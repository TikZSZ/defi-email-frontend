import {
  crypto_exports,
  init_crypto
} from "./chunk-OQENSXWV.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toModule
} from "./chunk-2HKET77T.js";

// node_modules/@hashgraph/cryptography/node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/@hashgraph/cryptography/node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function(nacl5) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init)
          for (i = 0; i < init.length; i++)
            r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes2) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes2 >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes2 -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f3, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f3 = this.h[0] + this.pad[0];
        this.h[0] = f3 & 65535;
        for (i = 1; i < 8; i++) {
          f3 = (this.h[i] + this.pad[i] | 0) + (f3 >>> 16) | 0;
          this.h[i] = f3 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes2) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes2)
            want = bytes2;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes2 -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (i = 0; i < bytes2; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes2;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f3 = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f3, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f3);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f3);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f3 = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f3, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f3);
        M(p[1], h, g);
        M(p[2], g, f3);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl5.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      nacl5.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl5.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl5.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl5.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl5.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl5.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl5.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl5.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl5.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl5.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl5.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl5.box.before(publicKey, secretKey);
        return nacl5.secretbox(msg, nonce, k);
      };
      nacl5.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl5.box.after = nacl5.secretbox;
      nacl5.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl5.box.before(publicKey, secretKey);
        return nacl5.secretbox.open(msg, nonce, k);
      };
      nacl5.box.open.after = nacl5.secretbox.open;
      nacl5.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl5.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl5.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl5.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl5.box.nonceLength = crypto_box_NONCEBYTES;
      nacl5.box.overheadLength = nacl5.secretbox.overheadLength;
      nacl5.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl5.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl5.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl5.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl5.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl5.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl5.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl5.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl5.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl5.sign.signatureLength = crypto_sign_BYTES;
      nacl5.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl5.hash.hashLength = crypto_hash_BYTES;
      nacl5.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl5.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto4 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto4 && crypto4.getRandomValues) {
          var QUOTA = 65536;
          nacl5.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto4.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto4 = (init_crypto(), crypto_exports);
          if (crypto4 && crypto4.randomBytes) {
            nacl5.setPRNG(function(x, n) {
              var i, v = crypto4.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports2, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// browser-external:buffer
var buffer_exports = {};
__export(buffer_exports, {
  default: () => buffer_default
});
var buffer_default;
var init_buffer = __esm({
  "browser-external:buffer"() {
    buffer_default = new Proxy({}, {
      get() {
        throw new Error('Module "buffer" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer = window.Buffer;
        } else {
          Buffer = (init_buffer(), buffer_exports).Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod2; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone2() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer !== "undefined");
        return this.toArrayLike(Buffer, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd2() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports2, module2) {
    module2.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode5(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    var BN = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w + 1;
      var k = num.clone();
      for (var i = 0; i < naf.length; i++) {
        var z;
        var mod2 = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod2 > (ws >> 1) - 1)
            z = (ws >> 1) - mod2;
          else
            z = mod2;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes2) {
      return typeof bytes2 === "string" ? utils.toArray(bytes2, "hex") : bytes2;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes2) {
      return new BN(bytes2, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports2, module2) {
    var r;
    module2.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module2.exports.Rand = Rand;
    Rand.prototype.generate = function generate2(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto4 = (init_crypto(), crypto_exports);
        if (typeof crypto4.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto4.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto4;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils2();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module2.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          null,
          null,
          points[b]
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
      bytes2 = utils.toArray(bytes2, enc);
      var len = this.p.byteLength();
      if ((bytes2[0] === 4 || bytes2[0] === 6 || bytes2[0] === 7) && bytes2.length - 1 === 2 * len) {
        if (bytes2[0] === 6)
          assert(bytes2[bytes2.length - 1] % 2 === 0);
        else if (bytes2[0] === 7)
          assert(bytes2[bytes2.length - 1] % 2 === 1);
        var res = this.point(bytes2.slice(1, 1 + len), bytes2.slice(1 + len, 1 + 2 * len));
        return res;
      } else if ((bytes2[0] === 2 || bytes2[0] === 3) && bytes2.length - 1 === len) {
        return this.pointFromX(bytes2.slice(1, 1 + len), bytes2[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode5(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module2.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd2 = y.fromRed().isOdd();
      if (odd && !isOdd2 || !odd && isOdd2)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new BN(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f3 = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f3.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
      return this.point(utils.toArray(bytes2, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd2 = y.fromRed().isOdd();
      if (odd && !isOdd2 || !odd && isOdd2)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f3 = g.redSub(c);
      var h = d.redSub(b);
      var nx = e.redMul(f3);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f3.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f3 = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f3.redSub(this.curve.two));
          ny = f3.redMul(e.redSub(d));
          nz = f3.redSqr().redSub(f3).redSub(f3);
        } else {
          h = this.z.redSqr();
          j = f3.redSub(h).redISub(h);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f3.redMul(e.redSub(d));
          nz = f3.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f3 = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx = e.redMul(f3);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f3.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f3 = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f3).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f3.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f3).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
    "use strict";
    var curve = exports2;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils3 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports2) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports2.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports2.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports2.toHex = toHex;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports2.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports2.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports2.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports2.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports2.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports2.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports2.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports2.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports2.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    exports2.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    exports2.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }
    exports2.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports2.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports2.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports2.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports2.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports2.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports2.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports2.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports2.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports2.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports2) {
    "use strict";
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports2.BlockHash = BlockHash;
    BlockHash.prototype.update = function update3(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest3(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes2 = this._delta8;
      var k = bytes2 - (len + this.padLength) % bytes2;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
    "use strict";
    var utils = require_utils3();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports2.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports2.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports2.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports2.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports2.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports2.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports2.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports2.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var assert = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f3 = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f3, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f3;
        f3 = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f3);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports2) {
    "use strict";
    exports2.sha1 = require__();
    exports2.sha224 = require__3();
    exports2.sha256 = require__2();
    exports2.sha384 = require__5();
    exports2.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports2.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update3(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(rotl32(sum32_4(A, f3(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(rotl32(sum32_4(Ah, f3(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f3(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function Hmac(hash2, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash2, key, enc);
      this.Hash = hash2;
      this.blockSize = hash2.blockSize / 8;
      this.outSize = hash2.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i = key.length; i < this.blockSize; i++)
        key.push(0);
      for (i = 0; i < key.length; i++)
        key[i] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i = 0; i < key.length; i++)
        key[i] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update3(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest3(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports2) {
    var hash2 = exports2;
    hash2.utils = require_utils3();
    hash2.common = require_common();
    hash2.sha = require_sha();
    hash2.ripemd = require_ripemd();
    hash2.hmac = require_hmac();
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
    "use strict";
    var curves = exports2;
    var hash2 = require_hash();
    var curve = require_curve();
    var utils = require_utils2();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash2.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash2.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash2.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
    "use strict";
    var hash2 = require_hash();
    var utils = require_utils();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy2 = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(entropy2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
      this._init(entropy2, nonce, pers);
    }
    module2.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy2, nonce, pers) {
      var seed = entropy2.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac6() {
      return new hash2.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update3(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy2, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy2 = utils.toArray(entropy2, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert(entropy2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
      this._update(entropy2.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate2(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils2();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module2.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive3(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign2(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify2(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils2();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module2.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i = 0;
      var len = buf.length - 1;
      while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils2();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module2.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes2 = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes2));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes2 = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes2);
      var nonce = msg.toArray("be", bytes2);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash2 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash2.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash2() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign2(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify2(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module2.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils2();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module2.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
    "use strict";
    var hash2 = require_hash();
    var curves = require_curves();
    var utils = require_utils2();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash2.sha512;
    }
    module2.exports = EDDSA;
    EDDSA.prototype.sign = function sign2(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify2(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash3 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash3.update(arguments[i]);
      return utils.intFromLE(hash3.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes2) {
      bytes2 = utils.parseBytes(bytes2);
      var lastIx = bytes2.length - 1;
      var normed = bytes2.slice(0, lastIx).concat(bytes2[lastIx] & ~128);
      var xIsOdd = (bytes2[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt2(bytes2) {
      return utils.intFromLE(bytes2);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports2) {
    "use strict";
    var elliptic2 = exports2;
    elliptic2.version = require_package().version;
    elliptic2.utils = require_utils2();
    elliptic2.rand = require_brorand();
    elliptic2.curve = require_curve();
    elliptic2.curves = require_curves();
    elliptic2.ec = require_ec();
    elliptic2.eddsa = require_eddsa();
  }
});

// node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/long/src/long.js"(exports2, module2) {
    module2.exports = Long39;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long39(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long39.prototype.__isLong__;
    Object.defineProperty(Long39.prototype, "__isLong__", { value: true });
    function isLong2(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long39.isLong = isLong2;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long39.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long39.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long39(lowBits, highBits, unsigned);
    }
    Long39.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString2(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString2(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long39.fromString = fromString2;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString2(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long39.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long39.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long39.UZERO = UZERO;
    var ONE = fromInt(1);
    Long39.ONE = ONE;
    var UONE = fromInt(1, true);
    Long39.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long39.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long39.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long39.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long39.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long39.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd2() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong2(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(other);
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(other) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(other) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare3(other) {
      if (!isLong2(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong2(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong2(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong2(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong2(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong2(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong2(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong2(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong2(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long39.fromBytes = function fromBytes2(bytes2, unsigned, le) {
      return le ? Long39.fromBytesLE(bytes2, unsigned) : Long39.fromBytesBE(bytes2, unsigned);
    };
    Long39.fromBytesLE = function fromBytesLE(bytes2, unsigned) {
      return new Long39(bytes2[0] | bytes2[1] << 8 | bytes2[2] << 16 | bytes2[3] << 24, bytes2[4] | bytes2[5] << 8 | bytes2[6] << 16 | bytes2[7] << 24, unsigned);
    };
    Long39.fromBytesBE = function fromBytesBE(bytes2, unsigned) {
      return new Long39(bytes2[4] << 24 | bytes2[5] << 16 | bytes2[6] << 8 | bytes2[7], bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3], unsigned);
    };
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base642 = exports2;
    base642.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base642.encode = function encode5(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode7(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign2 << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign2 << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf812 = exports2;
    utf812.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf812.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf812.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX2 = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX2)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util6 = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util6.isString(value)) {
        if (util6.Long)
          value = util6.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util6.Long ? new util6.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits((charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0, (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0);
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util6 = exports2;
    util6.asPromise = require_aspromise();
    util6.base64 = require_base64();
    util6.EventEmitter = require_eventemitter();
    util6.float = require_float();
    util6.inquire = require_inquire();
    util6.utf8 = require_utf8();
    util6.pool = require_pool();
    util6.LongBits = require_longbits();
    util6.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util6.global = util6.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util6.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util6.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util6.isInteger = Number.isInteger || function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util6.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util6.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util6.isset = util6.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util6.Buffer = function() {
      try {
        var Buffer = util6.inquire("buffer").Buffer;
        return Buffer.prototype.utf8Write ? Buffer : null;
      } catch (e) {
        return null;
      }
    }();
    util6._Buffer_from = null;
    util6._Buffer_allocUnsafe = null;
    util6.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util6.Buffer ? util6._Buffer_allocUnsafe(sizeOrArray) : new util6.Array(sizeOrArray) : util6.Buffer ? util6._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util6.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util6.Long = util6.global.dcodeIO && util6.global.dcodeIO.Long || util6.global.Long || util6.inquire("long");
    util6.key2Re = /^true|false|0|1$/;
    util6.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util6.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util6.longToHash = function longToHash(value) {
      return value ? util6.LongBits.from(value).toHash() : util6.LongBits.zeroHash;
    };
    util6.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util6.LongBits.fromHash(hash2);
      if (util6.Long)
        return util6.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util6.merge = merge;
    util6.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util6.newError = newError;
    util6.ProtocolError = newError("ProtocolError");
    util6.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util6.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util6.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util6._configure = function() {
      var Buffer = util6.Buffer;
      if (!Buffer) {
        util6._Buffer_from = util6._Buffer_allocUnsafe = null;
        return;
      }
      util6._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
      };
      util6._Buffer_allocUnsafe = Buffer.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util6 = require_minimal();
    var BufferWriter;
    var LongBits = util6.LongBits;
    var base642 = util6.base64;
    var utf812 = util6.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util6.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util6.Array(size);
    };
    if (util6.Array !== Array)
      Writer.alloc = util6.pool(Writer.alloc, util6.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util6.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util6.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util6.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util6.isString(value)) {
        var buf = Writer.alloc(len = base642.length(value));
        base642.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf812.length(value);
      return len ? this.uint32(len)._push(utf812.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util6 = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util6._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util6.Buffer && util6.Buffer.prototype instanceof Uint8Array && util6.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util6.isString(value))
        value = util6._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util6.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util6.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util6 = require_minimal();
    var BufferReader;
    var LongBits = util6.LongBits;
    var utf812 = util6.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util6.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util6.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util6.Array.prototype.subarray || util6.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util6.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util6.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes2 = this.bytes();
      return utf812.read(bytes2, 0, bytes2.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util6.Long ? "toLong" : "toNumber";
      util6.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util6 = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util6.Buffer)
        BufferReader.prototype._slice = util6.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util6 = require_minimal();
    (Service.prototype = Object.create(util6.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util6.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util6.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
          if (err) {
            self2.emit("error", err, method);
            return callback(err);
          }
          if (response === null) {
            self2.end(true);
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
          }
          self2.emit("data", response, method);
          return callback(null, response);
        });
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/@hashgraph/proto/lib/proto.js
var require_proto = __commonJS({
  "node_modules/@hashgraph/proto/lib/proto.js"(exports2) {
    "use strict";
    var $protobuf = _interopRequireWildcard(require_minimal2());
    Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = exports2.google = exports2.proto = void 0;
    function _getRequireWildcardCache(e) {
      if (typeof WeakMap != "function")
        return null;
      var o = new WeakMap(), t = new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : o;
      })(e);
    }
    function _interopRequireWildcard(e, o) {
      if (!o && e && e.__esModule)
        return e;
      if (e === null || typeof e != "object" && typeof e != "function")
        return { default: e };
      var t = _getRequireWildcardCache(o);
      if (t && t.has(e))
        return t.get(e);
      var n = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var i in e)
        if (i != "default" && Object.prototype.hasOwnProperty.call(e, i)) {
          var d = r ? Object.getOwnPropertyDescriptor(e, i) : null;
          d && (d.get || d.set) ? Object.defineProperty(n, i, d) : n[i] = e[i];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    exports2.default = $root;
    var proto19 = $root.proto = (() => {
      const e = { TokenUnitBalance: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.tokenId != null && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), e3.balance != null && Object.hasOwnProperty.call(e3, "balance") && o.uint32(16).uint64(e3.balance), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenUnitBalance(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.balance = e3.uint64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), SingleAccountBalances: function() {
        function e2(e3) {
          if (this.tokenUnitBalances = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountID = null, e2.prototype.hbarBalance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.tokenUnitBalances = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(10).fork()).ldelim(), e3.hbarBalance != null && Object.hasOwnProperty.call(e3, "hbarBalance") && o.uint32(16).uint64(e3.hbarBalance), e3.tokenUnitBalances != null && e3.tokenUnitBalances.length)
            for (var t = 0; t < e3.tokenUnitBalances.length; ++t)
              $root.proto.TokenUnitBalance.encode(e3.tokenUnitBalances[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.SingleAccountBalances(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 2:
                i.hbarBalance = e3.uint64();
                break;
              case 3:
                i.tokenUnitBalances && i.tokenUnitBalances.length || (i.tokenUnitBalances = []), i.tokenUnitBalances.push($root.proto.TokenUnitBalance.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), AllAccountBalances: function() {
        function e2(e3) {
          if (this.allAccounts = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.consensusTimestamp = null, e2.prototype.allAccounts = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.consensusTimestamp != null && Object.hasOwnProperty.call(e3, "consensusTimestamp") && $root.proto.Timestamp.encode(e3.consensusTimestamp, o.uint32(10).fork()).ldelim(), e3.allAccounts != null && e3.allAccounts.length)
            for (var t = 0; t < e3.allAccounts.length; ++t)
              $root.proto.SingleAccountBalances.encode(e3.allAccounts[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.AllAccountBalances(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.consensusTimestamp = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 2:
                i.allAccounts && i.allAccounts.length || (i.allAccounts = []), i.allAccounts.push($root.proto.SingleAccountBalances.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ShardID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.shardNum != null && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ShardID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.shardNum = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), RealmID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.shardNum != null && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), e3.realmNum != null && Object.hasOwnProperty.call(e3, "realmNum") && o.uint32(16).int64(e3.realmNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.RealmID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.shardNum = e3.int64();
                break;
              case 2:
                i.realmNum = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), AccountID: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.accountNum = null, e2.prototype.alias = null;
        let o;
        return Object.defineProperty(e2.prototype, "account", { get: $util.oneOfGetter(o = ["accountNum", "alias"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.shardNum != null && Object.hasOwnProperty.call(e3, "shardNum") && o2.uint32(8).int64(e3.shardNum), e3.realmNum != null && Object.hasOwnProperty.call(e3, "realmNum") && o2.uint32(16).int64(e3.realmNum), e3.accountNum != null && Object.hasOwnProperty.call(e3, "accountNum") && o2.uint32(24).int64(e3.accountNum), e3.alias != null && Object.hasOwnProperty.call(e3, "alias") && o2.uint32(34).bytes(e3.alias), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.AccountID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.shardNum = e3.int64();
                break;
              case 2:
                i.realmNum = e3.int64();
                break;
              case 3:
                i.accountNum = e3.int64();
                break;
              case 4:
                i.alias = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FileID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.fileNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.shardNum != null && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), e3.realmNum != null && Object.hasOwnProperty.call(e3, "realmNum") && o.uint32(16).int64(e3.realmNum), e3.fileNum != null && Object.hasOwnProperty.call(e3, "fileNum") && o.uint32(24).int64(e3.fileNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FileID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.shardNum = e3.int64();
                break;
              case 2:
                i.realmNum = e3.int64();
                break;
              case 3:
                i.fileNum = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.contractNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.shardNum != null && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), e3.realmNum != null && Object.hasOwnProperty.call(e3, "realmNum") && o.uint32(16).int64(e3.realmNum), e3.contractNum != null && Object.hasOwnProperty.call(e3, "contractNum") && o.uint32(24).int64(e3.contractNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.shardNum = e3.int64();
                break;
              case 2:
                i.realmNum = e3.int64();
                break;
              case 3:
                i.contractNum = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transactionValidStart = null, e2.prototype.accountID = null, e2.prototype.scheduled = false, e2.prototype.nonce = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.transactionValidStart != null && Object.hasOwnProperty.call(e3, "transactionValidStart") && $root.proto.Timestamp.encode(e3.transactionValidStart, o.uint32(10).fork()).ldelim(), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), e3.scheduled != null && Object.hasOwnProperty.call(e3, "scheduled") && o.uint32(24).bool(e3.scheduled), e3.nonce != null && Object.hasOwnProperty.call(e3, "nonce") && o.uint32(32).int32(e3.nonce), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransactionID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.transactionValidStart = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.scheduled = e3.bool();
                break;
              case 4:
                i.nonce = e3.int32();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), AccountAmount: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountID = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(10).fork()).ldelim(), e3.amount != null && Object.hasOwnProperty.call(e3, "amount") && o.uint32(16).sint64(e3.amount), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.AccountAmount(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 2:
                i.amount = e3.sint64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransferList: function() {
        function e2(e3) {
          if (this.accountAmounts = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountAmounts = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.accountAmounts != null && e3.accountAmounts.length)
            for (var t = 0; t < e3.accountAmounts.length; ++t)
              $root.proto.AccountAmount.encode(e3.accountAmounts[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransferList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.accountAmounts && i.accountAmounts.length || (i.accountAmounts = []), i.accountAmounts.push($root.proto.AccountAmount.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), NftTransfer: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.senderAccountID = null, e2.prototype.receiverAccountID = null, e2.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.senderAccountID != null && Object.hasOwnProperty.call(e3, "senderAccountID") && $root.proto.AccountID.encode(e3.senderAccountID, o.uint32(10).fork()).ldelim(), e3.receiverAccountID != null && Object.hasOwnProperty.call(e3, "receiverAccountID") && $root.proto.AccountID.encode(e3.receiverAccountID, o.uint32(18).fork()).ldelim(), e3.serialNumber != null && Object.hasOwnProperty.call(e3, "serialNumber") && o.uint32(24).int64(e3.serialNumber), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.NftTransfer(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.senderAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 2:
                i.receiverAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.serialNumber = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenTransferList: function() {
        function e2(e3) {
          if (this.transfers = [], this.nftTransfers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.transfers = $util.emptyArray, e2.prototype.nftTransfers = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), e3.transfers != null && e3.transfers.length)
            for (var t = 0; t < e3.transfers.length; ++t)
              $root.proto.AccountAmount.encode(e3.transfers[t], o.uint32(18).fork()).ldelim();
          if (e3.nftTransfers != null && e3.nftTransfers.length)
            for (var t = 0; t < e3.nftTransfers.length; ++t)
              $root.proto.NftTransfer.encode(e3.nftTransfers[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenTransferList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.transfers && i.transfers.length || (i.transfers = []), i.transfers.push($root.proto.AccountAmount.decode(e3, e3.uint32()));
                break;
              case 3:
                i.nftTransfers && i.nftTransfers.length || (i.nftTransfers = []), i.nftTransfers.push($root.proto.NftTransfer.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), Fraction: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.numerator = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.denominator = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.numerator != null && Object.hasOwnProperty.call(e3, "numerator") && o.uint32(8).int64(e3.numerator), e3.denominator != null && Object.hasOwnProperty.call(e3, "denominator") && o.uint32(16).int64(e3.denominator), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.Fraction(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.numerator = e3.int64();
                break;
              case 2:
                i.denominator = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TopicID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.topicNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.shardNum != null && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), e3.realmNum != null && Object.hasOwnProperty.call(e3, "realmNum") && o.uint32(16).int64(e3.realmNum), e3.topicNum != null && Object.hasOwnProperty.call(e3, "topicNum") && o.uint32(24).int64(e3.topicNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TopicID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.shardNum = e3.int64();
                break;
              case 2:
                i.realmNum = e3.int64();
                break;
              case 3:
                i.topicNum = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.tokenNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.shardNum != null && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), e3.realmNum != null && Object.hasOwnProperty.call(e3, "realmNum") && o.uint32(16).int64(e3.realmNum), e3.tokenNum != null && Object.hasOwnProperty.call(e3, "tokenNum") && o.uint32(24).int64(e3.tokenNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.shardNum = e3.int64();
                break;
              case 2:
                i.realmNum = e3.int64();
                break;
              case 3:
                i.tokenNum = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ScheduleID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.scheduleNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.shardNum != null && Object.hasOwnProperty.call(e3, "shardNum") && o.uint32(8).int64(e3.shardNum), e3.realmNum != null && Object.hasOwnProperty.call(e3, "realmNum") && o.uint32(16).int64(e3.realmNum), e3.scheduleNum != null && Object.hasOwnProperty.call(e3, "scheduleNum") && o.uint32(24).int64(e3.scheduleNum), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ScheduleID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.shardNum = e3.int64();
                break;
              case 2:
                i.realmNum = e3.int64();
                break;
              case 3:
                i.scheduleNum = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "FUNGIBLE_COMMON"] = 0, o[e2[1] = "NON_FUNGIBLE_UNIQUE"] = 1, o;
      }(), SubType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "DEFAULT"] = 0, o[e2[1] = "TOKEN_FUNGIBLE_COMMON"] = 1, o[e2[2] = "TOKEN_NON_FUNGIBLE_UNIQUE"] = 2, o[e2[3] = "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES"] = 3, o[e2[4] = "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES"] = 4, o;
      }(), TokenSupplyType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "INFINITE"] = 0, o[e2[1] = "FINITE"] = 1, o;
      }(), TokenFreezeStatus: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "FreezeNotApplicable"] = 0, o[e2[1] = "Frozen"] = 1, o[e2[2] = "Unfrozen"] = 2, o;
      }(), TokenKycStatus: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "KycNotApplicable"] = 0, o[e2[1] = "Granted"] = 1, o[e2[2] = "Revoked"] = 2, o;
      }(), TokenPauseStatus: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "PauseNotApplicable"] = 0, o[e2[1] = "Paused"] = 1, o[e2[2] = "Unpaused"] = 2, o;
      }(), Key: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.contractID = null, e2.prototype.ed25519 = null, e2.prototype.RSA_3072 = null, e2.prototype.ECDSA_384 = null, e2.prototype.thresholdKey = null, e2.prototype.keyList = null, e2.prototype.ECDSASecp256k1 = null, e2.prototype.delegatableContractId = null;
        let o;
        return Object.defineProperty(e2.prototype, "key", { get: $util.oneOfGetter(o = ["contractID", "ed25519", "RSA_3072", "ECDSA_384", "thresholdKey", "keyList", "ECDSASecp256k1", "delegatableContractId"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(10).fork()).ldelim(), e3.ed25519 != null && Object.hasOwnProperty.call(e3, "ed25519") && o2.uint32(18).bytes(e3.ed25519), e3.RSA_3072 != null && Object.hasOwnProperty.call(e3, "RSA_3072") && o2.uint32(26).bytes(e3.RSA_3072), e3.ECDSA_384 != null && Object.hasOwnProperty.call(e3, "ECDSA_384") && o2.uint32(34).bytes(e3.ECDSA_384), e3.thresholdKey != null && Object.hasOwnProperty.call(e3, "thresholdKey") && $root.proto.ThresholdKey.encode(e3.thresholdKey, o2.uint32(42).fork()).ldelim(), e3.keyList != null && Object.hasOwnProperty.call(e3, "keyList") && $root.proto.KeyList.encode(e3.keyList, o2.uint32(50).fork()).ldelim(), e3.ECDSASecp256k1 != null && Object.hasOwnProperty.call(e3, "ECDSASecp256k1") && o2.uint32(58).bytes(e3.ECDSASecp256k1), e3.delegatableContractId != null && Object.hasOwnProperty.call(e3, "delegatableContractId") && $root.proto.ContractID.encode(e3.delegatableContractId, o2.uint32(66).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.Key(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              case 2:
                i.ed25519 = e3.bytes();
                break;
              case 3:
                i.RSA_3072 = e3.bytes();
                break;
              case 4:
                i.ECDSA_384 = e3.bytes();
                break;
              case 5:
                i.thresholdKey = $root.proto.ThresholdKey.decode(e3, e3.uint32());
                break;
              case 6:
                i.keyList = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              case 7:
                i.ECDSASecp256k1 = e3.bytes();
                break;
              case 8:
                i.delegatableContractId = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ThresholdKey: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.threshold = 0, e2.prototype.keys = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.threshold != null && Object.hasOwnProperty.call(e3, "threshold") && o.uint32(8).uint32(e3.threshold), e3.keys != null && Object.hasOwnProperty.call(e3, "keys") && $root.proto.KeyList.encode(e3.keys, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ThresholdKey(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.threshold = e3.uint32();
                break;
              case 2:
                i.keys = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), KeyList: function() {
        function e2(e3) {
          if (this.keys = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.keys = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.keys != null && e3.keys.length)
            for (var t = 0; t < e3.keys.length; ++t)
              $root.proto.Key.encode(e3.keys[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.KeyList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.keys && i.keys.length || (i.keys = []), i.keys.push($root.proto.Key.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), Signature: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.contract = null, e2.prototype.ed25519 = null, e2.prototype.RSA_3072 = null, e2.prototype.ECDSA_384 = null, e2.prototype.thresholdSignature = null, e2.prototype.signatureList = null;
        let o;
        return Object.defineProperty(e2.prototype, "signature", { get: $util.oneOfGetter(o = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "thresholdSignature", "signatureList"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.contract != null && Object.hasOwnProperty.call(e3, "contract") && o2.uint32(10).bytes(e3.contract), e3.ed25519 != null && Object.hasOwnProperty.call(e3, "ed25519") && o2.uint32(18).bytes(e3.ed25519), e3.RSA_3072 != null && Object.hasOwnProperty.call(e3, "RSA_3072") && o2.uint32(26).bytes(e3.RSA_3072), e3.ECDSA_384 != null && Object.hasOwnProperty.call(e3, "ECDSA_384") && o2.uint32(34).bytes(e3.ECDSA_384), e3.thresholdSignature != null && Object.hasOwnProperty.call(e3, "thresholdSignature") && $root.proto.ThresholdSignature.encode(e3.thresholdSignature, o2.uint32(42).fork()).ldelim(), e3.signatureList != null && Object.hasOwnProperty.call(e3, "signatureList") && $root.proto.SignatureList.encode(e3.signatureList, o2.uint32(50).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.Signature(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.contract = e3.bytes();
                break;
              case 2:
                i.ed25519 = e3.bytes();
                break;
              case 3:
                i.RSA_3072 = e3.bytes();
                break;
              case 4:
                i.ECDSA_384 = e3.bytes();
                break;
              case 5:
                i.thresholdSignature = $root.proto.ThresholdSignature.decode(e3, e3.uint32());
                break;
              case 6:
                i.signatureList = $root.proto.SignatureList.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ThresholdSignature: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.sigs = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.sigs != null && Object.hasOwnProperty.call(e3, "sigs") && $root.proto.SignatureList.encode(e3.sigs, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ThresholdSignature(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2:
                i.sigs = $root.proto.SignatureList.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), SignatureList: function() {
        function e2(e3) {
          if (this.sigs = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.sigs = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.sigs != null && e3.sigs.length)
            for (var t = 0; t < e3.sigs.length; ++t)
              $root.proto.Signature.encode(e3.sigs[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.SignatureList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2:
                i.sigs && i.sigs.length || (i.sigs = []), i.sigs.push($root.proto.Signature.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), SignaturePair: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.pubKeyPrefix = $util.newBuffer([]), e2.prototype.contract = null, e2.prototype.ed25519 = null, e2.prototype.RSA_3072 = null, e2.prototype.ECDSA_384 = null, e2.prototype.ECDSASecp256k1 = null;
        let o;
        return Object.defineProperty(e2.prototype, "signature", { get: $util.oneOfGetter(o = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "ECDSASecp256k1"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.pubKeyPrefix != null && Object.hasOwnProperty.call(e3, "pubKeyPrefix") && o2.uint32(10).bytes(e3.pubKeyPrefix), e3.contract != null && Object.hasOwnProperty.call(e3, "contract") && o2.uint32(18).bytes(e3.contract), e3.ed25519 != null && Object.hasOwnProperty.call(e3, "ed25519") && o2.uint32(26).bytes(e3.ed25519), e3.RSA_3072 != null && Object.hasOwnProperty.call(e3, "RSA_3072") && o2.uint32(34).bytes(e3.RSA_3072), e3.ECDSA_384 != null && Object.hasOwnProperty.call(e3, "ECDSA_384") && o2.uint32(42).bytes(e3.ECDSA_384), e3.ECDSASecp256k1 != null && Object.hasOwnProperty.call(e3, "ECDSASecp256k1") && o2.uint32(50).bytes(e3.ECDSASecp256k1), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.SignaturePair(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.pubKeyPrefix = e3.bytes();
                break;
              case 2:
                i.contract = e3.bytes();
                break;
              case 3:
                i.ed25519 = e3.bytes();
                break;
              case 4:
                i.RSA_3072 = e3.bytes();
                break;
              case 5:
                i.ECDSA_384 = e3.bytes();
                break;
              case 6:
                i.ECDSASecp256k1 = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), SignatureMap: function() {
        function e2(e3) {
          if (this.sigPair = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.sigPair = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.sigPair != null && e3.sigPair.length)
            for (var t = 0; t < e3.sigPair.length; ++t)
              $root.proto.SignaturePair.encode(e3.sigPair[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.SignatureMap(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.sigPair && i.sigPair.length || (i.sigPair = []), i.sigPair.push($root.proto.SignaturePair.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), HederaFunctionality: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "NONE"] = 0, o[e2[1] = "CryptoTransfer"] = 1, o[e2[2] = "CryptoUpdate"] = 2, o[e2[3] = "CryptoDelete"] = 3, o[e2[4] = "CryptoAddLiveHash"] = 4, o[e2[5] = "CryptoDeleteLiveHash"] = 5, o[e2[6] = "ContractCall"] = 6, o[e2[7] = "ContractCreate"] = 7, o[e2[8] = "ContractUpdate"] = 8, o[e2[9] = "FileCreate"] = 9, o[e2[10] = "FileAppend"] = 10, o[e2[11] = "FileUpdate"] = 11, o[e2[12] = "FileDelete"] = 12, o[e2[13] = "CryptoGetAccountBalance"] = 13, o[e2[14] = "CryptoGetAccountRecords"] = 14, o[e2[15] = "CryptoGetInfo"] = 15, o[e2[16] = "ContractCallLocal"] = 16, o[e2[17] = "ContractGetInfo"] = 17, o[e2[18] = "ContractGetBytecode"] = 18, o[e2[19] = "GetBySolidityID"] = 19, o[e2[20] = "GetByKey"] = 20, o[e2[21] = "CryptoGetLiveHash"] = 21, o[e2[22] = "CryptoGetStakers"] = 22, o[e2[23] = "FileGetContents"] = 23, o[e2[24] = "FileGetInfo"] = 24, o[e2[25] = "TransactionGetRecord"] = 25, o[e2[26] = "ContractGetRecords"] = 26, o[e2[27] = "CryptoCreate"] = 27, o[e2[28] = "SystemDelete"] = 28, o[e2[29] = "SystemUndelete"] = 29, o[e2[30] = "ContractDelete"] = 30, o[e2[31] = "Freeze"] = 31, o[e2[32] = "CreateTransactionRecord"] = 32, o[e2[33] = "CryptoAccountAutoRenew"] = 33, o[e2[34] = "ContractAutoRenew"] = 34, o[e2[35] = "GetVersionInfo"] = 35, o[e2[36] = "TransactionGetReceipt"] = 36, o[e2[50] = "ConsensusCreateTopic"] = 50, o[e2[51] = "ConsensusUpdateTopic"] = 51, o[e2[52] = "ConsensusDeleteTopic"] = 52, o[e2[53] = "ConsensusGetTopicInfo"] = 53, o[e2[54] = "ConsensusSubmitMessage"] = 54, o[e2[55] = "UncheckedSubmit"] = 55, o[e2[56] = "TokenCreate"] = 56, o[e2[58] = "TokenGetInfo"] = 58, o[e2[59] = "TokenFreezeAccount"] = 59, o[e2[60] = "TokenUnfreezeAccount"] = 60, o[e2[61] = "TokenGrantKycToAccount"] = 61, o[e2[62] = "TokenRevokeKycFromAccount"] = 62, o[e2[63] = "TokenDelete"] = 63, o[e2[64] = "TokenUpdate"] = 64, o[e2[65] = "TokenMint"] = 65, o[e2[66] = "TokenBurn"] = 66, o[e2[67] = "TokenAccountWipe"] = 67, o[e2[68] = "TokenAssociateToAccount"] = 68, o[e2[69] = "TokenDissociateFromAccount"] = 69, o[e2[70] = "ScheduleCreate"] = 70, o[e2[71] = "ScheduleDelete"] = 71, o[e2[72] = "ScheduleSign"] = 72, o[e2[73] = "ScheduleGetInfo"] = 73, o[e2[74] = "TokenGetAccountNftInfos"] = 74, o[e2[75] = "TokenGetNftInfo"] = 75, o[e2[76] = "TokenGetNftInfos"] = 76, o[e2[77] = "TokenFeeScheduleUpdate"] = 77, o[e2[78] = "NetworkGetExecutionTime"] = 78, o[e2[79] = "TokenPause"] = 79, o[e2[80] = "TokenUnpause"] = 80, o;
      }(), FeeComponents: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.min = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.max = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.constant = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.bpt = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.vpt = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.rbh = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.sbh = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.tv = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.bpr = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.sbpr = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.min != null && Object.hasOwnProperty.call(e3, "min") && o.uint32(8).int64(e3.min), e3.max != null && Object.hasOwnProperty.call(e3, "max") && o.uint32(16).int64(e3.max), e3.constant != null && Object.hasOwnProperty.call(e3, "constant") && o.uint32(24).int64(e3.constant), e3.bpt != null && Object.hasOwnProperty.call(e3, "bpt") && o.uint32(32).int64(e3.bpt), e3.vpt != null && Object.hasOwnProperty.call(e3, "vpt") && o.uint32(40).int64(e3.vpt), e3.rbh != null && Object.hasOwnProperty.call(e3, "rbh") && o.uint32(48).int64(e3.rbh), e3.sbh != null && Object.hasOwnProperty.call(e3, "sbh") && o.uint32(56).int64(e3.sbh), e3.gas != null && Object.hasOwnProperty.call(e3, "gas") && o.uint32(64).int64(e3.gas), e3.tv != null && Object.hasOwnProperty.call(e3, "tv") && o.uint32(72).int64(e3.tv), e3.bpr != null && Object.hasOwnProperty.call(e3, "bpr") && o.uint32(80).int64(e3.bpr), e3.sbpr != null && Object.hasOwnProperty.call(e3, "sbpr") && o.uint32(88).int64(e3.sbpr), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FeeComponents(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.min = e3.int64();
                break;
              case 2:
                i.max = e3.int64();
                break;
              case 3:
                i.constant = e3.int64();
                break;
              case 4:
                i.bpt = e3.int64();
                break;
              case 5:
                i.vpt = e3.int64();
                break;
              case 6:
                i.rbh = e3.int64();
                break;
              case 7:
                i.sbh = e3.int64();
                break;
              case 8:
                i.gas = e3.int64();
                break;
              case 9:
                i.tv = e3.int64();
                break;
              case 10:
                i.bpr = e3.int64();
                break;
              case 11:
                i.sbpr = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionFeeSchedule: function() {
        function e2(e3) {
          if (this.fees = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.hederaFunctionality = 0, e2.prototype.feeData = null, e2.prototype.fees = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.hederaFunctionality != null && Object.hasOwnProperty.call(e3, "hederaFunctionality") && o.uint32(8).int32(e3.hederaFunctionality), e3.feeData != null && Object.hasOwnProperty.call(e3, "feeData") && $root.proto.FeeData.encode(e3.feeData, o.uint32(18).fork()).ldelim(), e3.fees != null && e3.fees.length)
            for (var t = 0; t < e3.fees.length; ++t)
              $root.proto.FeeData.encode(e3.fees[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransactionFeeSchedule(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.hederaFunctionality = e3.int32();
                break;
              case 2:
                i.feeData = $root.proto.FeeData.decode(e3, e3.uint32());
                break;
              case 3:
                i.fees && i.fees.length || (i.fees = []), i.fees.push($root.proto.FeeData.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FeeData: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nodedata = null, e2.prototype.networkdata = null, e2.prototype.servicedata = null, e2.prototype.subType = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.nodedata != null && Object.hasOwnProperty.call(e3, "nodedata") && $root.proto.FeeComponents.encode(e3.nodedata, o.uint32(10).fork()).ldelim(), e3.networkdata != null && Object.hasOwnProperty.call(e3, "networkdata") && $root.proto.FeeComponents.encode(e3.networkdata, o.uint32(18).fork()).ldelim(), e3.servicedata != null && Object.hasOwnProperty.call(e3, "servicedata") && $root.proto.FeeComponents.encode(e3.servicedata, o.uint32(26).fork()).ldelim(), e3.subType != null && Object.hasOwnProperty.call(e3, "subType") && o.uint32(32).int32(e3.subType), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FeeData(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.nodedata = $root.proto.FeeComponents.decode(e3, e3.uint32());
                break;
              case 2:
                i.networkdata = $root.proto.FeeComponents.decode(e3, e3.uint32());
                break;
              case 3:
                i.servicedata = $root.proto.FeeComponents.decode(e3, e3.uint32());
                break;
              case 4:
                i.subType = e3.int32();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FeeSchedule: function() {
        function e2(e3) {
          if (this.transactionFeeSchedule = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transactionFeeSchedule = $util.emptyArray, e2.prototype.expiryTime = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.transactionFeeSchedule != null && e3.transactionFeeSchedule.length)
            for (var t = 0; t < e3.transactionFeeSchedule.length; ++t)
              $root.proto.TransactionFeeSchedule.encode(e3.transactionFeeSchedule[t], o.uint32(10).fork()).ldelim();
          return e3.expiryTime != null && Object.hasOwnProperty.call(e3, "expiryTime") && $root.proto.TimestampSeconds.encode(e3.expiryTime, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FeeSchedule(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.transactionFeeSchedule && i.transactionFeeSchedule.length || (i.transactionFeeSchedule = []), i.transactionFeeSchedule.push($root.proto.TransactionFeeSchedule.decode(e3, e3.uint32()));
                break;
              case 2:
                i.expiryTime = $root.proto.TimestampSeconds.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CurrentAndNextFeeSchedule: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.currentFeeSchedule = null, e2.prototype.nextFeeSchedule = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.currentFeeSchedule != null && Object.hasOwnProperty.call(e3, "currentFeeSchedule") && $root.proto.FeeSchedule.encode(e3.currentFeeSchedule, o.uint32(10).fork()).ldelim(), e3.nextFeeSchedule != null && Object.hasOwnProperty.call(e3, "nextFeeSchedule") && $root.proto.FeeSchedule.encode(e3.nextFeeSchedule, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CurrentAndNextFeeSchedule(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.currentFeeSchedule = $root.proto.FeeSchedule.decode(e3, e3.uint32());
                break;
              case 2:
                i.nextFeeSchedule = $root.proto.FeeSchedule.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ServiceEndpoint: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.ipAddressV4 = $util.newBuffer([]), e2.prototype.port = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.ipAddressV4 != null && Object.hasOwnProperty.call(e3, "ipAddressV4") && o.uint32(10).bytes(e3.ipAddressV4), e3.port != null && Object.hasOwnProperty.call(e3, "port") && o.uint32(16).int32(e3.port), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ServiceEndpoint(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.ipAddressV4 = e3.bytes();
                break;
              case 2:
                i.port = e3.int32();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), NodeAddress: function() {
        function e2(e3) {
          if (this.serviceEndpoint = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.ipAddress = $util.newBuffer([]), e2.prototype.portno = 0, e2.prototype.memo = $util.newBuffer([]), e2.prototype.RSA_PubKey = "", e2.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.nodeAccountId = null, e2.prototype.nodeCertHash = $util.newBuffer([]), e2.prototype.serviceEndpoint = $util.emptyArray, e2.prototype.description = "", e2.prototype.stake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.ipAddress != null && Object.hasOwnProperty.call(e3, "ipAddress") && o.uint32(10).bytes(e3.ipAddress), e3.portno != null && Object.hasOwnProperty.call(e3, "portno") && o.uint32(16).int32(e3.portno), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o.uint32(26).bytes(e3.memo), e3.RSA_PubKey != null && Object.hasOwnProperty.call(e3, "RSA_PubKey") && o.uint32(34).string(e3.RSA_PubKey), e3.nodeId != null && Object.hasOwnProperty.call(e3, "nodeId") && o.uint32(40).int64(e3.nodeId), e3.nodeAccountId != null && Object.hasOwnProperty.call(e3, "nodeAccountId") && $root.proto.AccountID.encode(e3.nodeAccountId, o.uint32(50).fork()).ldelim(), e3.nodeCertHash != null && Object.hasOwnProperty.call(e3, "nodeCertHash") && o.uint32(58).bytes(e3.nodeCertHash), e3.serviceEndpoint != null && e3.serviceEndpoint.length)
            for (var t = 0; t < e3.serviceEndpoint.length; ++t)
              $root.proto.ServiceEndpoint.encode(e3.serviceEndpoint[t], o.uint32(66).fork()).ldelim();
          return e3.description != null && Object.hasOwnProperty.call(e3, "description") && o.uint32(74).string(e3.description), e3.stake != null && Object.hasOwnProperty.call(e3, "stake") && o.uint32(80).int64(e3.stake), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.NodeAddress(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.ipAddress = e3.bytes();
                break;
              case 2:
                i.portno = e3.int32();
                break;
              case 3:
                i.memo = e3.bytes();
                break;
              case 4:
                i.RSA_PubKey = e3.string();
                break;
              case 5:
                i.nodeId = e3.int64();
                break;
              case 6:
                i.nodeAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 7:
                i.nodeCertHash = e3.bytes();
                break;
              case 8:
                i.serviceEndpoint && i.serviceEndpoint.length || (i.serviceEndpoint = []), i.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(e3, e3.uint32()));
                break;
              case 9:
                i.description = e3.string();
                break;
              case 10:
                i.stake = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), NodeAddressBook: function() {
        function e2(e3) {
          if (this.nodeAddress = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nodeAddress = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.nodeAddress != null && e3.nodeAddress.length)
            for (var t = 0; t < e3.nodeAddress.length; ++t)
              $root.proto.NodeAddress.encode(e3.nodeAddress[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.NodeAddressBook(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.nodeAddress && i.nodeAddress.length || (i.nodeAddress = []), i.nodeAddress.push($root.proto.NodeAddress.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), SemanticVersion: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.major = 0, e2.prototype.minor = 0, e2.prototype.patch = 0, e2.prototype.pre = "", e2.prototype.build = "", e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.major != null && Object.hasOwnProperty.call(e3, "major") && o.uint32(8).int32(e3.major), e3.minor != null && Object.hasOwnProperty.call(e3, "minor") && o.uint32(16).int32(e3.minor), e3.patch != null && Object.hasOwnProperty.call(e3, "patch") && o.uint32(24).int32(e3.patch), e3.pre != null && Object.hasOwnProperty.call(e3, "pre") && o.uint32(34).string(e3.pre), e3.build != null && Object.hasOwnProperty.call(e3, "build") && o.uint32(42).string(e3.build), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.SemanticVersion(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.major = e3.int32();
                break;
              case 2:
                i.minor = e3.int32();
                break;
              case 3:
                i.patch = e3.int32();
                break;
              case 4:
                i.pre = e3.string();
                break;
              case 5:
                i.build = e3.string();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), Setting: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.name = "", e2.prototype.value = "", e2.prototype.data = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.name != null && Object.hasOwnProperty.call(e3, "name") && o.uint32(10).string(e3.name), e3.value != null && Object.hasOwnProperty.call(e3, "value") && o.uint32(18).string(e3.value), e3.data != null && Object.hasOwnProperty.call(e3, "data") && o.uint32(26).bytes(e3.data), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.Setting(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.name = e3.string();
                break;
              case 2:
                i.value = e3.string();
                break;
              case 3:
                i.data = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ServicesConfigurationList: function() {
        function e2(e3) {
          if (this.nameValue = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nameValue = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.nameValue != null && e3.nameValue.length)
            for (var t = 0; t < e3.nameValue.length; ++t)
              $root.proto.Setting.encode(e3.nameValue[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ServicesConfigurationList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.nameValue && i.nameValue.length || (i.nameValue = []), i.nameValue.push($root.proto.Setting.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenRelationship: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.symbol = "", e2.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.kycStatus = 0, e2.prototype.freezeStatus = 0, e2.prototype.decimals = 0, e2.prototype.automaticAssociation = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.tokenId != null && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), e3.symbol != null && Object.hasOwnProperty.call(e3, "symbol") && o.uint32(18).string(e3.symbol), e3.balance != null && Object.hasOwnProperty.call(e3, "balance") && o.uint32(24).uint64(e3.balance), e3.kycStatus != null && Object.hasOwnProperty.call(e3, "kycStatus") && o.uint32(32).int32(e3.kycStatus), e3.freezeStatus != null && Object.hasOwnProperty.call(e3, "freezeStatus") && o.uint32(40).int32(e3.freezeStatus), e3.decimals != null && Object.hasOwnProperty.call(e3, "decimals") && o.uint32(48).uint32(e3.decimals), e3.automaticAssociation != null && Object.hasOwnProperty.call(e3, "automaticAssociation") && o.uint32(56).bool(e3.automaticAssociation), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenRelationship(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.symbol = e3.string();
                break;
              case 3:
                i.balance = e3.uint64();
                break;
              case 4:
                i.kycStatus = e3.int32();
                break;
              case 5:
                i.freezeStatus = e3.int32();
                break;
              case 6:
                i.decimals = e3.uint32();
                break;
              case 7:
                i.automaticAssociation = e3.bool();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenBalance: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.decimals = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.tokenId != null && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), e3.balance != null && Object.hasOwnProperty.call(e3, "balance") && o.uint32(16).uint64(e3.balance), e3.decimals != null && Object.hasOwnProperty.call(e3, "decimals") && o.uint32(24).uint32(e3.decimals), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenBalance(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.balance = e3.uint64();
                break;
              case 3:
                i.decimals = e3.uint32();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenBalances: function() {
        function e2(e3) {
          if (this.tokenBalances = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenBalances = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.tokenBalances != null && e3.tokenBalances.length)
            for (var t = 0; t < e3.tokenBalances.length; ++t)
              $root.proto.TokenBalance.encode(e3.tokenBalances[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenBalances(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.tokenBalances && i.tokenBalances.length || (i.tokenBalances = []), i.tokenBalances.push($root.proto.TokenBalance.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenAssociation: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.accountId = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.tokenId != null && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), e3.accountId != null && Object.hasOwnProperty.call(e3, "accountId") && $root.proto.AccountID.encode(e3.accountId, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenAssociation(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), Timestamp: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.nanos = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.seconds != null && Object.hasOwnProperty.call(e3, "seconds") && o.uint32(8).int64(e3.seconds), e3.nanos != null && Object.hasOwnProperty.call(e3, "nanos") && o.uint32(16).int32(e3.nanos), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.Timestamp(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.seconds = e3.int64();
                break;
              case 2:
                i.nanos = e3.int32();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TimestampSeconds: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.seconds != null && Object.hasOwnProperty.call(e3, "seconds") && o.uint32(8).int64(e3.seconds), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TimestampSeconds(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.seconds = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ConsensusCreateTopicTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.memo = "", e2.prototype.adminKey = null, e2.prototype.submitKey = null, e2.prototype.autoRenewPeriod = null, e2.prototype.autoRenewAccount = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o.uint32(10).string(e3.memo), e3.adminKey != null && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(18).fork()).ldelim(), e3.submitKey != null && Object.hasOwnProperty.call(e3, "submitKey") && $root.proto.Key.encode(e3.submitKey, o.uint32(26).fork()).ldelim(), e3.autoRenewPeriod != null && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(50).fork()).ldelim(), e3.autoRenewAccount != null && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(58).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ConsensusCreateTopicTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.memo = e3.string();
                break;
              case 2:
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 3:
                i.submitKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 6:
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              case 7:
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), Duration: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.seconds != null && Object.hasOwnProperty.call(e3, "seconds") && o.uint32(8).int64(e3.seconds), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.Duration(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.seconds = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ConsensusDeleteTopicTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.topicID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.topicID != null && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ConsensusDeleteTopicTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ConsensusGetTopicInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.topicID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.topicID != null && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ConsensusGetTopicInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ConsensusGetTopicInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.topicID = null, e2.prototype.topicInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.topicID != null && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(18).fork()).ldelim(), e3.topicInfo != null && Object.hasOwnProperty.call(e3, "topicInfo") && $root.proto.ConsensusTopicInfo.encode(e3.topicInfo, o.uint32(42).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ConsensusGetTopicInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              case 5:
                i.topicInfo = $root.proto.ConsensusTopicInfo.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ResponseType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "ANSWER_ONLY"] = 0, o[e2[1] = "ANSWER_STATE_PROOF"] = 1, o[e2[2] = "COST_ANSWER"] = 2, o[e2[3] = "COST_ANSWER_STATE_PROOF"] = 3, o;
      }(), QueryHeader: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.payment = null, e2.prototype.responseType = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.payment != null && Object.hasOwnProperty.call(e3, "payment") && $root.proto.Transaction.encode(e3.payment, o.uint32(10).fork()).ldelim(), e3.responseType != null && Object.hasOwnProperty.call(e3, "responseType") && o.uint32(16).int32(e3.responseType), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.QueryHeader(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.payment = $root.proto.Transaction.decode(e3, e3.uint32());
                break;
              case 2:
                i.responseType = e3.int32();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), Transaction: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.body = null, e2.prototype.sigs = null, e2.prototype.sigMap = null, e2.prototype.bodyBytes = $util.newBuffer([]), e2.prototype.signedTransactionBytes = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.body != null && Object.hasOwnProperty.call(e3, "body") && $root.proto.TransactionBody.encode(e3.body, o.uint32(10).fork()).ldelim(), e3.sigs != null && Object.hasOwnProperty.call(e3, "sigs") && $root.proto.SignatureList.encode(e3.sigs, o.uint32(18).fork()).ldelim(), e3.sigMap != null && Object.hasOwnProperty.call(e3, "sigMap") && $root.proto.SignatureMap.encode(e3.sigMap, o.uint32(26).fork()).ldelim(), e3.bodyBytes != null && Object.hasOwnProperty.call(e3, "bodyBytes") && o.uint32(34).bytes(e3.bodyBytes), e3.signedTransactionBytes != null && Object.hasOwnProperty.call(e3, "signedTransactionBytes") && o.uint32(42).bytes(e3.signedTransactionBytes), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.Transaction(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.body = $root.proto.TransactionBody.decode(e3, e3.uint32());
                break;
              case 2:
                i.sigs = $root.proto.SignatureList.decode(e3, e3.uint32());
                break;
              case 3:
                i.sigMap = $root.proto.SignatureMap.decode(e3, e3.uint32());
                break;
              case 4:
                i.bodyBytes = e3.bytes();
                break;
              case 5:
                i.signedTransactionBytes = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.transactionID = null, e2.prototype.nodeAccountID = null, e2.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.transactionValidDuration = null, e2.prototype.generateRecord = false, e2.prototype.memo = "", e2.prototype.contractCall = null, e2.prototype.contractCreateInstance = null, e2.prototype.contractUpdateInstance = null, e2.prototype.contractDeleteInstance = null, e2.prototype.cryptoAddLiveHash = null, e2.prototype.cryptoCreateAccount = null, e2.prototype.cryptoDelete = null, e2.prototype.cryptoDeleteLiveHash = null, e2.prototype.cryptoTransfer = null, e2.prototype.cryptoUpdateAccount = null, e2.prototype.fileAppend = null, e2.prototype.fileCreate = null, e2.prototype.fileDelete = null, e2.prototype.fileUpdate = null, e2.prototype.systemDelete = null, e2.prototype.systemUndelete = null, e2.prototype.freeze = null, e2.prototype.consensusCreateTopic = null, e2.prototype.consensusUpdateTopic = null, e2.prototype.consensusDeleteTopic = null, e2.prototype.consensusSubmitMessage = null, e2.prototype.uncheckedSubmit = null, e2.prototype.tokenCreation = null, e2.prototype.tokenFreeze = null, e2.prototype.tokenUnfreeze = null, e2.prototype.tokenGrantKyc = null, e2.prototype.tokenRevokeKyc = null, e2.prototype.tokenDeletion = null, e2.prototype.tokenUpdate = null, e2.prototype.tokenMint = null, e2.prototype.tokenBurn = null, e2.prototype.tokenWipe = null, e2.prototype.tokenAssociate = null, e2.prototype.tokenDissociate = null, e2.prototype.tokenFeeScheduleUpdate = null, e2.prototype.tokenPause = null, e2.prototype.tokenUnpause = null, e2.prototype.scheduleCreate = null, e2.prototype.scheduleDelete = null, e2.prototype.scheduleSign = null;
        let o;
        return Object.defineProperty(e2.prototype, "data", { get: $util.oneOfGetter(o = ["contractCall", "contractCreateInstance", "contractUpdateInstance", "contractDeleteInstance", "cryptoAddLiveHash", "cryptoCreateAccount", "cryptoDelete", "cryptoDeleteLiveHash", "cryptoTransfer", "cryptoUpdateAccount", "fileAppend", "fileCreate", "fileDelete", "fileUpdate", "systemDelete", "systemUndelete", "freeze", "consensusCreateTopic", "consensusUpdateTopic", "consensusDeleteTopic", "consensusSubmitMessage", "uncheckedSubmit", "tokenCreation", "tokenFreeze", "tokenUnfreeze", "tokenGrantKyc", "tokenRevokeKyc", "tokenDeletion", "tokenUpdate", "tokenMint", "tokenBurn", "tokenWipe", "tokenAssociate", "tokenDissociate", "tokenFeeScheduleUpdate", "tokenPause", "tokenUnpause", "scheduleCreate", "scheduleDelete", "scheduleSign"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.transactionID != null && Object.hasOwnProperty.call(e3, "transactionID") && $root.proto.TransactionID.encode(e3.transactionID, o2.uint32(10).fork()).ldelim(), e3.nodeAccountID != null && Object.hasOwnProperty.call(e3, "nodeAccountID") && $root.proto.AccountID.encode(e3.nodeAccountID, o2.uint32(18).fork()).ldelim(), e3.transactionFee != null && Object.hasOwnProperty.call(e3, "transactionFee") && o2.uint32(24).uint64(e3.transactionFee), e3.transactionValidDuration != null && Object.hasOwnProperty.call(e3, "transactionValidDuration") && $root.proto.Duration.encode(e3.transactionValidDuration, o2.uint32(34).fork()).ldelim(), e3.generateRecord != null && Object.hasOwnProperty.call(e3, "generateRecord") && o2.uint32(40).bool(e3.generateRecord), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(50).string(e3.memo), e3.contractCall != null && Object.hasOwnProperty.call(e3, "contractCall") && $root.proto.ContractCallTransactionBody.encode(e3.contractCall, o2.uint32(58).fork()).ldelim(), e3.contractCreateInstance != null && Object.hasOwnProperty.call(e3, "contractCreateInstance") && $root.proto.ContractCreateTransactionBody.encode(e3.contractCreateInstance, o2.uint32(66).fork()).ldelim(), e3.contractUpdateInstance != null && Object.hasOwnProperty.call(e3, "contractUpdateInstance") && $root.proto.ContractUpdateTransactionBody.encode(e3.contractUpdateInstance, o2.uint32(74).fork()).ldelim(), e3.cryptoAddLiveHash != null && Object.hasOwnProperty.call(e3, "cryptoAddLiveHash") && $root.proto.CryptoAddLiveHashTransactionBody.encode(e3.cryptoAddLiveHash, o2.uint32(82).fork()).ldelim(), e3.cryptoCreateAccount != null && Object.hasOwnProperty.call(e3, "cryptoCreateAccount") && $root.proto.CryptoCreateTransactionBody.encode(e3.cryptoCreateAccount, o2.uint32(90).fork()).ldelim(), e3.cryptoDelete != null && Object.hasOwnProperty.call(e3, "cryptoDelete") && $root.proto.CryptoDeleteTransactionBody.encode(e3.cryptoDelete, o2.uint32(98).fork()).ldelim(), e3.cryptoDeleteLiveHash != null && Object.hasOwnProperty.call(e3, "cryptoDeleteLiveHash") && $root.proto.CryptoDeleteLiveHashTransactionBody.encode(e3.cryptoDeleteLiveHash, o2.uint32(106).fork()).ldelim(), e3.cryptoTransfer != null && Object.hasOwnProperty.call(e3, "cryptoTransfer") && $root.proto.CryptoTransferTransactionBody.encode(e3.cryptoTransfer, o2.uint32(114).fork()).ldelim(), e3.cryptoUpdateAccount != null && Object.hasOwnProperty.call(e3, "cryptoUpdateAccount") && $root.proto.CryptoUpdateTransactionBody.encode(e3.cryptoUpdateAccount, o2.uint32(122).fork()).ldelim(), e3.fileAppend != null && Object.hasOwnProperty.call(e3, "fileAppend") && $root.proto.FileAppendTransactionBody.encode(e3.fileAppend, o2.uint32(130).fork()).ldelim(), e3.fileCreate != null && Object.hasOwnProperty.call(e3, "fileCreate") && $root.proto.FileCreateTransactionBody.encode(e3.fileCreate, o2.uint32(138).fork()).ldelim(), e3.fileDelete != null && Object.hasOwnProperty.call(e3, "fileDelete") && $root.proto.FileDeleteTransactionBody.encode(e3.fileDelete, o2.uint32(146).fork()).ldelim(), e3.fileUpdate != null && Object.hasOwnProperty.call(e3, "fileUpdate") && $root.proto.FileUpdateTransactionBody.encode(e3.fileUpdate, o2.uint32(154).fork()).ldelim(), e3.systemDelete != null && Object.hasOwnProperty.call(e3, "systemDelete") && $root.proto.SystemDeleteTransactionBody.encode(e3.systemDelete, o2.uint32(162).fork()).ldelim(), e3.systemUndelete != null && Object.hasOwnProperty.call(e3, "systemUndelete") && $root.proto.SystemUndeleteTransactionBody.encode(e3.systemUndelete, o2.uint32(170).fork()).ldelim(), e3.contractDeleteInstance != null && Object.hasOwnProperty.call(e3, "contractDeleteInstance") && $root.proto.ContractDeleteTransactionBody.encode(e3.contractDeleteInstance, o2.uint32(178).fork()).ldelim(), e3.freeze != null && Object.hasOwnProperty.call(e3, "freeze") && $root.proto.FreezeTransactionBody.encode(e3.freeze, o2.uint32(186).fork()).ldelim(), e3.consensusCreateTopic != null && Object.hasOwnProperty.call(e3, "consensusCreateTopic") && $root.proto.ConsensusCreateTopicTransactionBody.encode(e3.consensusCreateTopic, o2.uint32(194).fork()).ldelim(), e3.consensusUpdateTopic != null && Object.hasOwnProperty.call(e3, "consensusUpdateTopic") && $root.proto.ConsensusUpdateTopicTransactionBody.encode(e3.consensusUpdateTopic, o2.uint32(202).fork()).ldelim(), e3.consensusDeleteTopic != null && Object.hasOwnProperty.call(e3, "consensusDeleteTopic") && $root.proto.ConsensusDeleteTopicTransactionBody.encode(e3.consensusDeleteTopic, o2.uint32(210).fork()).ldelim(), e3.consensusSubmitMessage != null && Object.hasOwnProperty.call(e3, "consensusSubmitMessage") && $root.proto.ConsensusSubmitMessageTransactionBody.encode(e3.consensusSubmitMessage, o2.uint32(218).fork()).ldelim(), e3.uncheckedSubmit != null && Object.hasOwnProperty.call(e3, "uncheckedSubmit") && $root.proto.UncheckedSubmitBody.encode(e3.uncheckedSubmit, o2.uint32(226).fork()).ldelim(), e3.tokenCreation != null && Object.hasOwnProperty.call(e3, "tokenCreation") && $root.proto.TokenCreateTransactionBody.encode(e3.tokenCreation, o2.uint32(234).fork()).ldelim(), e3.tokenFreeze != null && Object.hasOwnProperty.call(e3, "tokenFreeze") && $root.proto.TokenFreezeAccountTransactionBody.encode(e3.tokenFreeze, o2.uint32(250).fork()).ldelim(), e3.tokenUnfreeze != null && Object.hasOwnProperty.call(e3, "tokenUnfreeze") && $root.proto.TokenUnfreezeAccountTransactionBody.encode(e3.tokenUnfreeze, o2.uint32(258).fork()).ldelim(), e3.tokenGrantKyc != null && Object.hasOwnProperty.call(e3, "tokenGrantKyc") && $root.proto.TokenGrantKycTransactionBody.encode(e3.tokenGrantKyc, o2.uint32(266).fork()).ldelim(), e3.tokenRevokeKyc != null && Object.hasOwnProperty.call(e3, "tokenRevokeKyc") && $root.proto.TokenRevokeKycTransactionBody.encode(e3.tokenRevokeKyc, o2.uint32(274).fork()).ldelim(), e3.tokenDeletion != null && Object.hasOwnProperty.call(e3, "tokenDeletion") && $root.proto.TokenDeleteTransactionBody.encode(e3.tokenDeletion, o2.uint32(282).fork()).ldelim(), e3.tokenUpdate != null && Object.hasOwnProperty.call(e3, "tokenUpdate") && $root.proto.TokenUpdateTransactionBody.encode(e3.tokenUpdate, o2.uint32(290).fork()).ldelim(), e3.tokenMint != null && Object.hasOwnProperty.call(e3, "tokenMint") && $root.proto.TokenMintTransactionBody.encode(e3.tokenMint, o2.uint32(298).fork()).ldelim(), e3.tokenBurn != null && Object.hasOwnProperty.call(e3, "tokenBurn") && $root.proto.TokenBurnTransactionBody.encode(e3.tokenBurn, o2.uint32(306).fork()).ldelim(), e3.tokenWipe != null && Object.hasOwnProperty.call(e3, "tokenWipe") && $root.proto.TokenWipeAccountTransactionBody.encode(e3.tokenWipe, o2.uint32(314).fork()).ldelim(), e3.tokenAssociate != null && Object.hasOwnProperty.call(e3, "tokenAssociate") && $root.proto.TokenAssociateTransactionBody.encode(e3.tokenAssociate, o2.uint32(322).fork()).ldelim(), e3.tokenDissociate != null && Object.hasOwnProperty.call(e3, "tokenDissociate") && $root.proto.TokenDissociateTransactionBody.encode(e3.tokenDissociate, o2.uint32(330).fork()).ldelim(), e3.scheduleCreate != null && Object.hasOwnProperty.call(e3, "scheduleCreate") && $root.proto.ScheduleCreateTransactionBody.encode(e3.scheduleCreate, o2.uint32(338).fork()).ldelim(), e3.scheduleDelete != null && Object.hasOwnProperty.call(e3, "scheduleDelete") && $root.proto.ScheduleDeleteTransactionBody.encode(e3.scheduleDelete, o2.uint32(346).fork()).ldelim(), e3.scheduleSign != null && Object.hasOwnProperty.call(e3, "scheduleSign") && $root.proto.ScheduleSignTransactionBody.encode(e3.scheduleSign, o2.uint32(354).fork()).ldelim(), e3.tokenFeeScheduleUpdate != null && Object.hasOwnProperty.call(e3, "tokenFeeScheduleUpdate") && $root.proto.TokenFeeScheduleUpdateTransactionBody.encode(e3.tokenFeeScheduleUpdate, o2.uint32(362).fork()).ldelim(), e3.tokenPause != null && Object.hasOwnProperty.call(e3, "tokenPause") && $root.proto.TokenPauseTransactionBody.encode(e3.tokenPause, o2.uint32(370).fork()).ldelim(), e3.tokenUnpause != null && Object.hasOwnProperty.call(e3, "tokenUnpause") && $root.proto.TokenUnpauseTransactionBody.encode(e3.tokenUnpause, o2.uint32(378).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.TransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.transactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              case 2:
                i.nodeAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.transactionFee = e3.uint64();
                break;
              case 4:
                i.transactionValidDuration = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              case 5:
                i.generateRecord = e3.bool();
                break;
              case 6:
                i.memo = e3.string();
                break;
              case 7:
                i.contractCall = $root.proto.ContractCallTransactionBody.decode(e3, e3.uint32());
                break;
              case 8:
                i.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(e3, e3.uint32());
                break;
              case 9:
                i.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              case 22:
                i.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 10:
                i.cryptoAddLiveHash = $root.proto.CryptoAddLiveHashTransactionBody.decode(e3, e3.uint32());
                break;
              case 11:
                i.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(e3, e3.uint32());
                break;
              case 12:
                i.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 13:
                i.cryptoDeleteLiveHash = $root.proto.CryptoDeleteLiveHashTransactionBody.decode(e3, e3.uint32());
                break;
              case 14:
                i.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(e3, e3.uint32());
                break;
              case 15:
                i.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              case 16:
                i.fileAppend = $root.proto.FileAppendTransactionBody.decode(e3, e3.uint32());
                break;
              case 17:
                i.fileCreate = $root.proto.FileCreateTransactionBody.decode(e3, e3.uint32());
                break;
              case 18:
                i.fileDelete = $root.proto.FileDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 19:
                i.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              case 20:
                i.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 21:
                i.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 23:
                i.freeze = $root.proto.FreezeTransactionBody.decode(e3, e3.uint32());
                break;
              case 24:
                i.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(e3, e3.uint32());
                break;
              case 25:
                i.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(e3, e3.uint32());
                break;
              case 26:
                i.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(e3, e3.uint32());
                break;
              case 27:
                i.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(e3, e3.uint32());
                break;
              case 28:
                i.uncheckedSubmit = $root.proto.UncheckedSubmitBody.decode(e3, e3.uint32());
                break;
              case 29:
                i.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(e3, e3.uint32());
                break;
              case 31:
                i.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              case 32:
                i.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              case 33:
                i.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(e3, e3.uint32());
                break;
              case 34:
                i.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(e3, e3.uint32());
                break;
              case 35:
                i.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 36:
                i.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              case 37:
                i.tokenMint = $root.proto.TokenMintTransactionBody.decode(e3, e3.uint32());
                break;
              case 38:
                i.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(e3, e3.uint32());
                break;
              case 39:
                i.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              case 40:
                i.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(e3, e3.uint32());
                break;
              case 41:
                i.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(e3, e3.uint32());
                break;
              case 45:
                i.tokenFeeScheduleUpdate = $root.proto.TokenFeeScheduleUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              case 46:
                i.tokenPause = $root.proto.TokenPauseTransactionBody.decode(e3, e3.uint32());
                break;
              case 47:
                i.tokenUnpause = $root.proto.TokenUnpauseTransactionBody.decode(e3, e3.uint32());
                break;
              case 42:
                i.scheduleCreate = $root.proto.ScheduleCreateTransactionBody.decode(e3, e3.uint32());
                break;
              case 43:
                i.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 44:
                i.scheduleSign = $root.proto.ScheduleSignTransactionBody.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), SystemDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.fileID = null, e2.prototype.contractID = null, e2.prototype.expirationTime = null;
        let o;
        return Object.defineProperty(e2.prototype, "id", { get: $util.oneOfGetter(o = ["fileID", "contractID"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o2.uint32(10).fork()).ldelim(), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(18).fork()).ldelim(), e3.expirationTime != null && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.TimestampSeconds.encode(e3.expirationTime, o2.uint32(26).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.SystemDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              case 2:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              case 3:
                i.expirationTime = $root.proto.TimestampSeconds.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), SystemUndeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.fileID = null, e2.prototype.contractID = null;
        let o;
        return Object.defineProperty(e2.prototype, "id", { get: $util.oneOfGetter(o = ["fileID", "contractID"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o2.uint32(10).fork()).ldelim(), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(18).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.SystemUndeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              case 2:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FreezeTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.startHour = 0, e2.prototype.startMin = 0, e2.prototype.endHour = 0, e2.prototype.endMin = 0, e2.prototype.updateFile = null, e2.prototype.fileHash = $util.newBuffer([]), e2.prototype.startTime = null, e2.prototype.freezeType = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.startHour != null && Object.hasOwnProperty.call(e3, "startHour") && o.uint32(8).int32(e3.startHour), e3.startMin != null && Object.hasOwnProperty.call(e3, "startMin") && o.uint32(16).int32(e3.startMin), e3.endHour != null && Object.hasOwnProperty.call(e3, "endHour") && o.uint32(24).int32(e3.endHour), e3.endMin != null && Object.hasOwnProperty.call(e3, "endMin") && o.uint32(32).int32(e3.endMin), e3.updateFile != null && Object.hasOwnProperty.call(e3, "updateFile") && $root.proto.FileID.encode(e3.updateFile, o.uint32(42).fork()).ldelim(), e3.fileHash != null && Object.hasOwnProperty.call(e3, "fileHash") && o.uint32(50).bytes(e3.fileHash), e3.startTime != null && Object.hasOwnProperty.call(e3, "startTime") && $root.proto.Timestamp.encode(e3.startTime, o.uint32(58).fork()).ldelim(), e3.freezeType != null && Object.hasOwnProperty.call(e3, "freezeType") && o.uint32(64).int32(e3.freezeType), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FreezeTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.startHour = e3.int32();
                break;
              case 2:
                i.startMin = e3.int32();
                break;
              case 3:
                i.endHour = e3.int32();
                break;
              case 4:
                i.endMin = e3.int32();
                break;
              case 5:
                i.updateFile = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              case 6:
                i.fileHash = e3.bytes();
                break;
              case 7:
                i.startTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 8:
                i.freezeType = e3.int32();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FreezeType: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "UNKNOWN_FREEZE_TYPE"] = 0, o[e2[1] = "FREEZE_ONLY"] = 1, o[e2[2] = "PREPARE_UPGRADE"] = 2, o[e2[3] = "FREEZE_UPGRADE"] = 3, o[e2[4] = "FREEZE_ABORT"] = 4, o[e2[5] = "TELEMETRY_UPGRADE"] = 5, o;
      }(), ContractCallTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.contractID = null, e2.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.functionParameters = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(10).fork()).ldelim(), e3.gas != null && Object.hasOwnProperty.call(e3, "gas") && o.uint32(16).int64(e3.gas), e3.amount != null && Object.hasOwnProperty.call(e3, "amount") && o.uint32(24).int64(e3.amount), e3.functionParameters != null && Object.hasOwnProperty.call(e3, "functionParameters") && o.uint32(34).bytes(e3.functionParameters), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractCallTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              case 2:
                i.gas = e3.int64();
                break;
              case 3:
                i.amount = e3.int64();
                break;
              case 4:
                i.functionParameters = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractCreateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.fileID = null, e2.prototype.adminKey = null, e2.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.proxyAccountID = null, e2.prototype.autoRenewPeriod = null, e2.prototype.constructorParameters = $util.newBuffer([]), e2.prototype.shardID = null, e2.prototype.realmID = null, e2.prototype.newRealmAdminKey = null, e2.prototype.memo = "", e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(10).fork()).ldelim(), e3.adminKey != null && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(26).fork()).ldelim(), e3.gas != null && Object.hasOwnProperty.call(e3, "gas") && o.uint32(32).int64(e3.gas), e3.initialBalance != null && Object.hasOwnProperty.call(e3, "initialBalance") && o.uint32(40).int64(e3.initialBalance), e3.proxyAccountID != null && Object.hasOwnProperty.call(e3, "proxyAccountID") && $root.proto.AccountID.encode(e3.proxyAccountID, o.uint32(50).fork()).ldelim(), e3.autoRenewPeriod != null && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(66).fork()).ldelim(), e3.constructorParameters != null && Object.hasOwnProperty.call(e3, "constructorParameters") && o.uint32(74).bytes(e3.constructorParameters), e3.shardID != null && Object.hasOwnProperty.call(e3, "shardID") && $root.proto.ShardID.encode(e3.shardID, o.uint32(82).fork()).ldelim(), e3.realmID != null && Object.hasOwnProperty.call(e3, "realmID") && $root.proto.RealmID.encode(e3.realmID, o.uint32(90).fork()).ldelim(), e3.newRealmAdminKey != null && Object.hasOwnProperty.call(e3, "newRealmAdminKey") && $root.proto.Key.encode(e3.newRealmAdminKey, o.uint32(98).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o.uint32(106).string(e3.memo), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractCreateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              case 3:
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 4:
                i.gas = e3.int64();
                break;
              case 5:
                i.initialBalance = e3.int64();
                break;
              case 6:
                i.proxyAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 8:
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              case 9:
                i.constructorParameters = e3.bytes();
                break;
              case 10:
                i.shardID = $root.proto.ShardID.decode(e3, e3.uint32());
                break;
              case 11:
                i.realmID = $root.proto.RealmID.decode(e3, e3.uint32());
                break;
              case 12:
                i.newRealmAdminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 13:
                i.memo = e3.string();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractUpdateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.contractID = null, e2.prototype.expirationTime = null, e2.prototype.adminKey = null, e2.prototype.proxyAccountID = null, e2.prototype.autoRenewPeriod = null, e2.prototype.fileID = null, e2.prototype.memo = null, e2.prototype.memoWrapper = null;
        let o;
        return Object.defineProperty(e2.prototype, "memoField", { get: $util.oneOfGetter(o = ["memo", "memoWrapper"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(10).fork()).ldelim(), e3.expirationTime != null && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o2.uint32(18).fork()).ldelim(), e3.adminKey != null && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o2.uint32(26).fork()).ldelim(), e3.proxyAccountID != null && Object.hasOwnProperty.call(e3, "proxyAccountID") && $root.proto.AccountID.encode(e3.proxyAccountID, o2.uint32(50).fork()).ldelim(), e3.autoRenewPeriod != null && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o2.uint32(58).fork()).ldelim(), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o2.uint32(66).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(74).string(e3.memo), e3.memoWrapper != null && Object.hasOwnProperty.call(e3, "memoWrapper") && $root.google.protobuf.StringValue.encode(e3.memoWrapper, o2.uint32(82).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.ContractUpdateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              case 2:
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 3:
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 6:
                i.proxyAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 7:
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              case 8:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              case 9:
                i.memo = e3.string();
                break;
              case 10:
                i.memoWrapper = $root.google.protobuf.StringValue.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), LiveHash: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountId = null, e2.prototype.hash = $util.newBuffer([]), e2.prototype.keys = null, e2.prototype.duration = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.accountId != null && Object.hasOwnProperty.call(e3, "accountId") && $root.proto.AccountID.encode(e3.accountId, o.uint32(10).fork()).ldelim(), e3.hash != null && Object.hasOwnProperty.call(e3, "hash") && o.uint32(18).bytes(e3.hash), e3.keys != null && Object.hasOwnProperty.call(e3, "keys") && $root.proto.KeyList.encode(e3.keys, o.uint32(26).fork()).ldelim(), e3.duration != null && Object.hasOwnProperty.call(e3, "duration") && $root.proto.Duration.encode(e3.duration, o.uint32(42).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.LiveHash(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.accountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 2:
                i.hash = e3.bytes();
                break;
              case 3:
                i.keys = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              case 5:
                i.duration = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoAddLiveHashTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.liveHash = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.liveHash != null && Object.hasOwnProperty.call(e3, "liveHash") && $root.proto.LiveHash.encode(e3.liveHash, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoAddLiveHashTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 3:
                i.liveHash = $root.proto.LiveHash.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoCreateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.key = null, e2.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.proxyAccountID = null, e2.prototype.sendRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.receiveRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.receiverSigRequired = false, e2.prototype.autoRenewPeriod = null, e2.prototype.shardID = null, e2.prototype.realmID = null, e2.prototype.newRealmAdminKey = null, e2.prototype.memo = "", e2.prototype.maxAutomaticTokenAssociations = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.key != null && Object.hasOwnProperty.call(e3, "key") && $root.proto.Key.encode(e3.key, o.uint32(10).fork()).ldelim(), e3.initialBalance != null && Object.hasOwnProperty.call(e3, "initialBalance") && o.uint32(16).uint64(e3.initialBalance), e3.proxyAccountID != null && Object.hasOwnProperty.call(e3, "proxyAccountID") && $root.proto.AccountID.encode(e3.proxyAccountID, o.uint32(26).fork()).ldelim(), e3.sendRecordThreshold != null && Object.hasOwnProperty.call(e3, "sendRecordThreshold") && o.uint32(48).uint64(e3.sendRecordThreshold), e3.receiveRecordThreshold != null && Object.hasOwnProperty.call(e3, "receiveRecordThreshold") && o.uint32(56).uint64(e3.receiveRecordThreshold), e3.receiverSigRequired != null && Object.hasOwnProperty.call(e3, "receiverSigRequired") && o.uint32(64).bool(e3.receiverSigRequired), e3.autoRenewPeriod != null && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(74).fork()).ldelim(), e3.shardID != null && Object.hasOwnProperty.call(e3, "shardID") && $root.proto.ShardID.encode(e3.shardID, o.uint32(82).fork()).ldelim(), e3.realmID != null && Object.hasOwnProperty.call(e3, "realmID") && $root.proto.RealmID.encode(e3.realmID, o.uint32(90).fork()).ldelim(), e3.newRealmAdminKey != null && Object.hasOwnProperty.call(e3, "newRealmAdminKey") && $root.proto.Key.encode(e3.newRealmAdminKey, o.uint32(98).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o.uint32(106).string(e3.memo), e3.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(e3, "maxAutomaticTokenAssociations") && o.uint32(112).int32(e3.maxAutomaticTokenAssociations), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoCreateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.key = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 2:
                i.initialBalance = e3.uint64();
                break;
              case 3:
                i.proxyAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 6:
                i.sendRecordThreshold = e3.uint64();
                break;
              case 7:
                i.receiveRecordThreshold = e3.uint64();
                break;
              case 8:
                i.receiverSigRequired = e3.bool();
                break;
              case 9:
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              case 10:
                i.shardID = $root.proto.ShardID.decode(e3, e3.uint32());
                break;
              case 11:
                i.realmID = $root.proto.RealmID.decode(e3, e3.uint32());
                break;
              case 12:
                i.newRealmAdminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 13:
                i.memo = e3.string();
                break;
              case 14:
                i.maxAutomaticTokenAssociations = e3.int32();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transferAccountID = null, e2.prototype.deleteAccountID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.transferAccountID != null && Object.hasOwnProperty.call(e3, "transferAccountID") && $root.proto.AccountID.encode(e3.transferAccountID, o.uint32(10).fork()).ldelim(), e3.deleteAccountID != null && Object.hasOwnProperty.call(e3, "deleteAccountID") && $root.proto.AccountID.encode(e3.deleteAccountID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.transferAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 2:
                i.deleteAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoDeleteLiveHashTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountOfLiveHash = null, e2.prototype.liveHashToDelete = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.accountOfLiveHash != null && Object.hasOwnProperty.call(e3, "accountOfLiveHash") && $root.proto.AccountID.encode(e3.accountOfLiveHash, o.uint32(10).fork()).ldelim(), e3.liveHashToDelete != null && Object.hasOwnProperty.call(e3, "liveHashToDelete") && o.uint32(18).bytes(e3.liveHashToDelete), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoDeleteLiveHashTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.accountOfLiveHash = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 2:
                i.liveHashToDelete = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoTransferTransactionBody: function() {
        function e2(e3) {
          if (this.tokenTransfers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transfers = null, e2.prototype.tokenTransfers = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.transfers != null && Object.hasOwnProperty.call(e3, "transfers") && $root.proto.TransferList.encode(e3.transfers, o.uint32(10).fork()).ldelim(), e3.tokenTransfers != null && e3.tokenTransfers.length)
            for (var t = 0; t < e3.tokenTransfers.length; ++t)
              $root.proto.TokenTransferList.encode(e3.tokenTransfers[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoTransferTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.transfers = $root.proto.TransferList.decode(e3, e3.uint32());
                break;
              case 2:
                i.tokenTransfers && i.tokenTransfers.length || (i.tokenTransfers = []), i.tokenTransfers.push($root.proto.TokenTransferList.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoUpdateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.accountIDToUpdate = null, e2.prototype.key = null, e2.prototype.proxyAccountID = null, e2.prototype.proxyFraction = 0, e2.prototype.sendRecordThreshold = null, e2.prototype.sendRecordThresholdWrapper = null, e2.prototype.receiveRecordThreshold = null, e2.prototype.receiveRecordThresholdWrapper = null, e2.prototype.autoRenewPeriod = null, e2.prototype.expirationTime = null, e2.prototype.receiverSigRequired = null, e2.prototype.receiverSigRequiredWrapper = null, e2.prototype.memo = null, e2.prototype.maxAutomaticTokenAssociations = null;
        let o;
        return Object.defineProperty(e2.prototype, "sendRecordThresholdField", { get: $util.oneOfGetter(o = ["sendRecordThreshold", "sendRecordThresholdWrapper"]), set: $util.oneOfSetter(o) }), Object.defineProperty(e2.prototype, "receiveRecordThresholdField", { get: $util.oneOfGetter(o = ["receiveRecordThreshold", "receiveRecordThresholdWrapper"]), set: $util.oneOfSetter(o) }), Object.defineProperty(e2.prototype, "receiverSigRequiredField", { get: $util.oneOfGetter(o = ["receiverSigRequired", "receiverSigRequiredWrapper"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.accountIDToUpdate != null && Object.hasOwnProperty.call(e3, "accountIDToUpdate") && $root.proto.AccountID.encode(e3.accountIDToUpdate, o2.uint32(18).fork()).ldelim(), e3.key != null && Object.hasOwnProperty.call(e3, "key") && $root.proto.Key.encode(e3.key, o2.uint32(26).fork()).ldelim(), e3.proxyAccountID != null && Object.hasOwnProperty.call(e3, "proxyAccountID") && $root.proto.AccountID.encode(e3.proxyAccountID, o2.uint32(34).fork()).ldelim(), e3.proxyFraction != null && Object.hasOwnProperty.call(e3, "proxyFraction") && o2.uint32(40).int32(e3.proxyFraction), e3.sendRecordThreshold != null && Object.hasOwnProperty.call(e3, "sendRecordThreshold") && o2.uint32(48).uint64(e3.sendRecordThreshold), e3.receiveRecordThreshold != null && Object.hasOwnProperty.call(e3, "receiveRecordThreshold") && o2.uint32(56).uint64(e3.receiveRecordThreshold), e3.autoRenewPeriod != null && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o2.uint32(66).fork()).ldelim(), e3.expirationTime != null && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o2.uint32(74).fork()).ldelim(), e3.receiverSigRequired != null && Object.hasOwnProperty.call(e3, "receiverSigRequired") && o2.uint32(80).bool(e3.receiverSigRequired), e3.sendRecordThresholdWrapper != null && Object.hasOwnProperty.call(e3, "sendRecordThresholdWrapper") && $root.google.protobuf.UInt64Value.encode(e3.sendRecordThresholdWrapper, o2.uint32(90).fork()).ldelim(), e3.receiveRecordThresholdWrapper != null && Object.hasOwnProperty.call(e3, "receiveRecordThresholdWrapper") && $root.google.protobuf.UInt64Value.encode(e3.receiveRecordThresholdWrapper, o2.uint32(98).fork()).ldelim(), e3.receiverSigRequiredWrapper != null && Object.hasOwnProperty.call(e3, "receiverSigRequiredWrapper") && $root.google.protobuf.BoolValue.encode(e3.receiverSigRequiredWrapper, o2.uint32(106).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && $root.google.protobuf.StringValue.encode(e3.memo, o2.uint32(114).fork()).ldelim(), e3.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(e3, "maxAutomaticTokenAssociations") && $root.google.protobuf.Int32Value.encode(e3.maxAutomaticTokenAssociations, o2.uint32(122).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.CryptoUpdateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2:
                i.accountIDToUpdate = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.key = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 4:
                i.proxyAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 5:
                i.proxyFraction = e3.int32();
                break;
              case 6:
                i.sendRecordThreshold = e3.uint64();
                break;
              case 11:
                i.sendRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(e3, e3.uint32());
                break;
              case 7:
                i.receiveRecordThreshold = e3.uint64();
                break;
              case 12:
                i.receiveRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(e3, e3.uint32());
                break;
              case 8:
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              case 9:
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 10:
                i.receiverSigRequired = e3.bool();
                break;
              case 13:
                i.receiverSigRequiredWrapper = $root.google.protobuf.BoolValue.decode(e3, e3.uint32());
                break;
              case 14:
                i.memo = $root.google.protobuf.StringValue.decode(e3, e3.uint32());
                break;
              case 15:
                i.maxAutomaticTokenAssociations = $root.google.protobuf.Int32Value.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FileAppendTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.fileID = null, e2.prototype.contents = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(18).fork()).ldelim(), e3.contents != null && Object.hasOwnProperty.call(e3, "contents") && o.uint32(34).bytes(e3.contents), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FileAppendTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              case 4:
                i.contents = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FileCreateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.expirationTime = null, e2.prototype.keys = null, e2.prototype.contents = $util.newBuffer([]), e2.prototype.shardID = null, e2.prototype.realmID = null, e2.prototype.newRealmAdminKey = null, e2.prototype.memo = "", e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.expirationTime != null && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o.uint32(18).fork()).ldelim(), e3.keys != null && Object.hasOwnProperty.call(e3, "keys") && $root.proto.KeyList.encode(e3.keys, o.uint32(26).fork()).ldelim(), e3.contents != null && Object.hasOwnProperty.call(e3, "contents") && o.uint32(34).bytes(e3.contents), e3.shardID != null && Object.hasOwnProperty.call(e3, "shardID") && $root.proto.ShardID.encode(e3.shardID, o.uint32(42).fork()).ldelim(), e3.realmID != null && Object.hasOwnProperty.call(e3, "realmID") && $root.proto.RealmID.encode(e3.realmID, o.uint32(50).fork()).ldelim(), e3.newRealmAdminKey != null && Object.hasOwnProperty.call(e3, "newRealmAdminKey") && $root.proto.Key.encode(e3.newRealmAdminKey, o.uint32(58).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o.uint32(66).string(e3.memo), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FileCreateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2:
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 3:
                i.keys = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              case 4:
                i.contents = e3.bytes();
                break;
              case 5:
                i.shardID = $root.proto.ShardID.decode(e3, e3.uint32());
                break;
              case 6:
                i.realmID = $root.proto.RealmID.decode(e3, e3.uint32());
                break;
              case 7:
                i.newRealmAdminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 8:
                i.memo = e3.string();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FileDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.fileID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FileDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 2:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FileUpdateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.fileID = null, e2.prototype.expirationTime = null, e2.prototype.keys = null, e2.prototype.contents = $util.newBuffer([]), e2.prototype.memo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(10).fork()).ldelim(), e3.expirationTime != null && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o.uint32(18).fork()).ldelim(), e3.keys != null && Object.hasOwnProperty.call(e3, "keys") && $root.proto.KeyList.encode(e3.keys, o.uint32(26).fork()).ldelim(), e3.contents != null && Object.hasOwnProperty.call(e3, "contents") && o.uint32(34).bytes(e3.contents), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && $root.google.protobuf.StringValue.encode(e3.memo, o.uint32(42).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FileUpdateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              case 2:
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 3:
                i.keys = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              case 4:
                i.contents = e3.bytes();
                break;
              case 5:
                i.memo = $root.google.protobuf.StringValue.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.contractID = null, e2.prototype.transferAccountID = null, e2.prototype.transferContractID = null;
        let o;
        return Object.defineProperty(e2.prototype, "obtainers", { get: $util.oneOfGetter(o = ["transferAccountID", "transferContractID"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(10).fork()).ldelim(), e3.transferAccountID != null && Object.hasOwnProperty.call(e3, "transferAccountID") && $root.proto.AccountID.encode(e3.transferAccountID, o2.uint32(18).fork()).ldelim(), e3.transferContractID != null && Object.hasOwnProperty.call(e3, "transferContractID") && $root.proto.ContractID.encode(e3.transferContractID, o2.uint32(26).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.ContractDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              case 2:
                i.transferAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.transferContractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ConsensusUpdateTopicTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.topicID = null, e2.prototype.memo = null, e2.prototype.expirationTime = null, e2.prototype.adminKey = null, e2.prototype.submitKey = null, e2.prototype.autoRenewPeriod = null, e2.prototype.autoRenewAccount = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.topicID != null && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(10).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && $root.google.protobuf.StringValue.encode(e3.memo, o.uint32(18).fork()).ldelim(), e3.expirationTime != null && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o.uint32(34).fork()).ldelim(), e3.adminKey != null && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(50).fork()).ldelim(), e3.submitKey != null && Object.hasOwnProperty.call(e3, "submitKey") && $root.proto.Key.encode(e3.submitKey, o.uint32(58).fork()).ldelim(), e3.autoRenewPeriod != null && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(66).fork()).ldelim(), e3.autoRenewAccount != null && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(74).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ConsensusUpdateTopicTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              case 2:
                i.memo = $root.google.protobuf.StringValue.decode(e3, e3.uint32());
                break;
              case 4:
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 6:
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 7:
                i.submitKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 8:
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              case 9:
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ConsensusMessageChunkInfo: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.initialTransactionID = null, e2.prototype.total = 0, e2.prototype.number = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.initialTransactionID != null && Object.hasOwnProperty.call(e3, "initialTransactionID") && $root.proto.TransactionID.encode(e3.initialTransactionID, o.uint32(10).fork()).ldelim(), e3.total != null && Object.hasOwnProperty.call(e3, "total") && o.uint32(16).int32(e3.total), e3.number != null && Object.hasOwnProperty.call(e3, "number") && o.uint32(24).int32(e3.number), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ConsensusMessageChunkInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.initialTransactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              case 2:
                i.total = e3.int32();
                break;
              case 3:
                i.number = e3.int32();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ConsensusSubmitMessageTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.topicID = null, e2.prototype.message = $util.newBuffer([]), e2.prototype.chunkInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.topicID != null && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(10).fork()).ldelim(), e3.message != null && Object.hasOwnProperty.call(e3, "message") && o.uint32(18).bytes(e3.message), e3.chunkInfo != null && Object.hasOwnProperty.call(e3, "chunkInfo") && $root.proto.ConsensusMessageChunkInfo.encode(e3.chunkInfo, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ConsensusSubmitMessageTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              case 2:
                i.message = e3.bytes();
                break;
              case 3:
                i.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), UncheckedSubmitBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transactionBytes = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.transactionBytes != null && Object.hasOwnProperty.call(e3, "transactionBytes") && o.uint32(10).bytes(e3.transactionBytes), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.UncheckedSubmitBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.transactionBytes = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenCreateTransactionBody: function() {
        function e2(e3) {
          if (this.customFees = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.name = "", e2.prototype.symbol = "", e2.prototype.decimals = 0, e2.prototype.initialSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.treasury = null, e2.prototype.adminKey = null, e2.prototype.kycKey = null, e2.prototype.freezeKey = null, e2.prototype.wipeKey = null, e2.prototype.supplyKey = null, e2.prototype.freezeDefault = false, e2.prototype.expiry = null, e2.prototype.autoRenewAccount = null, e2.prototype.autoRenewPeriod = null, e2.prototype.memo = "", e2.prototype.tokenType = 0, e2.prototype.supplyType = 0, e2.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.feeScheduleKey = null, e2.prototype.customFees = $util.emptyArray, e2.prototype.pauseKey = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.name != null && Object.hasOwnProperty.call(e3, "name") && o.uint32(10).string(e3.name), e3.symbol != null && Object.hasOwnProperty.call(e3, "symbol") && o.uint32(18).string(e3.symbol), e3.decimals != null && Object.hasOwnProperty.call(e3, "decimals") && o.uint32(24).uint32(e3.decimals), e3.initialSupply != null && Object.hasOwnProperty.call(e3, "initialSupply") && o.uint32(32).uint64(e3.initialSupply), e3.treasury != null && Object.hasOwnProperty.call(e3, "treasury") && $root.proto.AccountID.encode(e3.treasury, o.uint32(42).fork()).ldelim(), e3.adminKey != null && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(50).fork()).ldelim(), e3.kycKey != null && Object.hasOwnProperty.call(e3, "kycKey") && $root.proto.Key.encode(e3.kycKey, o.uint32(58).fork()).ldelim(), e3.freezeKey != null && Object.hasOwnProperty.call(e3, "freezeKey") && $root.proto.Key.encode(e3.freezeKey, o.uint32(66).fork()).ldelim(), e3.wipeKey != null && Object.hasOwnProperty.call(e3, "wipeKey") && $root.proto.Key.encode(e3.wipeKey, o.uint32(74).fork()).ldelim(), e3.supplyKey != null && Object.hasOwnProperty.call(e3, "supplyKey") && $root.proto.Key.encode(e3.supplyKey, o.uint32(82).fork()).ldelim(), e3.freezeDefault != null && Object.hasOwnProperty.call(e3, "freezeDefault") && o.uint32(88).bool(e3.freezeDefault), e3.expiry != null && Object.hasOwnProperty.call(e3, "expiry") && $root.proto.Timestamp.encode(e3.expiry, o.uint32(106).fork()).ldelim(), e3.autoRenewAccount != null && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(114).fork()).ldelim(), e3.autoRenewPeriod != null && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(122).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o.uint32(130).string(e3.memo), e3.tokenType != null && Object.hasOwnProperty.call(e3, "tokenType") && o.uint32(136).int32(e3.tokenType), e3.supplyType != null && Object.hasOwnProperty.call(e3, "supplyType") && o.uint32(144).int32(e3.supplyType), e3.maxSupply != null && Object.hasOwnProperty.call(e3, "maxSupply") && o.uint32(152).int64(e3.maxSupply), e3.feeScheduleKey != null && Object.hasOwnProperty.call(e3, "feeScheduleKey") && $root.proto.Key.encode(e3.feeScheduleKey, o.uint32(162).fork()).ldelim(), e3.customFees != null && e3.customFees.length)
            for (var t = 0; t < e3.customFees.length; ++t)
              $root.proto.CustomFee.encode(e3.customFees[t], o.uint32(170).fork()).ldelim();
          return e3.pauseKey != null && Object.hasOwnProperty.call(e3, "pauseKey") && $root.proto.Key.encode(e3.pauseKey, o.uint32(178).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenCreateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.name = e3.string();
                break;
              case 2:
                i.symbol = e3.string();
                break;
              case 3:
                i.decimals = e3.uint32();
                break;
              case 4:
                i.initialSupply = e3.uint64();
                break;
              case 5:
                i.treasury = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 6:
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 7:
                i.kycKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 8:
                i.freezeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 9:
                i.wipeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 10:
                i.supplyKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 11:
                i.freezeDefault = e3.bool();
                break;
              case 13:
                i.expiry = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 14:
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 15:
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              case 16:
                i.memo = e3.string();
                break;
              case 17:
                i.tokenType = e3.int32();
                break;
              case 18:
                i.supplyType = e3.int32();
                break;
              case 19:
                i.maxSupply = e3.int64();
                break;
              case 20:
                i.feeScheduleKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 21:
                i.customFees && i.customFees.length || (i.customFees = []), i.customFees.push($root.proto.CustomFee.decode(e3, e3.uint32()));
                break;
              case 22:
                i.pauseKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FractionalFee: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.fractionalAmount = null, e2.prototype.minimumAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.maximumAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.netOfTransfers = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.fractionalAmount != null && Object.hasOwnProperty.call(e3, "fractionalAmount") && $root.proto.Fraction.encode(e3.fractionalAmount, o.uint32(10).fork()).ldelim(), e3.minimumAmount != null && Object.hasOwnProperty.call(e3, "minimumAmount") && o.uint32(16).int64(e3.minimumAmount), e3.maximumAmount != null && Object.hasOwnProperty.call(e3, "maximumAmount") && o.uint32(24).int64(e3.maximumAmount), e3.netOfTransfers != null && Object.hasOwnProperty.call(e3, "netOfTransfers") && o.uint32(32).bool(e3.netOfTransfers), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FractionalFee(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.fractionalAmount = $root.proto.Fraction.decode(e3, e3.uint32());
                break;
              case 2:
                i.minimumAmount = e3.int64();
                break;
              case 3:
                i.maximumAmount = e3.int64();
                break;
              case 4:
                i.netOfTransfers = e3.bool();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FixedFee: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.denominatingTokenId = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.amount != null && Object.hasOwnProperty.call(e3, "amount") && o.uint32(8).int64(e3.amount), e3.denominatingTokenId != null && Object.hasOwnProperty.call(e3, "denominatingTokenId") && $root.proto.TokenID.encode(e3.denominatingTokenId, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FixedFee(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.amount = e3.int64();
                break;
              case 2:
                i.denominatingTokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), RoyaltyFee: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.exchangeValueFraction = null, e2.prototype.fallbackFee = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.exchangeValueFraction != null && Object.hasOwnProperty.call(e3, "exchangeValueFraction") && $root.proto.Fraction.encode(e3.exchangeValueFraction, o.uint32(10).fork()).ldelim(), e3.fallbackFee != null && Object.hasOwnProperty.call(e3, "fallbackFee") && $root.proto.FixedFee.encode(e3.fallbackFee, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.RoyaltyFee(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.exchangeValueFraction = $root.proto.Fraction.decode(e3, e3.uint32());
                break;
              case 2:
                i.fallbackFee = $root.proto.FixedFee.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CustomFee: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.fixedFee = null, e2.prototype.fractionalFee = null, e2.prototype.royaltyFee = null, e2.prototype.feeCollectorAccountId = null;
        let o;
        return Object.defineProperty(e2.prototype, "fee", { get: $util.oneOfGetter(o = ["fixedFee", "fractionalFee", "royaltyFee"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.fixedFee != null && Object.hasOwnProperty.call(e3, "fixedFee") && $root.proto.FixedFee.encode(e3.fixedFee, o2.uint32(10).fork()).ldelim(), e3.fractionalFee != null && Object.hasOwnProperty.call(e3, "fractionalFee") && $root.proto.FractionalFee.encode(e3.fractionalFee, o2.uint32(18).fork()).ldelim(), e3.feeCollectorAccountId != null && Object.hasOwnProperty.call(e3, "feeCollectorAccountId") && $root.proto.AccountID.encode(e3.feeCollectorAccountId, o2.uint32(26).fork()).ldelim(), e3.royaltyFee != null && Object.hasOwnProperty.call(e3, "royaltyFee") && $root.proto.RoyaltyFee.encode(e3.royaltyFee, o2.uint32(34).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.CustomFee(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.fixedFee = $root.proto.FixedFee.decode(e3, e3.uint32());
                break;
              case 2:
                i.fractionalFee = $root.proto.FractionalFee.decode(e3, e3.uint32());
                break;
              case 4:
                i.royaltyFee = $root.proto.RoyaltyFee.decode(e3, e3.uint32());
                break;
              case 3:
                i.feeCollectorAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), AssessedCustomFee: function() {
        function e2(e3) {
          if (this.effectivePayerAccountId = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.tokenId = null, e2.prototype.feeCollectorAccountId = null, e2.prototype.effectivePayerAccountId = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.amount != null && Object.hasOwnProperty.call(e3, "amount") && o.uint32(8).int64(e3.amount), e3.tokenId != null && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(18).fork()).ldelim(), e3.feeCollectorAccountId != null && Object.hasOwnProperty.call(e3, "feeCollectorAccountId") && $root.proto.AccountID.encode(e3.feeCollectorAccountId, o.uint32(26).fork()).ldelim(), e3.effectivePayerAccountId != null && e3.effectivePayerAccountId.length)
            for (var t = 0; t < e3.effectivePayerAccountId.length; ++t)
              $root.proto.AccountID.encode(e3.effectivePayerAccountId[t], o.uint32(34).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.AssessedCustomFee(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.amount = e3.int64();
                break;
              case 2:
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 3:
                i.feeCollectorAccountId = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 4:
                i.effectivePayerAccountId && i.effectivePayerAccountId.length || (i.effectivePayerAccountId = []), i.effectivePayerAccountId.push($root.proto.AccountID.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenFreezeAccountTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.account = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), e3.account != null && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenFreezeAccountTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenUnfreezeAccountTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.account = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), e3.account != null && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenUnfreezeAccountTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenGrantKycTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.account = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), e3.account != null && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenGrantKycTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenRevokeKycTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.account = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), e3.account != null && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenRevokeKycTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenUpdateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.symbol = "", e2.prototype.name = "", e2.prototype.treasury = null, e2.prototype.adminKey = null, e2.prototype.kycKey = null, e2.prototype.freezeKey = null, e2.prototype.wipeKey = null, e2.prototype.supplyKey = null, e2.prototype.autoRenewAccount = null, e2.prototype.autoRenewPeriod = null, e2.prototype.expiry = null, e2.prototype.memo = null, e2.prototype.feeScheduleKey = null, e2.prototype.pauseKey = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), e3.symbol != null && Object.hasOwnProperty.call(e3, "symbol") && o.uint32(18).string(e3.symbol), e3.name != null && Object.hasOwnProperty.call(e3, "name") && o.uint32(26).string(e3.name), e3.treasury != null && Object.hasOwnProperty.call(e3, "treasury") && $root.proto.AccountID.encode(e3.treasury, o.uint32(34).fork()).ldelim(), e3.adminKey != null && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(42).fork()).ldelim(), e3.kycKey != null && Object.hasOwnProperty.call(e3, "kycKey") && $root.proto.Key.encode(e3.kycKey, o.uint32(50).fork()).ldelim(), e3.freezeKey != null && Object.hasOwnProperty.call(e3, "freezeKey") && $root.proto.Key.encode(e3.freezeKey, o.uint32(58).fork()).ldelim(), e3.wipeKey != null && Object.hasOwnProperty.call(e3, "wipeKey") && $root.proto.Key.encode(e3.wipeKey, o.uint32(66).fork()).ldelim(), e3.supplyKey != null && Object.hasOwnProperty.call(e3, "supplyKey") && $root.proto.Key.encode(e3.supplyKey, o.uint32(74).fork()).ldelim(), e3.autoRenewAccount != null && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(82).fork()).ldelim(), e3.autoRenewPeriod != null && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(90).fork()).ldelim(), e3.expiry != null && Object.hasOwnProperty.call(e3, "expiry") && $root.proto.Timestamp.encode(e3.expiry, o.uint32(98).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && $root.google.protobuf.StringValue.encode(e3.memo, o.uint32(106).fork()).ldelim(), e3.feeScheduleKey != null && Object.hasOwnProperty.call(e3, "feeScheduleKey") && $root.proto.Key.encode(e3.feeScheduleKey, o.uint32(114).fork()).ldelim(), e3.pauseKey != null && Object.hasOwnProperty.call(e3, "pauseKey") && $root.proto.Key.encode(e3.pauseKey, o.uint32(122).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenUpdateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.symbol = e3.string();
                break;
              case 3:
                i.name = e3.string();
                break;
              case 4:
                i.treasury = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 5:
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 6:
                i.kycKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 7:
                i.freezeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 8:
                i.wipeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 9:
                i.supplyKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 10:
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 11:
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              case 12:
                i.expiry = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 13:
                i.memo = $root.google.protobuf.StringValue.decode(e3, e3.uint32());
                break;
              case 14:
                i.feeScheduleKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 15:
                i.pauseKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenMintTransactionBody: function() {
        function e2(e3) {
          if (this.metadata = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.metadata = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), e3.amount != null && Object.hasOwnProperty.call(e3, "amount") && o.uint32(16).uint64(e3.amount), e3.metadata != null && e3.metadata.length)
            for (var t = 0; t < e3.metadata.length; ++t)
              o.uint32(26).bytes(e3.metadata[t]);
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenMintTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.amount = e3.uint64();
                break;
              case 3:
                i.metadata && i.metadata.length || (i.metadata = []), i.metadata.push(e3.bytes());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenBurnTransactionBody: function() {
        function e2(e3) {
          if (this.serialNumbers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.serialNumbers = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), e3.amount != null && Object.hasOwnProperty.call(e3, "amount") && o.uint32(16).uint64(e3.amount), e3.serialNumbers != null && e3.serialNumbers.length) {
            o.uint32(26).fork();
            for (var t = 0; t < e3.serialNumbers.length; ++t)
              o.int64(e3.serialNumbers[t]);
            o.ldelim();
          }
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenBurnTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.amount = e3.uint64();
                break;
              case 3:
                if (i.serialNumbers && i.serialNumbers.length || (i.serialNumbers = []), (7 & d) == 2)
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.serialNumbers.push(e3.int64());
                else
                  i.serialNumbers.push(e3.int64());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenWipeAccountTransactionBody: function() {
        function e2(e3) {
          if (this.serialNumbers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.prototype.account = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.serialNumbers = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), e3.account != null && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(18).fork()).ldelim(), e3.amount != null && Object.hasOwnProperty.call(e3, "amount") && o.uint32(24).uint64(e3.amount), e3.serialNumbers != null && e3.serialNumbers.length) {
            o.uint32(34).fork();
            for (var t = 0; t < e3.serialNumbers.length; ++t)
              o.int64(e3.serialNumbers[t]);
            o.ldelim();
          }
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenWipeAccountTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.amount = e3.uint64();
                break;
              case 4:
                if (i.serialNumbers && i.serialNumbers.length || (i.serialNumbers = []), (7 & d) == 2)
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.serialNumbers.push(e3.int64());
                else
                  i.serialNumbers.push(e3.int64());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenAssociateTransactionBody: function() {
        function e2(e3) {
          if (this.tokens = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.account = null, e2.prototype.tokens = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.account != null && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(10).fork()).ldelim(), e3.tokens != null && e3.tokens.length)
            for (var t = 0; t < e3.tokens.length; ++t)
              $root.proto.TokenID.encode(e3.tokens[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenAssociateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 2:
                i.tokens && i.tokens.length || (i.tokens = []), i.tokens.push($root.proto.TokenID.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenDissociateTransactionBody: function() {
        function e2(e3) {
          if (this.tokens = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.account = null, e2.prototype.tokens = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.account != null && Object.hasOwnProperty.call(e3, "account") && $root.proto.AccountID.encode(e3.account, o.uint32(10).fork()).ldelim(), e3.tokens != null && e3.tokens.length)
            for (var t = 0; t < e3.tokens.length; ++t)
              $root.proto.TokenID.encode(e3.tokens[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenDissociateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.account = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 2:
                i.tokens && i.tokens.length || (i.tokens = []), i.tokens.push($root.proto.TokenID.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenFeeScheduleUpdateTransactionBody: function() {
        function e2(e3) {
          if (this.customFees = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.customFees = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.tokenId != null && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), e3.customFees != null && e3.customFees.length)
            for (var t = 0; t < e3.customFees.length; ++t)
              $root.proto.CustomFee.encode(e3.customFees[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenFeeScheduleUpdateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.customFees && i.customFees.length || (i.customFees = []), i.customFees.push($root.proto.CustomFee.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenPauseTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenPauseTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenUnpauseTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.token = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenUnpauseTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ScheduleCreateTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.scheduledTransactionBody = null, e2.prototype.memo = "", e2.prototype.adminKey = null, e2.prototype.payerAccountID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.scheduledTransactionBody != null && Object.hasOwnProperty.call(e3, "scheduledTransactionBody") && $root.proto.SchedulableTransactionBody.encode(e3.scheduledTransactionBody, o.uint32(10).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o.uint32(18).string(e3.memo), e3.adminKey != null && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(26).fork()).ldelim(), e3.payerAccountID != null && Object.hasOwnProperty.call(e3, "payerAccountID") && $root.proto.AccountID.encode(e3.payerAccountID, o.uint32(34).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ScheduleCreateTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(e3, e3.uint32());
                break;
              case 2:
                i.memo = e3.string();
                break;
              case 3:
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 4:
                i.payerAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), SchedulableTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.memo = "", e2.prototype.contractCall = null, e2.prototype.contractCreateInstance = null, e2.prototype.contractUpdateInstance = null, e2.prototype.contractDeleteInstance = null, e2.prototype.cryptoCreateAccount = null, e2.prototype.cryptoDelete = null, e2.prototype.cryptoTransfer = null, e2.prototype.cryptoUpdateAccount = null, e2.prototype.fileAppend = null, e2.prototype.fileCreate = null, e2.prototype.fileDelete = null, e2.prototype.fileUpdate = null, e2.prototype.systemDelete = null, e2.prototype.systemUndelete = null, e2.prototype.freeze = null, e2.prototype.consensusCreateTopic = null, e2.prototype.consensusUpdateTopic = null, e2.prototype.consensusDeleteTopic = null, e2.prototype.consensusSubmitMessage = null, e2.prototype.tokenCreation = null, e2.prototype.tokenFreeze = null, e2.prototype.tokenUnfreeze = null, e2.prototype.tokenGrantKyc = null, e2.prototype.tokenRevokeKyc = null, e2.prototype.tokenDeletion = null, e2.prototype.tokenUpdate = null, e2.prototype.tokenMint = null, e2.prototype.tokenBurn = null, e2.prototype.tokenWipe = null, e2.prototype.tokenAssociate = null, e2.prototype.tokenDissociate = null, e2.prototype.tokenPause = null, e2.prototype.tokenUnpause = null, e2.prototype.scheduleDelete = null;
        let o;
        return Object.defineProperty(e2.prototype, "data", { get: $util.oneOfGetter(o = ["contractCall", "contractCreateInstance", "contractUpdateInstance", "contractDeleteInstance", "cryptoCreateAccount", "cryptoDelete", "cryptoTransfer", "cryptoUpdateAccount", "fileAppend", "fileCreate", "fileDelete", "fileUpdate", "systemDelete", "systemUndelete", "freeze", "consensusCreateTopic", "consensusUpdateTopic", "consensusDeleteTopic", "consensusSubmitMessage", "tokenCreation", "tokenFreeze", "tokenUnfreeze", "tokenGrantKyc", "tokenRevokeKyc", "tokenDeletion", "tokenUpdate", "tokenMint", "tokenBurn", "tokenWipe", "tokenAssociate", "tokenDissociate", "tokenPause", "tokenUnpause", "scheduleDelete"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.transactionFee != null && Object.hasOwnProperty.call(e3, "transactionFee") && o2.uint32(8).uint64(e3.transactionFee), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(18).string(e3.memo), e3.contractCall != null && Object.hasOwnProperty.call(e3, "contractCall") && $root.proto.ContractCallTransactionBody.encode(e3.contractCall, o2.uint32(26).fork()).ldelim(), e3.contractCreateInstance != null && Object.hasOwnProperty.call(e3, "contractCreateInstance") && $root.proto.ContractCreateTransactionBody.encode(e3.contractCreateInstance, o2.uint32(34).fork()).ldelim(), e3.contractUpdateInstance != null && Object.hasOwnProperty.call(e3, "contractUpdateInstance") && $root.proto.ContractUpdateTransactionBody.encode(e3.contractUpdateInstance, o2.uint32(42).fork()).ldelim(), e3.contractDeleteInstance != null && Object.hasOwnProperty.call(e3, "contractDeleteInstance") && $root.proto.ContractDeleteTransactionBody.encode(e3.contractDeleteInstance, o2.uint32(50).fork()).ldelim(), e3.cryptoCreateAccount != null && Object.hasOwnProperty.call(e3, "cryptoCreateAccount") && $root.proto.CryptoCreateTransactionBody.encode(e3.cryptoCreateAccount, o2.uint32(58).fork()).ldelim(), e3.cryptoDelete != null && Object.hasOwnProperty.call(e3, "cryptoDelete") && $root.proto.CryptoDeleteTransactionBody.encode(e3.cryptoDelete, o2.uint32(66).fork()).ldelim(), e3.cryptoTransfer != null && Object.hasOwnProperty.call(e3, "cryptoTransfer") && $root.proto.CryptoTransferTransactionBody.encode(e3.cryptoTransfer, o2.uint32(74).fork()).ldelim(), e3.cryptoUpdateAccount != null && Object.hasOwnProperty.call(e3, "cryptoUpdateAccount") && $root.proto.CryptoUpdateTransactionBody.encode(e3.cryptoUpdateAccount, o2.uint32(82).fork()).ldelim(), e3.fileAppend != null && Object.hasOwnProperty.call(e3, "fileAppend") && $root.proto.FileAppendTransactionBody.encode(e3.fileAppend, o2.uint32(90).fork()).ldelim(), e3.fileCreate != null && Object.hasOwnProperty.call(e3, "fileCreate") && $root.proto.FileCreateTransactionBody.encode(e3.fileCreate, o2.uint32(98).fork()).ldelim(), e3.fileDelete != null && Object.hasOwnProperty.call(e3, "fileDelete") && $root.proto.FileDeleteTransactionBody.encode(e3.fileDelete, o2.uint32(106).fork()).ldelim(), e3.fileUpdate != null && Object.hasOwnProperty.call(e3, "fileUpdate") && $root.proto.FileUpdateTransactionBody.encode(e3.fileUpdate, o2.uint32(114).fork()).ldelim(), e3.systemDelete != null && Object.hasOwnProperty.call(e3, "systemDelete") && $root.proto.SystemDeleteTransactionBody.encode(e3.systemDelete, o2.uint32(122).fork()).ldelim(), e3.systemUndelete != null && Object.hasOwnProperty.call(e3, "systemUndelete") && $root.proto.SystemUndeleteTransactionBody.encode(e3.systemUndelete, o2.uint32(130).fork()).ldelim(), e3.freeze != null && Object.hasOwnProperty.call(e3, "freeze") && $root.proto.FreezeTransactionBody.encode(e3.freeze, o2.uint32(138).fork()).ldelim(), e3.consensusCreateTopic != null && Object.hasOwnProperty.call(e3, "consensusCreateTopic") && $root.proto.ConsensusCreateTopicTransactionBody.encode(e3.consensusCreateTopic, o2.uint32(146).fork()).ldelim(), e3.consensusUpdateTopic != null && Object.hasOwnProperty.call(e3, "consensusUpdateTopic") && $root.proto.ConsensusUpdateTopicTransactionBody.encode(e3.consensusUpdateTopic, o2.uint32(154).fork()).ldelim(), e3.consensusDeleteTopic != null && Object.hasOwnProperty.call(e3, "consensusDeleteTopic") && $root.proto.ConsensusDeleteTopicTransactionBody.encode(e3.consensusDeleteTopic, o2.uint32(162).fork()).ldelim(), e3.consensusSubmitMessage != null && Object.hasOwnProperty.call(e3, "consensusSubmitMessage") && $root.proto.ConsensusSubmitMessageTransactionBody.encode(e3.consensusSubmitMessage, o2.uint32(170).fork()).ldelim(), e3.tokenCreation != null && Object.hasOwnProperty.call(e3, "tokenCreation") && $root.proto.TokenCreateTransactionBody.encode(e3.tokenCreation, o2.uint32(178).fork()).ldelim(), e3.tokenFreeze != null && Object.hasOwnProperty.call(e3, "tokenFreeze") && $root.proto.TokenFreezeAccountTransactionBody.encode(e3.tokenFreeze, o2.uint32(186).fork()).ldelim(), e3.tokenUnfreeze != null && Object.hasOwnProperty.call(e3, "tokenUnfreeze") && $root.proto.TokenUnfreezeAccountTransactionBody.encode(e3.tokenUnfreeze, o2.uint32(194).fork()).ldelim(), e3.tokenGrantKyc != null && Object.hasOwnProperty.call(e3, "tokenGrantKyc") && $root.proto.TokenGrantKycTransactionBody.encode(e3.tokenGrantKyc, o2.uint32(202).fork()).ldelim(), e3.tokenRevokeKyc != null && Object.hasOwnProperty.call(e3, "tokenRevokeKyc") && $root.proto.TokenRevokeKycTransactionBody.encode(e3.tokenRevokeKyc, o2.uint32(210).fork()).ldelim(), e3.tokenDeletion != null && Object.hasOwnProperty.call(e3, "tokenDeletion") && $root.proto.TokenDeleteTransactionBody.encode(e3.tokenDeletion, o2.uint32(218).fork()).ldelim(), e3.tokenUpdate != null && Object.hasOwnProperty.call(e3, "tokenUpdate") && $root.proto.TokenUpdateTransactionBody.encode(e3.tokenUpdate, o2.uint32(226).fork()).ldelim(), e3.tokenMint != null && Object.hasOwnProperty.call(e3, "tokenMint") && $root.proto.TokenMintTransactionBody.encode(e3.tokenMint, o2.uint32(234).fork()).ldelim(), e3.tokenBurn != null && Object.hasOwnProperty.call(e3, "tokenBurn") && $root.proto.TokenBurnTransactionBody.encode(e3.tokenBurn, o2.uint32(242).fork()).ldelim(), e3.tokenWipe != null && Object.hasOwnProperty.call(e3, "tokenWipe") && $root.proto.TokenWipeAccountTransactionBody.encode(e3.tokenWipe, o2.uint32(250).fork()).ldelim(), e3.tokenAssociate != null && Object.hasOwnProperty.call(e3, "tokenAssociate") && $root.proto.TokenAssociateTransactionBody.encode(e3.tokenAssociate, o2.uint32(258).fork()).ldelim(), e3.tokenDissociate != null && Object.hasOwnProperty.call(e3, "tokenDissociate") && $root.proto.TokenDissociateTransactionBody.encode(e3.tokenDissociate, o2.uint32(266).fork()).ldelim(), e3.scheduleDelete != null && Object.hasOwnProperty.call(e3, "scheduleDelete") && $root.proto.ScheduleDeleteTransactionBody.encode(e3.scheduleDelete, o2.uint32(274).fork()).ldelim(), e3.tokenPause != null && Object.hasOwnProperty.call(e3, "tokenPause") && $root.proto.TokenPauseTransactionBody.encode(e3.tokenPause, o2.uint32(282).fork()).ldelim(), e3.tokenUnpause != null && Object.hasOwnProperty.call(e3, "tokenUnpause") && $root.proto.TokenUnpauseTransactionBody.encode(e3.tokenUnpause, o2.uint32(290).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.SchedulableTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.transactionFee = e3.uint64();
                break;
              case 2:
                i.memo = e3.string();
                break;
              case 3:
                i.contractCall = $root.proto.ContractCallTransactionBody.decode(e3, e3.uint32());
                break;
              case 4:
                i.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(e3, e3.uint32());
                break;
              case 5:
                i.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              case 6:
                i.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 7:
                i.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(e3, e3.uint32());
                break;
              case 8:
                i.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 9:
                i.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(e3, e3.uint32());
                break;
              case 10:
                i.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              case 11:
                i.fileAppend = $root.proto.FileAppendTransactionBody.decode(e3, e3.uint32());
                break;
              case 12:
                i.fileCreate = $root.proto.FileCreateTransactionBody.decode(e3, e3.uint32());
                break;
              case 13:
                i.fileDelete = $root.proto.FileDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 14:
                i.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              case 15:
                i.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 16:
                i.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 17:
                i.freeze = $root.proto.FreezeTransactionBody.decode(e3, e3.uint32());
                break;
              case 18:
                i.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(e3, e3.uint32());
                break;
              case 19:
                i.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(e3, e3.uint32());
                break;
              case 20:
                i.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(e3, e3.uint32());
                break;
              case 21:
                i.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(e3, e3.uint32());
                break;
              case 22:
                i.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(e3, e3.uint32());
                break;
              case 23:
                i.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              case 24:
                i.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              case 25:
                i.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(e3, e3.uint32());
                break;
              case 26:
                i.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(e3, e3.uint32());
                break;
              case 27:
                i.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              case 28:
                i.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(e3, e3.uint32());
                break;
              case 29:
                i.tokenMint = $root.proto.TokenMintTransactionBody.decode(e3, e3.uint32());
                break;
              case 30:
                i.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(e3, e3.uint32());
                break;
              case 31:
                i.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(e3, e3.uint32());
                break;
              case 32:
                i.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(e3, e3.uint32());
                break;
              case 33:
                i.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(e3, e3.uint32());
                break;
              case 35:
                i.tokenPause = $root.proto.TokenPauseTransactionBody.decode(e3, e3.uint32());
                break;
              case 36:
                i.tokenUnpause = $root.proto.TokenUnpauseTransactionBody.decode(e3, e3.uint32());
                break;
              case 34:
                i.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ScheduleDeleteTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.scheduleID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.scheduleID != null && Object.hasOwnProperty.call(e3, "scheduleID") && $root.proto.ScheduleID.encode(e3.scheduleID, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ScheduleDeleteTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.scheduleID = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ScheduleSignTransactionBody: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.scheduleID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.scheduleID != null && Object.hasOwnProperty.call(e3, "scheduleID") && $root.proto.ScheduleID.encode(e3.scheduleID, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ScheduleSignTransactionBody(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.scheduleID = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ResponseHeader: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nodeTransactionPrecheckCode = 0, e2.prototype.responseType = 0, e2.prototype.cost = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.stateProof = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(e3, "nodeTransactionPrecheckCode") && o.uint32(8).int32(e3.nodeTransactionPrecheckCode), e3.responseType != null && Object.hasOwnProperty.call(e3, "responseType") && o.uint32(16).int32(e3.responseType), e3.cost != null && Object.hasOwnProperty.call(e3, "cost") && o.uint32(24).uint64(e3.cost), e3.stateProof != null && Object.hasOwnProperty.call(e3, "stateProof") && o.uint32(34).bytes(e3.stateProof), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ResponseHeader(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.nodeTransactionPrecheckCode = e3.int32();
                break;
              case 2:
                i.responseType = e3.int32();
                break;
              case 3:
                i.cost = e3.uint64();
                break;
              case 4:
                i.stateProof = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nodeTransactionPrecheckCode = 0, e2.prototype.cost = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(e3, "nodeTransactionPrecheckCode") && o.uint32(8).int32(e3.nodeTransactionPrecheckCode), e3.cost != null && Object.hasOwnProperty.call(e3, "cost") && o.uint32(16).uint64(e3.cost), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransactionResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.nodeTransactionPrecheckCode = e3.int32();
                break;
              case 2:
                i.cost = e3.uint64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ResponseCodeEnum: function() {
        const e2 = {}, o = Object.create(e2);
        return o[e2[0] = "OK"] = 0, o[e2[1] = "INVALID_TRANSACTION"] = 1, o[e2[2] = "PAYER_ACCOUNT_NOT_FOUND"] = 2, o[e2[3] = "INVALID_NODE_ACCOUNT"] = 3, o[e2[4] = "TRANSACTION_EXPIRED"] = 4, o[e2[5] = "INVALID_TRANSACTION_START"] = 5, o[e2[6] = "INVALID_TRANSACTION_DURATION"] = 6, o[e2[7] = "INVALID_SIGNATURE"] = 7, o[e2[8] = "MEMO_TOO_LONG"] = 8, o[e2[9] = "INSUFFICIENT_TX_FEE"] = 9, o[e2[10] = "INSUFFICIENT_PAYER_BALANCE"] = 10, o[e2[11] = "DUPLICATE_TRANSACTION"] = 11, o[e2[12] = "BUSY"] = 12, o[e2[13] = "NOT_SUPPORTED"] = 13, o[e2[14] = "INVALID_FILE_ID"] = 14, o[e2[15] = "INVALID_ACCOUNT_ID"] = 15, o[e2[16] = "INVALID_CONTRACT_ID"] = 16, o[e2[17] = "INVALID_TRANSACTION_ID"] = 17, o[e2[18] = "RECEIPT_NOT_FOUND"] = 18, o[e2[19] = "RECORD_NOT_FOUND"] = 19, o[e2[20] = "INVALID_SOLIDITY_ID"] = 20, o[e2[21] = "UNKNOWN"] = 21, o[e2[22] = "SUCCESS"] = 22, o[e2[23] = "FAIL_INVALID"] = 23, o[e2[24] = "FAIL_FEE"] = 24, o[e2[25] = "FAIL_BALANCE"] = 25, o[e2[26] = "KEY_REQUIRED"] = 26, o[e2[27] = "BAD_ENCODING"] = 27, o[e2[28] = "INSUFFICIENT_ACCOUNT_BALANCE"] = 28, o[e2[29] = "INVALID_SOLIDITY_ADDRESS"] = 29, o[e2[30] = "INSUFFICIENT_GAS"] = 30, o[e2[31] = "CONTRACT_SIZE_LIMIT_EXCEEDED"] = 31, o[e2[32] = "LOCAL_CALL_MODIFICATION_EXCEPTION"] = 32, o[e2[33] = "CONTRACT_REVERT_EXECUTED"] = 33, o[e2[34] = "CONTRACT_EXECUTION_EXCEPTION"] = 34, o[e2[35] = "INVALID_RECEIVING_NODE_ACCOUNT"] = 35, o[e2[36] = "MISSING_QUERY_HEADER"] = 36, o[e2[37] = "ACCOUNT_UPDATE_FAILED"] = 37, o[e2[38] = "INVALID_KEY_ENCODING"] = 38, o[e2[39] = "NULL_SOLIDITY_ADDRESS"] = 39, o[e2[40] = "CONTRACT_UPDATE_FAILED"] = 40, o[e2[41] = "INVALID_QUERY_HEADER"] = 41, o[e2[42] = "INVALID_FEE_SUBMITTED"] = 42, o[e2[43] = "INVALID_PAYER_SIGNATURE"] = 43, o[e2[44] = "KEY_NOT_PROVIDED"] = 44, o[e2[45] = "INVALID_EXPIRATION_TIME"] = 45, o[e2[46] = "NO_WACL_KEY"] = 46, o[e2[47] = "FILE_CONTENT_EMPTY"] = 47, o[e2[48] = "INVALID_ACCOUNT_AMOUNTS"] = 48, o[e2[49] = "EMPTY_TRANSACTION_BODY"] = 49, o[e2[50] = "INVALID_TRANSACTION_BODY"] = 50, o[e2[51] = "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY"] = 51, o[e2[52] = "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY"] = 52, o[e2[53] = "EMPTY_LIVE_HASH_BODY"] = 53, o[e2[54] = "EMPTY_LIVE_HASH"] = 54, o[e2[55] = "EMPTY_LIVE_HASH_KEYS"] = 55, o[e2[56] = "INVALID_LIVE_HASH_SIZE"] = 56, o[e2[57] = "EMPTY_QUERY_BODY"] = 57, o[e2[58] = "EMPTY_LIVE_HASH_QUERY"] = 58, o[e2[59] = "LIVE_HASH_NOT_FOUND"] = 59, o[e2[60] = "ACCOUNT_ID_DOES_NOT_EXIST"] = 60, o[e2[61] = "LIVE_HASH_ALREADY_EXISTS"] = 61, o[e2[62] = "INVALID_FILE_WACL"] = 62, o[e2[63] = "SERIALIZATION_FAILED"] = 63, o[e2[64] = "TRANSACTION_OVERSIZE"] = 64, o[e2[65] = "TRANSACTION_TOO_MANY_LAYERS"] = 65, o[e2[66] = "CONTRACT_DELETED"] = 66, o[e2[67] = "PLATFORM_NOT_ACTIVE"] = 67, o[e2[68] = "KEY_PREFIX_MISMATCH"] = 68, o[e2[69] = "PLATFORM_TRANSACTION_NOT_CREATED"] = 69, o[e2[70] = "INVALID_RENEWAL_PERIOD"] = 70, o[e2[71] = "INVALID_PAYER_ACCOUNT_ID"] = 71, o[e2[72] = "ACCOUNT_DELETED"] = 72, o[e2[73] = "FILE_DELETED"] = 73, o[e2[74] = "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS"] = 74, o[e2[75] = "SETTING_NEGATIVE_ACCOUNT_BALANCE"] = 75, o[e2[76] = "OBTAINER_REQUIRED"] = 76, o[e2[77] = "OBTAINER_SAME_CONTRACT_ID"] = 77, o[e2[78] = "OBTAINER_DOES_NOT_EXIST"] = 78, o[e2[79] = "MODIFYING_IMMUTABLE_CONTRACT"] = 79, o[e2[80] = "FILE_SYSTEM_EXCEPTION"] = 80, o[e2[81] = "AUTORENEW_DURATION_NOT_IN_RANGE"] = 81, o[e2[82] = "ERROR_DECODING_BYTESTRING"] = 82, o[e2[83] = "CONTRACT_FILE_EMPTY"] = 83, o[e2[84] = "CONTRACT_BYTECODE_EMPTY"] = 84, o[e2[85] = "INVALID_INITIAL_BALANCE"] = 85, o[e2[86] = "INVALID_RECEIVE_RECORD_THRESHOLD"] = 86, o[e2[87] = "INVALID_SEND_RECORD_THRESHOLD"] = 87, o[e2[88] = "ACCOUNT_IS_NOT_GENESIS_ACCOUNT"] = 88, o[e2[89] = "PAYER_ACCOUNT_UNAUTHORIZED"] = 89, o[e2[90] = "INVALID_FREEZE_TRANSACTION_BODY"] = 90, o[e2[91] = "FREEZE_TRANSACTION_BODY_NOT_FOUND"] = 91, o[e2[92] = "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"] = 92, o[e2[93] = "RESULT_SIZE_LIMIT_EXCEEDED"] = 93, o[e2[94] = "NOT_SPECIAL_ACCOUNT"] = 94, o[e2[95] = "CONTRACT_NEGATIVE_GAS"] = 95, o[e2[96] = "CONTRACT_NEGATIVE_VALUE"] = 96, o[e2[97] = "INVALID_FEE_FILE"] = 97, o[e2[98] = "INVALID_EXCHANGE_RATE_FILE"] = 98, o[e2[99] = "INSUFFICIENT_LOCAL_CALL_GAS"] = 99, o[e2[100] = "ENTITY_NOT_ALLOWED_TO_DELETE"] = 100, o[e2[101] = "AUTHORIZATION_FAILED"] = 101, o[e2[102] = "FILE_UPLOADED_PROTO_INVALID"] = 102, o[e2[103] = "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK"] = 103, o[e2[104] = "FEE_SCHEDULE_FILE_PART_UPLOADED"] = 104, o[e2[105] = "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED"] = 105, o[e2[106] = "MAX_CONTRACT_STORAGE_EXCEEDED"] = 106, o[e2[107] = "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT"] = 107, o[e2[108] = "TOTAL_LEDGER_BALANCE_INVALID"] = 108, o[e2[110] = "EXPIRATION_REDUCTION_NOT_ALLOWED"] = 110, o[e2[111] = "MAX_GAS_LIMIT_EXCEEDED"] = 111, o[e2[112] = "MAX_FILE_SIZE_EXCEEDED"] = 112, o[e2[113] = "RECEIVER_SIG_REQUIRED"] = 113, o[e2[150] = "INVALID_TOPIC_ID"] = 150, o[e2[155] = "INVALID_ADMIN_KEY"] = 155, o[e2[156] = "INVALID_SUBMIT_KEY"] = 156, o[e2[157] = "UNAUTHORIZED"] = 157, o[e2[158] = "INVALID_TOPIC_MESSAGE"] = 158, o[e2[159] = "INVALID_AUTORENEW_ACCOUNT"] = 159, o[e2[160] = "AUTORENEW_ACCOUNT_NOT_ALLOWED"] = 160, o[e2[162] = "TOPIC_EXPIRED"] = 162, o[e2[163] = "INVALID_CHUNK_NUMBER"] = 163, o[e2[164] = "INVALID_CHUNK_TRANSACTION_ID"] = 164, o[e2[165] = "ACCOUNT_FROZEN_FOR_TOKEN"] = 165, o[e2[166] = "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED"] = 166, o[e2[167] = "INVALID_TOKEN_ID"] = 167, o[e2[168] = "INVALID_TOKEN_DECIMALS"] = 168, o[e2[169] = "INVALID_TOKEN_INITIAL_SUPPLY"] = 169, o[e2[170] = "INVALID_TREASURY_ACCOUNT_FOR_TOKEN"] = 170, o[e2[171] = "INVALID_TOKEN_SYMBOL"] = 171, o[e2[172] = "TOKEN_HAS_NO_FREEZE_KEY"] = 172, o[e2[173] = "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN"] = 173, o[e2[174] = "MISSING_TOKEN_SYMBOL"] = 174, o[e2[175] = "TOKEN_SYMBOL_TOO_LONG"] = 175, o[e2[176] = "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN"] = 176, o[e2[177] = "TOKEN_HAS_NO_KYC_KEY"] = 177, o[e2[178] = "INSUFFICIENT_TOKEN_BALANCE"] = 178, o[e2[179] = "TOKEN_WAS_DELETED"] = 179, o[e2[180] = "TOKEN_HAS_NO_SUPPLY_KEY"] = 180, o[e2[181] = "TOKEN_HAS_NO_WIPE_KEY"] = 181, o[e2[182] = "INVALID_TOKEN_MINT_AMOUNT"] = 182, o[e2[183] = "INVALID_TOKEN_BURN_AMOUNT"] = 183, o[e2[184] = "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT"] = 184, o[e2[185] = "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT"] = 185, o[e2[186] = "INVALID_KYC_KEY"] = 186, o[e2[187] = "INVALID_WIPE_KEY"] = 187, o[e2[188] = "INVALID_FREEZE_KEY"] = 188, o[e2[189] = "INVALID_SUPPLY_KEY"] = 189, o[e2[190] = "MISSING_TOKEN_NAME"] = 190, o[e2[191] = "TOKEN_NAME_TOO_LONG"] = 191, o[e2[192] = "INVALID_WIPING_AMOUNT"] = 192, o[e2[193] = "TOKEN_IS_IMMUTABLE"] = 193, o[e2[194] = "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT"] = 194, o[e2[195] = "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES"] = 195, o[e2[196] = "ACCOUNT_IS_TREASURY"] = 196, o[e2[197] = "TOKEN_ID_REPEATED_IN_TOKEN_LIST"] = 197, o[e2[198] = "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"] = 198, o[e2[199] = "EMPTY_TOKEN_TRANSFER_BODY"] = 199, o[e2[200] = "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS"] = 200, o[e2[201] = "INVALID_SCHEDULE_ID"] = 201, o[e2[202] = "SCHEDULE_IS_IMMUTABLE"] = 202, o[e2[203] = "INVALID_SCHEDULE_PAYER_ID"] = 203, o[e2[204] = "INVALID_SCHEDULE_ACCOUNT_ID"] = 204, o[e2[205] = "NO_NEW_VALID_SIGNATURES"] = 205, o[e2[206] = "UNRESOLVABLE_REQUIRED_SIGNERS"] = 206, o[e2[207] = "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST"] = 207, o[e2[208] = "SOME_SIGNATURES_WERE_INVALID"] = 208, o[e2[209] = "TRANSACTION_ID_FIELD_NOT_ALLOWED"] = 209, o[e2[210] = "IDENTICAL_SCHEDULE_ALREADY_CREATED"] = 210, o[e2[211] = "INVALID_ZERO_BYTE_IN_STRING"] = 211, o[e2[212] = "SCHEDULE_ALREADY_DELETED"] = 212, o[e2[213] = "SCHEDULE_ALREADY_EXECUTED"] = 213, o[e2[214] = "MESSAGE_SIZE_TOO_LARGE"] = 214, o[e2[215] = "OPERATION_REPEATED_IN_BUCKET_GROUPS"] = 215, o[e2[216] = "BUCKET_CAPACITY_OVERFLOW"] = 216, o[e2[217] = "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION"] = 217, o[e2[218] = "BUCKET_HAS_NO_THROTTLE_GROUPS"] = 218, o[e2[219] = "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC"] = 219, o[e2[220] = "SUCCESS_BUT_MISSING_EXPECTED_OPERATION"] = 220, o[e2[221] = "UNPARSEABLE_THROTTLE_DEFINITIONS"] = 221, o[e2[222] = "INVALID_THROTTLE_DEFINITIONS"] = 222, o[e2[223] = "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL"] = 223, o[e2[224] = "INVALID_TOKEN_MAX_SUPPLY"] = 224, o[e2[225] = "INVALID_TOKEN_NFT_SERIAL_NUMBER"] = 225, o[e2[226] = "INVALID_NFT_ID"] = 226, o[e2[227] = "METADATA_TOO_LONG"] = 227, o[e2[228] = "BATCH_SIZE_LIMIT_EXCEEDED"] = 228, o[e2[229] = "INVALID_QUERY_RANGE"] = 229, o[e2[230] = "FRACTION_DIVIDES_BY_ZERO"] = 230, o[e2[231] = "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE"] = 231, o[e2[232] = "CUSTOM_FEES_LIST_TOO_LONG"] = 232, o[e2[233] = "INVALID_CUSTOM_FEE_COLLECTOR"] = 233, o[e2[234] = "INVALID_TOKEN_ID_IN_CUSTOM_FEES"] = 234, o[e2[235] = "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR"] = 235, o[e2[236] = "TOKEN_MAX_SUPPLY_REACHED"] = 236, o[e2[237] = "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO"] = 237, o[e2[238] = "CUSTOM_FEE_NOT_FULLY_SPECIFIED"] = 238, o[e2[239] = "CUSTOM_FEE_MUST_BE_POSITIVE"] = 239, o[e2[240] = "TOKEN_HAS_NO_FEE_SCHEDULE_KEY"] = 240, o[e2[241] = "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE"] = 241, o[e2[242] = "ROYALTY_FRACTION_CANNOT_EXCEED_ONE"] = 242, o[e2[243] = "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT"] = 243, o[e2[244] = "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES"] = 244, o[e2[245] = "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON"] = 245, o[e2[246] = "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"] = 246, o[e2[247] = "INVALID_CUSTOM_FEE_SCHEDULE_KEY"] = 247, o[e2[248] = "INVALID_TOKEN_MINT_METADATA"] = 248, o[e2[249] = "INVALID_TOKEN_BURN_METADATA"] = 249, o[e2[250] = "CURRENT_TREASURY_STILL_OWNS_NFTS"] = 250, o[e2[251] = "ACCOUNT_STILL_OWNS_NFTS"] = 251, o[e2[252] = "TREASURY_MUST_OWN_BURNED_NFT"] = 252, o[e2[253] = "ACCOUNT_DOES_NOT_OWN_WIPED_NFT"] = 253, o[e2[254] = "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"] = 254, o[e2[255] = "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED"] = 255, o[e2[256] = "PAYER_ACCOUNT_DELETED"] = 256, o[e2[257] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH"] = 257, o[e2[258] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS"] = 258, o[e2[259] = "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE"] = 259, o[e2[260] = "SERIAL_NUMBER_LIMIT_REACHED"] = 260, o[e2[261] = "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE"] = 261, o[e2[262] = "NO_REMAINING_AUTOMATIC_ASSOCIATIONS"] = 262, o[e2[263] = "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT"] = 263, o[e2[264] = "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT"] = 264, o[e2[265] = "TOKEN_IS_PAUSED"] = 265, o[e2[266] = "TOKEN_HAS_NO_PAUSE_KEY"] = 266, o[e2[267] = "INVALID_PAUSE_KEY"] = 267, o[e2[268] = "FREEZE_UPDATE_FILE_DOES_NOT_EXIST"] = 268, o[e2[269] = "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH"] = 269, o[e2[270] = "NO_UPGRADE_HAS_BEEN_PREPARED"] = 270, o[e2[271] = "NO_FREEZE_IS_SCHEDULED"] = 271, o[e2[272] = "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE"] = 272, o[e2[273] = "FREEZE_START_TIME_MUST_BE_FUTURE"] = 273, o[e2[274] = "PREPARED_UPDATE_FILE_IS_IMMUTABLE"] = 274, o[e2[275] = "FREEZE_ALREADY_SCHEDULED"] = 275, o[e2[276] = "FREEZE_UPGRADE_IN_PROGRESS"] = 276, o[e2[277] = "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED"] = 277, o[e2[278] = "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED"] = 278, o[e2[279] = "CONSENSUS_GAS_EXHAUSTED"] = 279, o[e2[280] = "REVERTED_SUCCESS"] = 280, o[e2[281] = "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED"] = 281, o[e2[282] = "INVALID_ALIAS_KEY"] = 282, o;
      }(), ConsensusTopicInfo: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.memo = "", e2.prototype.runningHash = $util.newBuffer([]), e2.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.expirationTime = null, e2.prototype.adminKey = null, e2.prototype.submitKey = null, e2.prototype.autoRenewPeriod = null, e2.prototype.autoRenewAccount = null, e2.prototype.ledgerId = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o.uint32(10).string(e3.memo), e3.runningHash != null && Object.hasOwnProperty.call(e3, "runningHash") && o.uint32(18).bytes(e3.runningHash), e3.sequenceNumber != null && Object.hasOwnProperty.call(e3, "sequenceNumber") && o.uint32(24).uint64(e3.sequenceNumber), e3.expirationTime != null && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o.uint32(34).fork()).ldelim(), e3.adminKey != null && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(42).fork()).ldelim(), e3.submitKey != null && Object.hasOwnProperty.call(e3, "submitKey") && $root.proto.Key.encode(e3.submitKey, o.uint32(50).fork()).ldelim(), e3.autoRenewPeriod != null && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(58).fork()).ldelim(), e3.autoRenewAccount != null && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(66).fork()).ldelim(), e3.ledgerId != null && Object.hasOwnProperty.call(e3, "ledgerId") && o.uint32(74).bytes(e3.ledgerId), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ConsensusTopicInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.memo = e3.string();
                break;
              case 2:
                i.runningHash = e3.bytes();
                break;
              case 3:
                i.sequenceNumber = e3.uint64();
                break;
              case 4:
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 5:
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 6:
                i.submitKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 7:
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              case 8:
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 9:
                i.ledgerId = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ConsensusService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createTopic = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "createTopic" }), Object.defineProperty(e2.prototype.updateTopic = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "updateTopic" }), Object.defineProperty(e2.prototype.deleteTopic = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "deleteTopic" }), Object.defineProperty(e2.prototype.getTopicInfo = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getTopicInfo" }), Object.defineProperty(e2.prototype.submitMessage = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "submitMessage" }), e2;
      }(), Query: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.getByKey = null, e2.prototype.getBySolidityID = null, e2.prototype.contractCallLocal = null, e2.prototype.contractGetInfo = null, e2.prototype.contractGetBytecode = null, e2.prototype.ContractGetRecords = null, e2.prototype.cryptogetAccountBalance = null, e2.prototype.cryptoGetAccountRecords = null, e2.prototype.cryptoGetInfo = null, e2.prototype.cryptoGetLiveHash = null, e2.prototype.cryptoGetProxyStakers = null, e2.prototype.fileGetContents = null, e2.prototype.fileGetInfo = null, e2.prototype.transactionGetReceipt = null, e2.prototype.transactionGetRecord = null, e2.prototype.transactionGetFastRecord = null, e2.prototype.consensusGetTopicInfo = null, e2.prototype.networkGetVersionInfo = null, e2.prototype.tokenGetInfo = null, e2.prototype.scheduleGetInfo = null, e2.prototype.tokenGetAccountNftInfos = null, e2.prototype.tokenGetNftInfo = null, e2.prototype.tokenGetNftInfos = null, e2.prototype.networkGetExecutionTime = null;
        let o;
        return Object.defineProperty(e2.prototype, "query", { get: $util.oneOfGetter(o = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetInfo", "contractGetBytecode", "ContractGetRecords", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo", "tokenGetInfo", "scheduleGetInfo", "tokenGetAccountNftInfos", "tokenGetNftInfo", "tokenGetNftInfos", "networkGetExecutionTime"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.getByKey != null && Object.hasOwnProperty.call(e3, "getByKey") && $root.proto.GetByKeyQuery.encode(e3.getByKey, o2.uint32(10).fork()).ldelim(), e3.getBySolidityID != null && Object.hasOwnProperty.call(e3, "getBySolidityID") && $root.proto.GetBySolidityIDQuery.encode(e3.getBySolidityID, o2.uint32(18).fork()).ldelim(), e3.contractCallLocal != null && Object.hasOwnProperty.call(e3, "contractCallLocal") && $root.proto.ContractCallLocalQuery.encode(e3.contractCallLocal, o2.uint32(26).fork()).ldelim(), e3.contractGetInfo != null && Object.hasOwnProperty.call(e3, "contractGetInfo") && $root.proto.ContractGetInfoQuery.encode(e3.contractGetInfo, o2.uint32(34).fork()).ldelim(), e3.contractGetBytecode != null && Object.hasOwnProperty.call(e3, "contractGetBytecode") && $root.proto.ContractGetBytecodeQuery.encode(e3.contractGetBytecode, o2.uint32(42).fork()).ldelim(), e3.ContractGetRecords != null && Object.hasOwnProperty.call(e3, "ContractGetRecords") && $root.proto.ContractGetRecordsQuery.encode(e3.ContractGetRecords, o2.uint32(50).fork()).ldelim(), e3.cryptogetAccountBalance != null && Object.hasOwnProperty.call(e3, "cryptogetAccountBalance") && $root.proto.CryptoGetAccountBalanceQuery.encode(e3.cryptogetAccountBalance, o2.uint32(58).fork()).ldelim(), e3.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(e3, "cryptoGetAccountRecords") && $root.proto.CryptoGetAccountRecordsQuery.encode(e3.cryptoGetAccountRecords, o2.uint32(66).fork()).ldelim(), e3.cryptoGetInfo != null && Object.hasOwnProperty.call(e3, "cryptoGetInfo") && $root.proto.CryptoGetInfoQuery.encode(e3.cryptoGetInfo, o2.uint32(74).fork()).ldelim(), e3.cryptoGetLiveHash != null && Object.hasOwnProperty.call(e3, "cryptoGetLiveHash") && $root.proto.CryptoGetLiveHashQuery.encode(e3.cryptoGetLiveHash, o2.uint32(82).fork()).ldelim(), e3.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(e3, "cryptoGetProxyStakers") && $root.proto.CryptoGetStakersQuery.encode(e3.cryptoGetProxyStakers, o2.uint32(90).fork()).ldelim(), e3.fileGetContents != null && Object.hasOwnProperty.call(e3, "fileGetContents") && $root.proto.FileGetContentsQuery.encode(e3.fileGetContents, o2.uint32(98).fork()).ldelim(), e3.fileGetInfo != null && Object.hasOwnProperty.call(e3, "fileGetInfo") && $root.proto.FileGetInfoQuery.encode(e3.fileGetInfo, o2.uint32(106).fork()).ldelim(), e3.transactionGetReceipt != null && Object.hasOwnProperty.call(e3, "transactionGetReceipt") && $root.proto.TransactionGetReceiptQuery.encode(e3.transactionGetReceipt, o2.uint32(114).fork()).ldelim(), e3.transactionGetRecord != null && Object.hasOwnProperty.call(e3, "transactionGetRecord") && $root.proto.TransactionGetRecordQuery.encode(e3.transactionGetRecord, o2.uint32(122).fork()).ldelim(), e3.transactionGetFastRecord != null && Object.hasOwnProperty.call(e3, "transactionGetFastRecord") && $root.proto.TransactionGetFastRecordQuery.encode(e3.transactionGetFastRecord, o2.uint32(130).fork()).ldelim(), e3.consensusGetTopicInfo != null && Object.hasOwnProperty.call(e3, "consensusGetTopicInfo") && $root.proto.ConsensusGetTopicInfoQuery.encode(e3.consensusGetTopicInfo, o2.uint32(402).fork()).ldelim(), e3.networkGetVersionInfo != null && Object.hasOwnProperty.call(e3, "networkGetVersionInfo") && $root.proto.NetworkGetVersionInfoQuery.encode(e3.networkGetVersionInfo, o2.uint32(410).fork()).ldelim(), e3.tokenGetInfo != null && Object.hasOwnProperty.call(e3, "tokenGetInfo") && $root.proto.TokenGetInfoQuery.encode(e3.tokenGetInfo, o2.uint32(418).fork()).ldelim(), e3.scheduleGetInfo != null && Object.hasOwnProperty.call(e3, "scheduleGetInfo") && $root.proto.ScheduleGetInfoQuery.encode(e3.scheduleGetInfo, o2.uint32(426).fork()).ldelim(), e3.tokenGetAccountNftInfos != null && Object.hasOwnProperty.call(e3, "tokenGetAccountNftInfos") && $root.proto.TokenGetAccountNftInfosQuery.encode(e3.tokenGetAccountNftInfos, o2.uint32(434).fork()).ldelim(), e3.tokenGetNftInfo != null && Object.hasOwnProperty.call(e3, "tokenGetNftInfo") && $root.proto.TokenGetNftInfoQuery.encode(e3.tokenGetNftInfo, o2.uint32(442).fork()).ldelim(), e3.tokenGetNftInfos != null && Object.hasOwnProperty.call(e3, "tokenGetNftInfos") && $root.proto.TokenGetNftInfosQuery.encode(e3.tokenGetNftInfos, o2.uint32(450).fork()).ldelim(), e3.networkGetExecutionTime != null && Object.hasOwnProperty.call(e3, "networkGetExecutionTime") && $root.proto.NetworkGetExecutionTimeQuery.encode(e3.networkGetExecutionTime, o2.uint32(458).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.Query(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.getByKey = $root.proto.GetByKeyQuery.decode(e3, e3.uint32());
                break;
              case 2:
                i.getBySolidityID = $root.proto.GetBySolidityIDQuery.decode(e3, e3.uint32());
                break;
              case 3:
                i.contractCallLocal = $root.proto.ContractCallLocalQuery.decode(e3, e3.uint32());
                break;
              case 4:
                i.contractGetInfo = $root.proto.ContractGetInfoQuery.decode(e3, e3.uint32());
                break;
              case 5:
                i.contractGetBytecode = $root.proto.ContractGetBytecodeQuery.decode(e3, e3.uint32());
                break;
              case 6:
                i.ContractGetRecords = $root.proto.ContractGetRecordsQuery.decode(e3, e3.uint32());
                break;
              case 7:
                i.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceQuery.decode(e3, e3.uint32());
                break;
              case 8:
                i.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsQuery.decode(e3, e3.uint32());
                break;
              case 9:
                i.cryptoGetInfo = $root.proto.CryptoGetInfoQuery.decode(e3, e3.uint32());
                break;
              case 10:
                i.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashQuery.decode(e3, e3.uint32());
                break;
              case 11:
                i.cryptoGetProxyStakers = $root.proto.CryptoGetStakersQuery.decode(e3, e3.uint32());
                break;
              case 12:
                i.fileGetContents = $root.proto.FileGetContentsQuery.decode(e3, e3.uint32());
                break;
              case 13:
                i.fileGetInfo = $root.proto.FileGetInfoQuery.decode(e3, e3.uint32());
                break;
              case 14:
                i.transactionGetReceipt = $root.proto.TransactionGetReceiptQuery.decode(e3, e3.uint32());
                break;
              case 15:
                i.transactionGetRecord = $root.proto.TransactionGetRecordQuery.decode(e3, e3.uint32());
                break;
              case 16:
                i.transactionGetFastRecord = $root.proto.TransactionGetFastRecordQuery.decode(e3, e3.uint32());
                break;
              case 50:
                i.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoQuery.decode(e3, e3.uint32());
                break;
              case 51:
                i.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoQuery.decode(e3, e3.uint32());
                break;
              case 52:
                i.tokenGetInfo = $root.proto.TokenGetInfoQuery.decode(e3, e3.uint32());
                break;
              case 53:
                i.scheduleGetInfo = $root.proto.ScheduleGetInfoQuery.decode(e3, e3.uint32());
                break;
              case 54:
                i.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosQuery.decode(e3, e3.uint32());
                break;
              case 55:
                i.tokenGetNftInfo = $root.proto.TokenGetNftInfoQuery.decode(e3, e3.uint32());
                break;
              case 56:
                i.tokenGetNftInfos = $root.proto.TokenGetNftInfosQuery.decode(e3, e3.uint32());
                break;
              case 57:
                i.networkGetExecutionTime = $root.proto.NetworkGetExecutionTimeQuery.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), GetByKeyQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.key = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.key != null && Object.hasOwnProperty.call(e3, "key") && $root.proto.Key.encode(e3.key, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.GetByKeyQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.key = $root.proto.Key.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), EntityID: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.accountID = null, e2.prototype.liveHash = null, e2.prototype.fileID = null, e2.prototype.contractID = null;
        let o;
        return Object.defineProperty(e2.prototype, "entity", { get: $util.oneOfGetter(o = ["accountID", "liveHash", "fileID", "contractID"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o2.uint32(10).fork()).ldelim(), e3.liveHash != null && Object.hasOwnProperty.call(e3, "liveHash") && $root.proto.LiveHash.encode(e3.liveHash, o2.uint32(18).fork()).ldelim(), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o2.uint32(26).fork()).ldelim(), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(34).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.EntityID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 2:
                i.liveHash = $root.proto.LiveHash.decode(e3, e3.uint32());
                break;
              case 3:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              case 4:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), GetByKeyResponse: function() {
        function e2(e3) {
          if (this.entities = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.entities = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.entities != null && e3.entities.length)
            for (var t = 0; t < e3.entities.length; ++t)
              $root.proto.EntityID.encode(e3.entities[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.GetByKeyResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.entities && i.entities.length || (i.entities = []), i.entities.push($root.proto.EntityID.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), GetBySolidityIDQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.solidityID = "", e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.solidityID != null && Object.hasOwnProperty.call(e3, "solidityID") && o.uint32(18).string(e3.solidityID), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.GetBySolidityIDQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.solidityID = e3.string();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), GetBySolidityIDResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.fileID = null, e2.prototype.contractID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(26).fork()).ldelim(), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(34).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.GetBySolidityIDResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              case 4:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractLoginfo: function() {
        function e2(e3) {
          if (this.topic = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.contractID = null, e2.prototype.bloom = $util.newBuffer([]), e2.prototype.topic = $util.emptyArray, e2.prototype.data = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(10).fork()).ldelim(), e3.bloom != null && Object.hasOwnProperty.call(e3, "bloom") && o.uint32(18).bytes(e3.bloom), e3.topic != null && e3.topic.length)
            for (var t = 0; t < e3.topic.length; ++t)
              o.uint32(26).bytes(e3.topic[t]);
          return e3.data != null && Object.hasOwnProperty.call(e3, "data") && o.uint32(34).bytes(e3.data), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractLoginfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              case 2:
                i.bloom = e3.bytes();
                break;
              case 3:
                i.topic && i.topic.length || (i.topic = []), i.topic.push(e3.bytes());
                break;
              case 4:
                i.data = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractFunctionResult: function() {
        function e2(e3) {
          if (this.logInfo = [], this.createdContractIDs = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.contractID = null, e2.prototype.contractCallResult = $util.newBuffer([]), e2.prototype.errorMessage = "", e2.prototype.bloom = $util.newBuffer([]), e2.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.logInfo = $util.emptyArray, e2.prototype.createdContractIDs = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(10).fork()).ldelim(), e3.contractCallResult != null && Object.hasOwnProperty.call(e3, "contractCallResult") && o.uint32(18).bytes(e3.contractCallResult), e3.errorMessage != null && Object.hasOwnProperty.call(e3, "errorMessage") && o.uint32(26).string(e3.errorMessage), e3.bloom != null && Object.hasOwnProperty.call(e3, "bloom") && o.uint32(34).bytes(e3.bloom), e3.gasUsed != null && Object.hasOwnProperty.call(e3, "gasUsed") && o.uint32(40).uint64(e3.gasUsed), e3.logInfo != null && e3.logInfo.length)
            for (var t = 0; t < e3.logInfo.length; ++t)
              $root.proto.ContractLoginfo.encode(e3.logInfo[t], o.uint32(50).fork()).ldelim();
          if (e3.createdContractIDs != null && e3.createdContractIDs.length)
            for (var t = 0; t < e3.createdContractIDs.length; ++t)
              $root.proto.ContractID.encode(e3.createdContractIDs[t], o.uint32(58).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractFunctionResult(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              case 2:
                i.contractCallResult = e3.bytes();
                break;
              case 3:
                i.errorMessage = e3.string();
                break;
              case 4:
                i.bloom = e3.bytes();
                break;
              case 5:
                i.gasUsed = e3.uint64();
                break;
              case 6:
                i.logInfo && i.logInfo.length || (i.logInfo = []), i.logInfo.push($root.proto.ContractLoginfo.decode(e3, e3.uint32()));
                break;
              case 7:
                i.createdContractIDs && i.createdContractIDs.length || (i.createdContractIDs = []), i.createdContractIDs.push($root.proto.ContractID.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractCallLocalQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractID = null, e2.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.functionParameters = $util.newBuffer([]), e2.prototype.maxResultSize = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(18).fork()).ldelim(), e3.gas != null && Object.hasOwnProperty.call(e3, "gas") && o.uint32(24).int64(e3.gas), e3.functionParameters != null && Object.hasOwnProperty.call(e3, "functionParameters") && o.uint32(34).bytes(e3.functionParameters), e3.maxResultSize != null && Object.hasOwnProperty.call(e3, "maxResultSize") && o.uint32(40).int64(e3.maxResultSize), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractCallLocalQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              case 3:
                i.gas = e3.int64();
                break;
              case 4:
                i.functionParameters = e3.bytes();
                break;
              case 5:
                i.maxResultSize = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractCallLocalResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.functionResult = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.functionResult != null && Object.hasOwnProperty.call(e3, "functionResult") && $root.proto.ContractFunctionResult.encode(e3.functionResult, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractCallLocalResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.functionResult = $root.proto.ContractFunctionResult.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractGetInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractGetInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractGetInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.contractInfo != null && Object.hasOwnProperty.call(e3, "contractInfo") && $root.proto.ContractGetInfoResponse.ContractInfo.encode(e3.contractInfo, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractGetInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.contractInfo = $root.proto.ContractGetInfoResponse.ContractInfo.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.ContractInfo = function() {
          function e3(e4) {
            if (this.tokenRelationships = [], e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.contractID = null, e3.prototype.accountID = null, e3.prototype.contractAccountID = "", e3.prototype.adminKey = null, e3.prototype.expirationTime = null, e3.prototype.autoRenewPeriod = null, e3.prototype.storage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.prototype.memo = "", e3.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e3.prototype.deleted = false, e3.prototype.tokenRelationships = $util.emptyArray, e3.prototype.ledgerId = $util.newBuffer([]), e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            if (o || (o = $Writer.create()), e4.contractID != null && Object.hasOwnProperty.call(e4, "contractID") && $root.proto.ContractID.encode(e4.contractID, o.uint32(10).fork()).ldelim(), e4.accountID != null && Object.hasOwnProperty.call(e4, "accountID") && $root.proto.AccountID.encode(e4.accountID, o.uint32(18).fork()).ldelim(), e4.contractAccountID != null && Object.hasOwnProperty.call(e4, "contractAccountID") && o.uint32(26).string(e4.contractAccountID), e4.adminKey != null && Object.hasOwnProperty.call(e4, "adminKey") && $root.proto.Key.encode(e4.adminKey, o.uint32(34).fork()).ldelim(), e4.expirationTime != null && Object.hasOwnProperty.call(e4, "expirationTime") && $root.proto.Timestamp.encode(e4.expirationTime, o.uint32(42).fork()).ldelim(), e4.autoRenewPeriod != null && Object.hasOwnProperty.call(e4, "autoRenewPeriod") && $root.proto.Duration.encode(e4.autoRenewPeriod, o.uint32(50).fork()).ldelim(), e4.storage != null && Object.hasOwnProperty.call(e4, "storage") && o.uint32(56).int64(e4.storage), e4.memo != null && Object.hasOwnProperty.call(e4, "memo") && o.uint32(66).string(e4.memo), e4.balance != null && Object.hasOwnProperty.call(e4, "balance") && o.uint32(72).uint64(e4.balance), e4.deleted != null && Object.hasOwnProperty.call(e4, "deleted") && o.uint32(80).bool(e4.deleted), e4.tokenRelationships != null && e4.tokenRelationships.length)
              for (var t = 0; t < e4.tokenRelationships.length; ++t)
                $root.proto.TokenRelationship.encode(e4.tokenRelationships[t], o.uint32(90).fork()).ldelim();
            return e4.ledgerId != null && Object.hasOwnProperty.call(e4, "ledgerId") && o.uint32(98).bytes(e4.ledgerId), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.proto.ContractGetInfoResponse.ContractInfo(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.contractID = $root.proto.ContractID.decode(e4, e4.uint32());
                  break;
                case 2:
                  i.accountID = $root.proto.AccountID.decode(e4, e4.uint32());
                  break;
                case 3:
                  i.contractAccountID = e4.string();
                  break;
                case 4:
                  i.adminKey = $root.proto.Key.decode(e4, e4.uint32());
                  break;
                case 5:
                  i.expirationTime = $root.proto.Timestamp.decode(e4, e4.uint32());
                  break;
                case 6:
                  i.autoRenewPeriod = $root.proto.Duration.decode(e4, e4.uint32());
                  break;
                case 7:
                  i.storage = e4.int64();
                  break;
                case 8:
                  i.memo = e4.string();
                  break;
                case 9:
                  i.balance = e4.uint64();
                  break;
                case 10:
                  i.deleted = e4.bool();
                  break;
                case 11:
                  i.tokenRelationships && i.tokenRelationships.length || (i.tokenRelationships = []), i.tokenRelationships.push($root.proto.TokenRelationship.decode(e4, e4.uint32()));
                  break;
                case 12:
                  i.ledgerId = e4.bytes();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), e2;
      }(), ContractGetBytecodeQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractGetBytecodeQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractGetBytecodeResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.bytecode = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.bytecode != null && Object.hasOwnProperty.call(e3, "bytecode") && o.uint32(50).bytes(e3.bytecode), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractGetBytecodeResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 6:
                i.bytecode = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractGetRecordsQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractGetRecordsQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ContractGetRecordsResponse: function() {
        function e2(e3) {
          if (this.records = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.contractID = null, e2.prototype.records = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(18).fork()).ldelim(), e3.records != null && e3.records.length)
            for (var t = 0; t < e3.records.length; ++t)
              $root.proto.TransactionRecord.encode(e3.records[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ContractGetRecordsResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              case 3:
                i.records && i.records.length || (i.records = []), i.records.push($root.proto.TransactionRecord.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionRecord: function() {
        function e2(e3) {
          if (this.tokenTransferLists = [], this.assessedCustomFees = [], this.automaticTokenAssociations = [], e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.receipt = null, e2.prototype.transactionHash = $util.newBuffer([]), e2.prototype.consensusTimestamp = null, e2.prototype.transactionID = null, e2.prototype.memo = "", e2.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.contractCallResult = null, e2.prototype.contractCreateResult = null, e2.prototype.transferList = null, e2.prototype.tokenTransferLists = $util.emptyArray, e2.prototype.scheduleRef = null, e2.prototype.assessedCustomFees = $util.emptyArray, e2.prototype.automaticTokenAssociations = $util.emptyArray, e2.prototype.parentConsensusTimestamp = null, e2.prototype.alias = $util.newBuffer([]);
        let o;
        return Object.defineProperty(e2.prototype, "body", { get: $util.oneOfGetter(o = ["contractCallResult", "contractCreateResult"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          if (o2 || (o2 = $Writer.create()), e3.receipt != null && Object.hasOwnProperty.call(e3, "receipt") && $root.proto.TransactionReceipt.encode(e3.receipt, o2.uint32(10).fork()).ldelim(), e3.transactionHash != null && Object.hasOwnProperty.call(e3, "transactionHash") && o2.uint32(18).bytes(e3.transactionHash), e3.consensusTimestamp != null && Object.hasOwnProperty.call(e3, "consensusTimestamp") && $root.proto.Timestamp.encode(e3.consensusTimestamp, o2.uint32(26).fork()).ldelim(), e3.transactionID != null && Object.hasOwnProperty.call(e3, "transactionID") && $root.proto.TransactionID.encode(e3.transactionID, o2.uint32(34).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(42).string(e3.memo), e3.transactionFee != null && Object.hasOwnProperty.call(e3, "transactionFee") && o2.uint32(48).uint64(e3.transactionFee), e3.contractCallResult != null && Object.hasOwnProperty.call(e3, "contractCallResult") && $root.proto.ContractFunctionResult.encode(e3.contractCallResult, o2.uint32(58).fork()).ldelim(), e3.contractCreateResult != null && Object.hasOwnProperty.call(e3, "contractCreateResult") && $root.proto.ContractFunctionResult.encode(e3.contractCreateResult, o2.uint32(66).fork()).ldelim(), e3.transferList != null && Object.hasOwnProperty.call(e3, "transferList") && $root.proto.TransferList.encode(e3.transferList, o2.uint32(82).fork()).ldelim(), e3.tokenTransferLists != null && e3.tokenTransferLists.length)
            for (var t = 0; t < e3.tokenTransferLists.length; ++t)
              $root.proto.TokenTransferList.encode(e3.tokenTransferLists[t], o2.uint32(90).fork()).ldelim();
          if (e3.scheduleRef != null && Object.hasOwnProperty.call(e3, "scheduleRef") && $root.proto.ScheduleID.encode(e3.scheduleRef, o2.uint32(98).fork()).ldelim(), e3.assessedCustomFees != null && e3.assessedCustomFees.length)
            for (var t = 0; t < e3.assessedCustomFees.length; ++t)
              $root.proto.AssessedCustomFee.encode(e3.assessedCustomFees[t], o2.uint32(106).fork()).ldelim();
          if (e3.automaticTokenAssociations != null && e3.automaticTokenAssociations.length)
            for (var t = 0; t < e3.automaticTokenAssociations.length; ++t)
              $root.proto.TokenAssociation.encode(e3.automaticTokenAssociations[t], o2.uint32(114).fork()).ldelim();
          return e3.parentConsensusTimestamp != null && Object.hasOwnProperty.call(e3, "parentConsensusTimestamp") && $root.proto.Timestamp.encode(e3.parentConsensusTimestamp, o2.uint32(122).fork()).ldelim(), e3.alias != null && Object.hasOwnProperty.call(e3, "alias") && o2.uint32(130).bytes(e3.alias), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.TransactionRecord(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.receipt = $root.proto.TransactionReceipt.decode(e3, e3.uint32());
                break;
              case 2:
                i.transactionHash = e3.bytes();
                break;
              case 3:
                i.consensusTimestamp = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 4:
                i.transactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              case 5:
                i.memo = e3.string();
                break;
              case 6:
                i.transactionFee = e3.uint64();
                break;
              case 7:
                i.contractCallResult = $root.proto.ContractFunctionResult.decode(e3, e3.uint32());
                break;
              case 8:
                i.contractCreateResult = $root.proto.ContractFunctionResult.decode(e3, e3.uint32());
                break;
              case 10:
                i.transferList = $root.proto.TransferList.decode(e3, e3.uint32());
                break;
              case 11:
                i.tokenTransferLists && i.tokenTransferLists.length || (i.tokenTransferLists = []), i.tokenTransferLists.push($root.proto.TokenTransferList.decode(e3, e3.uint32()));
                break;
              case 12:
                i.scheduleRef = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              case 13:
                i.assessedCustomFees && i.assessedCustomFees.length || (i.assessedCustomFees = []), i.assessedCustomFees.push($root.proto.AssessedCustomFee.decode(e3, e3.uint32()));
                break;
              case 14:
                i.automaticTokenAssociations && i.automaticTokenAssociations.length || (i.automaticTokenAssociations = []), i.automaticTokenAssociations.push($root.proto.TokenAssociation.decode(e3, e3.uint32()));
                break;
              case 15:
                i.parentConsensusTimestamp = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 16:
                i.alias = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionReceipt: function() {
        function e2(e3) {
          if (this.serialNumbers = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.status = 0, e2.prototype.accountID = null, e2.prototype.fileID = null, e2.prototype.contractID = null, e2.prototype.exchangeRate = null, e2.prototype.topicID = null, e2.prototype.topicSequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.topicRunningHash = $util.newBuffer([]), e2.prototype.topicRunningHashVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.tokenID = null, e2.prototype.newTotalSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.scheduleID = null, e2.prototype.scheduledTransactionID = null, e2.prototype.serialNumbers = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.status != null && Object.hasOwnProperty.call(e3, "status") && o.uint32(8).int32(e3.status), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(26).fork()).ldelim(), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o.uint32(34).fork()).ldelim(), e3.exchangeRate != null && Object.hasOwnProperty.call(e3, "exchangeRate") && $root.proto.ExchangeRateSet.encode(e3.exchangeRate, o.uint32(42).fork()).ldelim(), e3.topicID != null && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(50).fork()).ldelim(), e3.topicSequenceNumber != null && Object.hasOwnProperty.call(e3, "topicSequenceNumber") && o.uint32(56).uint64(e3.topicSequenceNumber), e3.topicRunningHash != null && Object.hasOwnProperty.call(e3, "topicRunningHash") && o.uint32(66).bytes(e3.topicRunningHash), e3.topicRunningHashVersion != null && Object.hasOwnProperty.call(e3, "topicRunningHashVersion") && o.uint32(72).uint64(e3.topicRunningHashVersion), e3.tokenID != null && Object.hasOwnProperty.call(e3, "tokenID") && $root.proto.TokenID.encode(e3.tokenID, o.uint32(82).fork()).ldelim(), e3.newTotalSupply != null && Object.hasOwnProperty.call(e3, "newTotalSupply") && o.uint32(88).uint64(e3.newTotalSupply), e3.scheduleID != null && Object.hasOwnProperty.call(e3, "scheduleID") && $root.proto.ScheduleID.encode(e3.scheduleID, o.uint32(98).fork()).ldelim(), e3.scheduledTransactionID != null && Object.hasOwnProperty.call(e3, "scheduledTransactionID") && $root.proto.TransactionID.encode(e3.scheduledTransactionID, o.uint32(106).fork()).ldelim(), e3.serialNumbers != null && e3.serialNumbers.length) {
            o.uint32(114).fork();
            for (var t = 0; t < e3.serialNumbers.length; ++t)
              o.int64(e3.serialNumbers[t]);
            o.ldelim();
          }
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransactionReceipt(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.status = e3.int32();
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              case 4:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              case 5:
                i.exchangeRate = $root.proto.ExchangeRateSet.decode(e3, e3.uint32());
                break;
              case 6:
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              case 7:
                i.topicSequenceNumber = e3.uint64();
                break;
              case 8:
                i.topicRunningHash = e3.bytes();
                break;
              case 9:
                i.topicRunningHashVersion = e3.uint64();
                break;
              case 10:
                i.tokenID = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 11:
                i.newTotalSupply = e3.uint64();
                break;
              case 12:
                i.scheduleID = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              case 13:
                i.scheduledTransactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              case 14:
                if (i.serialNumbers && i.serialNumbers.length || (i.serialNumbers = []), (7 & d) == 2)
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.serialNumbers.push(e3.int64());
                else
                  i.serialNumbers.push(e3.int64());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ExchangeRate: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.hbarEquiv = 0, e2.prototype.centEquiv = 0, e2.prototype.expirationTime = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.hbarEquiv != null && Object.hasOwnProperty.call(e3, "hbarEquiv") && o.uint32(8).int32(e3.hbarEquiv), e3.centEquiv != null && Object.hasOwnProperty.call(e3, "centEquiv") && o.uint32(16).int32(e3.centEquiv), e3.expirationTime != null && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.TimestampSeconds.encode(e3.expirationTime, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ExchangeRate(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.hbarEquiv = e3.int32();
                break;
              case 2:
                i.centEquiv = e3.int32();
                break;
              case 3:
                i.expirationTime = $root.proto.TimestampSeconds.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ExchangeRateSet: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.currentRate = null, e2.prototype.nextRate = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.currentRate != null && Object.hasOwnProperty.call(e3, "currentRate") && $root.proto.ExchangeRate.encode(e3.currentRate, o.uint32(10).fork()).ldelim(), e3.nextRate != null && Object.hasOwnProperty.call(e3, "nextRate") && $root.proto.ExchangeRate.encode(e3.nextRate, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ExchangeRateSet(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.currentRate = $root.proto.ExchangeRate.decode(e3, e3.uint32());
                break;
              case 2:
                i.nextRate = $root.proto.ExchangeRate.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoGetAccountBalanceQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.contractID = null;
        let o;
        return Object.defineProperty(e2.prototype, "balanceSource", { get: $util.oneOfGetter(o = ["accountID", "contractID"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o2.uint32(10).fork()).ldelim(), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o2.uint32(18).fork()).ldelim(), e3.contractID != null && Object.hasOwnProperty.call(e3, "contractID") && $root.proto.ContractID.encode(e3.contractID, o2.uint32(26).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.CryptoGetAccountBalanceQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.contractID = $root.proto.ContractID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoGetAccountBalanceResponse: function() {
        function e2(e3) {
          if (this.tokenBalances = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.tokenBalances = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), e3.balance != null && Object.hasOwnProperty.call(e3, "balance") && o.uint32(24).uint64(e3.balance), e3.tokenBalances != null && e3.tokenBalances.length)
            for (var t = 0; t < e3.tokenBalances.length; ++t)
              $root.proto.TokenBalance.encode(e3.tokenBalances[t], o.uint32(34).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetAccountBalanceResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.balance = e3.uint64();
                break;
              case 4:
                i.tokenBalances && i.tokenBalances.length || (i.tokenBalances = []), i.tokenBalances.push($root.proto.TokenBalance.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoGetAccountRecordsQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetAccountRecordsQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoGetAccountRecordsResponse: function() {
        function e2(e3) {
          if (this.records = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.records = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), e3.records != null && e3.records.length)
            for (var t = 0; t < e3.records.length; ++t)
              $root.proto.TransactionRecord.encode(e3.records[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetAccountRecordsResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.records && i.records.length || (i.records = []), i.records.push($root.proto.TransactionRecord.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoGetInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoGetInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.accountInfo != null && Object.hasOwnProperty.call(e3, "accountInfo") && $root.proto.CryptoGetInfoResponse.AccountInfo.encode(e3.accountInfo, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountInfo = $root.proto.CryptoGetInfoResponse.AccountInfo.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.AccountInfo = function() {
          function e3(e4) {
            if (this.liveHashes = [], this.tokenRelationships = [], e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.accountID = null, e3.prototype.contractAccountID = "", e3.prototype.deleted = false, e3.prototype.proxyAccountID = null, e3.prototype.proxyReceived = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.prototype.key = null, e3.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e3.prototype.generateSendRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e3.prototype.generateReceiveRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e3.prototype.receiverSigRequired = false, e3.prototype.expirationTime = null, e3.prototype.autoRenewPeriod = null, e3.prototype.liveHashes = $util.emptyArray, e3.prototype.tokenRelationships = $util.emptyArray, e3.prototype.memo = "", e3.prototype.ownedNfts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.prototype.maxAutomaticTokenAssociations = 0, e3.prototype.alias = $util.newBuffer([]), e3.prototype.ledgerId = $util.newBuffer([]), e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            if (o || (o = $Writer.create()), e4.accountID != null && Object.hasOwnProperty.call(e4, "accountID") && $root.proto.AccountID.encode(e4.accountID, o.uint32(10).fork()).ldelim(), e4.contractAccountID != null && Object.hasOwnProperty.call(e4, "contractAccountID") && o.uint32(18).string(e4.contractAccountID), e4.deleted != null && Object.hasOwnProperty.call(e4, "deleted") && o.uint32(24).bool(e4.deleted), e4.proxyAccountID != null && Object.hasOwnProperty.call(e4, "proxyAccountID") && $root.proto.AccountID.encode(e4.proxyAccountID, o.uint32(34).fork()).ldelim(), e4.proxyReceived != null && Object.hasOwnProperty.call(e4, "proxyReceived") && o.uint32(48).int64(e4.proxyReceived), e4.key != null && Object.hasOwnProperty.call(e4, "key") && $root.proto.Key.encode(e4.key, o.uint32(58).fork()).ldelim(), e4.balance != null && Object.hasOwnProperty.call(e4, "balance") && o.uint32(64).uint64(e4.balance), e4.generateSendRecordThreshold != null && Object.hasOwnProperty.call(e4, "generateSendRecordThreshold") && o.uint32(72).uint64(e4.generateSendRecordThreshold), e4.generateReceiveRecordThreshold != null && Object.hasOwnProperty.call(e4, "generateReceiveRecordThreshold") && o.uint32(80).uint64(e4.generateReceiveRecordThreshold), e4.receiverSigRequired != null && Object.hasOwnProperty.call(e4, "receiverSigRequired") && o.uint32(88).bool(e4.receiverSigRequired), e4.expirationTime != null && Object.hasOwnProperty.call(e4, "expirationTime") && $root.proto.Timestamp.encode(e4.expirationTime, o.uint32(98).fork()).ldelim(), e4.autoRenewPeriod != null && Object.hasOwnProperty.call(e4, "autoRenewPeriod") && $root.proto.Duration.encode(e4.autoRenewPeriod, o.uint32(106).fork()).ldelim(), e4.liveHashes != null && e4.liveHashes.length)
              for (var t = 0; t < e4.liveHashes.length; ++t)
                $root.proto.LiveHash.encode(e4.liveHashes[t], o.uint32(114).fork()).ldelim();
            if (e4.tokenRelationships != null && e4.tokenRelationships.length)
              for (var t = 0; t < e4.tokenRelationships.length; ++t)
                $root.proto.TokenRelationship.encode(e4.tokenRelationships[t], o.uint32(122).fork()).ldelim();
            return e4.memo != null && Object.hasOwnProperty.call(e4, "memo") && o.uint32(130).string(e4.memo), e4.ownedNfts != null && Object.hasOwnProperty.call(e4, "ownedNfts") && o.uint32(136).int64(e4.ownedNfts), e4.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(e4, "maxAutomaticTokenAssociations") && o.uint32(144).int32(e4.maxAutomaticTokenAssociations), e4.alias != null && Object.hasOwnProperty.call(e4, "alias") && o.uint32(154).bytes(e4.alias), e4.ledgerId != null && Object.hasOwnProperty.call(e4, "ledgerId") && o.uint32(162).bytes(e4.ledgerId), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.proto.CryptoGetInfoResponse.AccountInfo(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.accountID = $root.proto.AccountID.decode(e4, e4.uint32());
                  break;
                case 2:
                  i.contractAccountID = e4.string();
                  break;
                case 3:
                  i.deleted = e4.bool();
                  break;
                case 4:
                  i.proxyAccountID = $root.proto.AccountID.decode(e4, e4.uint32());
                  break;
                case 6:
                  i.proxyReceived = e4.int64();
                  break;
                case 7:
                  i.key = $root.proto.Key.decode(e4, e4.uint32());
                  break;
                case 8:
                  i.balance = e4.uint64();
                  break;
                case 9:
                  i.generateSendRecordThreshold = e4.uint64();
                  break;
                case 10:
                  i.generateReceiveRecordThreshold = e4.uint64();
                  break;
                case 11:
                  i.receiverSigRequired = e4.bool();
                  break;
                case 12:
                  i.expirationTime = $root.proto.Timestamp.decode(e4, e4.uint32());
                  break;
                case 13:
                  i.autoRenewPeriod = $root.proto.Duration.decode(e4, e4.uint32());
                  break;
                case 14:
                  i.liveHashes && i.liveHashes.length || (i.liveHashes = []), i.liveHashes.push($root.proto.LiveHash.decode(e4, e4.uint32()));
                  break;
                case 15:
                  i.tokenRelationships && i.tokenRelationships.length || (i.tokenRelationships = []), i.tokenRelationships.push($root.proto.TokenRelationship.decode(e4, e4.uint32()));
                  break;
                case 16:
                  i.memo = e4.string();
                  break;
                case 17:
                  i.ownedNfts = e4.int64();
                  break;
                case 18:
                  i.maxAutomaticTokenAssociations = e4.int32();
                  break;
                case 19:
                  i.alias = e4.bytes();
                  break;
                case 20:
                  i.ledgerId = e4.bytes();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), e2;
      }(), CryptoGetLiveHashQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.hash = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), e3.hash != null && Object.hasOwnProperty.call(e3, "hash") && o.uint32(26).bytes(e3.hash), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetLiveHashQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.hash = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoGetLiveHashResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.liveHash = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.liveHash != null && Object.hasOwnProperty.call(e3, "liveHash") && $root.proto.LiveHash.encode(e3.liveHash, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetLiveHashResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.liveHash = $root.proto.LiveHash.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoGetStakersQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetStakersQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ProxyStaker: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountID = null, e2.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(10).fork()).ldelim(), e3.amount != null && Object.hasOwnProperty.call(e3, "amount") && o.uint32(16).int64(e3.amount), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ProxyStaker(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 2:
                i.amount = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), AllProxyStakers: function() {
        function e2(e3) {
          if (this.proxyStaker = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.accountID = null, e2.prototype.proxyStaker = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(10).fork()).ldelim(), e3.proxyStaker != null && e3.proxyStaker.length)
            for (var t = 0; t < e3.proxyStaker.length; ++t)
              $root.proto.ProxyStaker.encode(e3.proxyStaker[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.AllProxyStakers(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 2:
                i.proxyStaker && i.proxyStaker.length || (i.proxyStaker = []), i.proxyStaker.push($root.proto.ProxyStaker.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoGetStakersResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.stakers = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.stakers != null && Object.hasOwnProperty.call(e3, "stakers") && $root.proto.AllProxyStakers.encode(e3.stakers, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.CryptoGetStakersResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 3:
                i.stakers = $root.proto.AllProxyStakers.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FileGetContentsQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.fileID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FileGetContentsQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FileGetContentsResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.fileContents = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.fileContents != null && Object.hasOwnProperty.call(e3, "fileContents") && $root.proto.FileGetContentsResponse.FileContents.encode(e3.fileContents, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FileGetContentsResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.fileContents = $root.proto.FileGetContentsResponse.FileContents.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.FileContents = function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.fileID = null, e3.prototype.contents = $util.newBuffer([]), e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), e4.fileID != null && Object.hasOwnProperty.call(e4, "fileID") && $root.proto.FileID.encode(e4.fileID, o.uint32(10).fork()).ldelim(), e4.contents != null && Object.hasOwnProperty.call(e4, "contents") && o.uint32(18).bytes(e4.contents), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.proto.FileGetContentsResponse.FileContents(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.fileID = $root.proto.FileID.decode(e4, e4.uint32());
                  break;
                case 2:
                  i.contents = e4.bytes();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), e2;
      }(), FileGetInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.fileID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.fileID != null && Object.hasOwnProperty.call(e3, "fileID") && $root.proto.FileID.encode(e3.fileID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FileGetInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.fileID = $root.proto.FileID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FileGetInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.fileInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.fileInfo != null && Object.hasOwnProperty.call(e3, "fileInfo") && $root.proto.FileGetInfoResponse.FileInfo.encode(e3.fileInfo, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FileGetInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.fileInfo = $root.proto.FileGetInfoResponse.FileInfo.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2.FileInfo = function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.fileID = null, e3.prototype.size = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.prototype.expirationTime = null, e3.prototype.deleted = false, e3.prototype.keys = null, e3.prototype.memo = "", e3.prototype.ledgerId = $util.newBuffer([]), e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), e4.fileID != null && Object.hasOwnProperty.call(e4, "fileID") && $root.proto.FileID.encode(e4.fileID, o.uint32(10).fork()).ldelim(), e4.size != null && Object.hasOwnProperty.call(e4, "size") && o.uint32(16).int64(e4.size), e4.expirationTime != null && Object.hasOwnProperty.call(e4, "expirationTime") && $root.proto.Timestamp.encode(e4.expirationTime, o.uint32(26).fork()).ldelim(), e4.deleted != null && Object.hasOwnProperty.call(e4, "deleted") && o.uint32(32).bool(e4.deleted), e4.keys != null && Object.hasOwnProperty.call(e4, "keys") && $root.proto.KeyList.encode(e4.keys, o.uint32(42).fork()).ldelim(), e4.memo != null && Object.hasOwnProperty.call(e4, "memo") && o.uint32(50).string(e4.memo), e4.ledgerId != null && Object.hasOwnProperty.call(e4, "ledgerId") && o.uint32(58).bytes(e4.ledgerId), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.proto.FileGetInfoResponse.FileInfo(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.fileID = $root.proto.FileID.decode(e4, e4.uint32());
                  break;
                case 2:
                  i.size = e4.int64();
                  break;
                case 3:
                  i.expirationTime = $root.proto.Timestamp.decode(e4, e4.uint32());
                  break;
                case 4:
                  i.deleted = e4.bool();
                  break;
                case 5:
                  i.keys = $root.proto.KeyList.decode(e4, e4.uint32());
                  break;
                case 6:
                  i.memo = e4.string();
                  break;
                case 7:
                  i.ledgerId = e4.bytes();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), e2;
      }(), TransactionGetReceiptQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionID = null, e2.prototype.includeDuplicates = false, e2.prototype.includeChildReceipts = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.transactionID != null && Object.hasOwnProperty.call(e3, "transactionID") && $root.proto.TransactionID.encode(e3.transactionID, o.uint32(18).fork()).ldelim(), e3.includeDuplicates != null && Object.hasOwnProperty.call(e3, "includeDuplicates") && o.uint32(24).bool(e3.includeDuplicates), e3.includeChildReceipts != null && Object.hasOwnProperty.call(e3, "includeChildReceipts") && o.uint32(32).bool(e3.includeChildReceipts), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetReceiptQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.transactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              case 3:
                i.includeDuplicates = e3.bool();
                break;
              case 4:
                i.includeChildReceipts = e3.bool();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionGetReceiptResponse: function() {
        function e2(e3) {
          if (this.duplicateTransactionReceipts = [], this.childTransactionReceipts = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.receipt = null, e2.prototype.duplicateTransactionReceipts = $util.emptyArray, e2.prototype.childTransactionReceipts = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.receipt != null && Object.hasOwnProperty.call(e3, "receipt") && $root.proto.TransactionReceipt.encode(e3.receipt, o.uint32(18).fork()).ldelim(), e3.duplicateTransactionReceipts != null && e3.duplicateTransactionReceipts.length)
            for (var t = 0; t < e3.duplicateTransactionReceipts.length; ++t)
              $root.proto.TransactionReceipt.encode(e3.duplicateTransactionReceipts[t], o.uint32(34).fork()).ldelim();
          if (e3.childTransactionReceipts != null && e3.childTransactionReceipts.length)
            for (var t = 0; t < e3.childTransactionReceipts.length; ++t)
              $root.proto.TransactionReceipt.encode(e3.childTransactionReceipts[t], o.uint32(42).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetReceiptResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.receipt = $root.proto.TransactionReceipt.decode(e3, e3.uint32());
                break;
              case 4:
                i.duplicateTransactionReceipts && i.duplicateTransactionReceipts.length || (i.duplicateTransactionReceipts = []), i.duplicateTransactionReceipts.push($root.proto.TransactionReceipt.decode(e3, e3.uint32()));
                break;
              case 5:
                i.childTransactionReceipts && i.childTransactionReceipts.length || (i.childTransactionReceipts = []), i.childTransactionReceipts.push($root.proto.TransactionReceipt.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionGetRecordQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionID = null, e2.prototype.includeDuplicates = false, e2.prototype.includeChildRecords = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.transactionID != null && Object.hasOwnProperty.call(e3, "transactionID") && $root.proto.TransactionID.encode(e3.transactionID, o.uint32(18).fork()).ldelim(), e3.includeDuplicates != null && Object.hasOwnProperty.call(e3, "includeDuplicates") && o.uint32(24).bool(e3.includeDuplicates), e3.includeChildRecords != null && Object.hasOwnProperty.call(e3, "includeChildRecords") && o.uint32(32).bool(e3.includeChildRecords), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetRecordQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.transactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              case 3:
                i.includeDuplicates = e3.bool();
                break;
              case 4:
                i.includeChildRecords = e3.bool();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionGetRecordResponse: function() {
        function e2(e3) {
          if (this.duplicateTransactionRecords = [], this.childTransactionRecords = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionRecord = null, e2.prototype.duplicateTransactionRecords = $util.emptyArray, e2.prototype.childTransactionRecords = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.transactionRecord != null && Object.hasOwnProperty.call(e3, "transactionRecord") && $root.proto.TransactionRecord.encode(e3.transactionRecord, o.uint32(26).fork()).ldelim(), e3.duplicateTransactionRecords != null && e3.duplicateTransactionRecords.length)
            for (var t = 0; t < e3.duplicateTransactionRecords.length; ++t)
              $root.proto.TransactionRecord.encode(e3.duplicateTransactionRecords[t], o.uint32(34).fork()).ldelim();
          if (e3.childTransactionRecords != null && e3.childTransactionRecords.length)
            for (var t = 0; t < e3.childTransactionRecords.length; ++t)
              $root.proto.TransactionRecord.encode(e3.childTransactionRecords[t], o.uint32(42).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetRecordResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 3:
                i.transactionRecord = $root.proto.TransactionRecord.decode(e3, e3.uint32());
                break;
              case 4:
                i.duplicateTransactionRecords && i.duplicateTransactionRecords.length || (i.duplicateTransactionRecords = []), i.duplicateTransactionRecords.push($root.proto.TransactionRecord.decode(e3, e3.uint32()));
                break;
              case 5:
                i.childTransactionRecords && i.childTransactionRecords.length || (i.childTransactionRecords = []), i.childTransactionRecords.push($root.proto.TransactionRecord.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionGetFastRecordQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.transactionID != null && Object.hasOwnProperty.call(e3, "transactionID") && $root.proto.TransactionID.encode(e3.transactionID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetFastRecordQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.transactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionGetFastRecordResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionRecord = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.transactionRecord != null && Object.hasOwnProperty.call(e3, "transactionRecord") && $root.proto.TransactionRecord.encode(e3.transactionRecord, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransactionGetFastRecordResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.transactionRecord = $root.proto.TransactionRecord.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), NetworkGetVersionInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.NetworkGetVersionInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), NetworkGetVersionInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.hapiProtoVersion = null, e2.prototype.hederaServicesVersion = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.hapiProtoVersion != null && Object.hasOwnProperty.call(e3, "hapiProtoVersion") && $root.proto.SemanticVersion.encode(e3.hapiProtoVersion, o.uint32(18).fork()).ldelim(), e3.hederaServicesVersion != null && Object.hasOwnProperty.call(e3, "hederaServicesVersion") && $root.proto.SemanticVersion.encode(e3.hederaServicesVersion, o.uint32(26).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.NetworkGetVersionInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.hapiProtoVersion = $root.proto.SemanticVersion.decode(e3, e3.uint32());
                break;
              case 3:
                i.hederaServicesVersion = $root.proto.SemanticVersion.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), NetworkGetExecutionTimeQuery: function() {
        function e2(e3) {
          if (this.transactionIds = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.transactionIds = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.transactionIds != null && e3.transactionIds.length)
            for (var t = 0; t < e3.transactionIds.length; ++t)
              $root.proto.TransactionID.encode(e3.transactionIds[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.NetworkGetExecutionTimeQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.transactionIds && i.transactionIds.length || (i.transactionIds = []), i.transactionIds.push($root.proto.TransactionID.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), NetworkGetExecutionTimeResponse: function() {
        function e2(e3) {
          if (this.executionTimes = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.executionTimes = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.executionTimes != null && e3.executionTimes.length) {
            o.uint32(18).fork();
            for (var t = 0; t < e3.executionTimes.length; ++t)
              o.uint64(e3.executionTimes[t]);
            o.ldelim();
          }
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.NetworkGetExecutionTimeResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                if (i.executionTimes && i.executionTimes.length || (i.executionTimes = []), (7 & d) == 2)
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.executionTimes.push(e3.uint64());
                else
                  i.executionTimes.push(e3.uint64());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenGetInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.token = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.token != null && Object.hasOwnProperty.call(e3, "token") && $root.proto.TokenID.encode(e3.token, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenGetInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.token = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenInfo: function() {
        function e2(e3) {
          if (this.customFees = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenId = null, e2.prototype.name = "", e2.prototype.symbol = "", e2.prototype.decimals = 0, e2.prototype.totalSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.treasury = null, e2.prototype.adminKey = null, e2.prototype.kycKey = null, e2.prototype.freezeKey = null, e2.prototype.wipeKey = null, e2.prototype.supplyKey = null, e2.prototype.defaultFreezeStatus = 0, e2.prototype.defaultKycStatus = 0, e2.prototype.deleted = false, e2.prototype.autoRenewAccount = null, e2.prototype.autoRenewPeriod = null, e2.prototype.expiry = null, e2.prototype.memo = "", e2.prototype.tokenType = 0, e2.prototype.supplyType = 0, e2.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.feeScheduleKey = null, e2.prototype.customFees = $util.emptyArray, e2.prototype.pauseKey = null, e2.prototype.pauseStatus = 0, e2.prototype.ledgerId = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.tokenId != null && Object.hasOwnProperty.call(e3, "tokenId") && $root.proto.TokenID.encode(e3.tokenId, o.uint32(10).fork()).ldelim(), e3.name != null && Object.hasOwnProperty.call(e3, "name") && o.uint32(18).string(e3.name), e3.symbol != null && Object.hasOwnProperty.call(e3, "symbol") && o.uint32(26).string(e3.symbol), e3.decimals != null && Object.hasOwnProperty.call(e3, "decimals") && o.uint32(32).uint32(e3.decimals), e3.totalSupply != null && Object.hasOwnProperty.call(e3, "totalSupply") && o.uint32(40).uint64(e3.totalSupply), e3.treasury != null && Object.hasOwnProperty.call(e3, "treasury") && $root.proto.AccountID.encode(e3.treasury, o.uint32(50).fork()).ldelim(), e3.adminKey != null && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o.uint32(58).fork()).ldelim(), e3.kycKey != null && Object.hasOwnProperty.call(e3, "kycKey") && $root.proto.Key.encode(e3.kycKey, o.uint32(66).fork()).ldelim(), e3.freezeKey != null && Object.hasOwnProperty.call(e3, "freezeKey") && $root.proto.Key.encode(e3.freezeKey, o.uint32(74).fork()).ldelim(), e3.wipeKey != null && Object.hasOwnProperty.call(e3, "wipeKey") && $root.proto.Key.encode(e3.wipeKey, o.uint32(82).fork()).ldelim(), e3.supplyKey != null && Object.hasOwnProperty.call(e3, "supplyKey") && $root.proto.Key.encode(e3.supplyKey, o.uint32(90).fork()).ldelim(), e3.defaultFreezeStatus != null && Object.hasOwnProperty.call(e3, "defaultFreezeStatus") && o.uint32(96).int32(e3.defaultFreezeStatus), e3.defaultKycStatus != null && Object.hasOwnProperty.call(e3, "defaultKycStatus") && o.uint32(104).int32(e3.defaultKycStatus), e3.deleted != null && Object.hasOwnProperty.call(e3, "deleted") && o.uint32(112).bool(e3.deleted), e3.autoRenewAccount != null && Object.hasOwnProperty.call(e3, "autoRenewAccount") && $root.proto.AccountID.encode(e3.autoRenewAccount, o.uint32(122).fork()).ldelim(), e3.autoRenewPeriod != null && Object.hasOwnProperty.call(e3, "autoRenewPeriod") && $root.proto.Duration.encode(e3.autoRenewPeriod, o.uint32(130).fork()).ldelim(), e3.expiry != null && Object.hasOwnProperty.call(e3, "expiry") && $root.proto.Timestamp.encode(e3.expiry, o.uint32(138).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o.uint32(146).string(e3.memo), e3.tokenType != null && Object.hasOwnProperty.call(e3, "tokenType") && o.uint32(152).int32(e3.tokenType), e3.supplyType != null && Object.hasOwnProperty.call(e3, "supplyType") && o.uint32(160).int32(e3.supplyType), e3.maxSupply != null && Object.hasOwnProperty.call(e3, "maxSupply") && o.uint32(168).int64(e3.maxSupply), e3.feeScheduleKey != null && Object.hasOwnProperty.call(e3, "feeScheduleKey") && $root.proto.Key.encode(e3.feeScheduleKey, o.uint32(178).fork()).ldelim(), e3.customFees != null && e3.customFees.length)
            for (var t = 0; t < e3.customFees.length; ++t)
              $root.proto.CustomFee.encode(e3.customFees[t], o.uint32(186).fork()).ldelim();
          return e3.pauseKey != null && Object.hasOwnProperty.call(e3, "pauseKey") && $root.proto.Key.encode(e3.pauseKey, o.uint32(194).fork()).ldelim(), e3.pauseStatus != null && Object.hasOwnProperty.call(e3, "pauseStatus") && o.uint32(200).int32(e3.pauseStatus), e3.ledgerId != null && Object.hasOwnProperty.call(e3, "ledgerId") && o.uint32(210).bytes(e3.ledgerId), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.tokenId = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.name = e3.string();
                break;
              case 3:
                i.symbol = e3.string();
                break;
              case 4:
                i.decimals = e3.uint32();
                break;
              case 5:
                i.totalSupply = e3.uint64();
                break;
              case 6:
                i.treasury = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 7:
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 8:
                i.kycKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 9:
                i.freezeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 10:
                i.wipeKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 11:
                i.supplyKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 12:
                i.defaultFreezeStatus = e3.int32();
                break;
              case 13:
                i.defaultKycStatus = e3.int32();
                break;
              case 14:
                i.deleted = e3.bool();
                break;
              case 15:
                i.autoRenewAccount = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 16:
                i.autoRenewPeriod = $root.proto.Duration.decode(e3, e3.uint32());
                break;
              case 17:
                i.expiry = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 18:
                i.memo = e3.string();
                break;
              case 19:
                i.tokenType = e3.int32();
                break;
              case 20:
                i.supplyType = e3.int32();
                break;
              case 21:
                i.maxSupply = e3.int64();
                break;
              case 22:
                i.feeScheduleKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 23:
                i.customFees && i.customFees.length || (i.customFees = []), i.customFees.push($root.proto.CustomFee.decode(e3, e3.uint32()));
                break;
              case 24:
                i.pauseKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 25:
                i.pauseStatus = e3.int32();
                break;
              case 26:
                i.ledgerId = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenGetInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.tokenInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.tokenInfo != null && Object.hasOwnProperty.call(e3, "tokenInfo") && $root.proto.TokenInfo.encode(e3.tokenInfo, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenGetInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.tokenInfo = $root.proto.TokenInfo.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ScheduleGetInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.scheduleID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.scheduleID != null && Object.hasOwnProperty.call(e3, "scheduleID") && $root.proto.ScheduleID.encode(e3.scheduleID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ScheduleGetInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.scheduleID = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ScheduleInfo: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.scheduleID = null, e2.prototype.deletionTime = null, e2.prototype.executionTime = null, e2.prototype.expirationTime = null, e2.prototype.scheduledTransactionBody = null, e2.prototype.memo = "", e2.prototype.adminKey = null, e2.prototype.signers = null, e2.prototype.creatorAccountID = null, e2.prototype.payerAccountID = null, e2.prototype.scheduledTransactionID = null, e2.prototype.ledgerId = $util.newBuffer([]);
        let o;
        return Object.defineProperty(e2.prototype, "data", { get: $util.oneOfGetter(o = ["deletionTime", "executionTime"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.scheduleID != null && Object.hasOwnProperty.call(e3, "scheduleID") && $root.proto.ScheduleID.encode(e3.scheduleID, o2.uint32(10).fork()).ldelim(), e3.deletionTime != null && Object.hasOwnProperty.call(e3, "deletionTime") && $root.proto.Timestamp.encode(e3.deletionTime, o2.uint32(18).fork()).ldelim(), e3.executionTime != null && Object.hasOwnProperty.call(e3, "executionTime") && $root.proto.Timestamp.encode(e3.executionTime, o2.uint32(26).fork()).ldelim(), e3.expirationTime != null && Object.hasOwnProperty.call(e3, "expirationTime") && $root.proto.Timestamp.encode(e3.expirationTime, o2.uint32(34).fork()).ldelim(), e3.scheduledTransactionBody != null && Object.hasOwnProperty.call(e3, "scheduledTransactionBody") && $root.proto.SchedulableTransactionBody.encode(e3.scheduledTransactionBody, o2.uint32(42).fork()).ldelim(), e3.memo != null && Object.hasOwnProperty.call(e3, "memo") && o2.uint32(50).string(e3.memo), e3.adminKey != null && Object.hasOwnProperty.call(e3, "adminKey") && $root.proto.Key.encode(e3.adminKey, o2.uint32(58).fork()).ldelim(), e3.signers != null && Object.hasOwnProperty.call(e3, "signers") && $root.proto.KeyList.encode(e3.signers, o2.uint32(66).fork()).ldelim(), e3.creatorAccountID != null && Object.hasOwnProperty.call(e3, "creatorAccountID") && $root.proto.AccountID.encode(e3.creatorAccountID, o2.uint32(74).fork()).ldelim(), e3.payerAccountID != null && Object.hasOwnProperty.call(e3, "payerAccountID") && $root.proto.AccountID.encode(e3.payerAccountID, o2.uint32(82).fork()).ldelim(), e3.scheduledTransactionID != null && Object.hasOwnProperty.call(e3, "scheduledTransactionID") && $root.proto.TransactionID.encode(e3.scheduledTransactionID, o2.uint32(90).fork()).ldelim(), e3.ledgerId != null && Object.hasOwnProperty.call(e3, "ledgerId") && o2.uint32(98).bytes(e3.ledgerId), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.ScheduleInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.scheduleID = $root.proto.ScheduleID.decode(e3, e3.uint32());
                break;
              case 2:
                i.deletionTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 3:
                i.executionTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 4:
                i.expirationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 5:
                i.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(e3, e3.uint32());
                break;
              case 6:
                i.memo = e3.string();
                break;
              case 7:
                i.adminKey = $root.proto.Key.decode(e3, e3.uint32());
                break;
              case 8:
                i.signers = $root.proto.KeyList.decode(e3, e3.uint32());
                break;
              case 9:
                i.creatorAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 10:
                i.payerAccountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 11:
                i.scheduledTransactionID = $root.proto.TransactionID.decode(e3, e3.uint32());
                break;
              case 12:
                i.ledgerId = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ScheduleGetInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.scheduleInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.scheduleInfo != null && Object.hasOwnProperty.call(e3, "scheduleInfo") && $root.proto.ScheduleInfo.encode(e3.scheduleInfo, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ScheduleGetInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.scheduleInfo = $root.proto.ScheduleInfo.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenGetAccountNftInfosQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.accountID = null, e2.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), e3.start != null && Object.hasOwnProperty.call(e3, "start") && o.uint32(24).int64(e3.start), e3.end != null && Object.hasOwnProperty.call(e3, "end") && o.uint32(32).int64(e3.end), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenGetAccountNftInfosQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.start = e3.int64();
                break;
              case 4:
                i.end = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenGetAccountNftInfosResponse: function() {
        function e2(e3) {
          if (this.nfts = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.nfts = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.nfts != null && e3.nfts.length)
            for (var t = 0; t < e3.nfts.length; ++t)
              $root.proto.TokenNftInfo.encode(e3.nfts[t], o.uint32(18).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenGetAccountNftInfosResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.nfts && i.nfts.length || (i.nfts = []), i.nfts.push($root.proto.TokenNftInfo.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), NftID: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.tokenID = null, e2.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.tokenID != null && Object.hasOwnProperty.call(e3, "tokenID") && $root.proto.TokenID.encode(e3.tokenID, o.uint32(10).fork()).ldelim(), e3.serialNumber != null && Object.hasOwnProperty.call(e3, "serialNumber") && o.uint32(16).int64(e3.serialNumber), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.NftID(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.tokenID = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 2:
                i.serialNumber = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenGetNftInfoQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.nftID = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.nftID != null && Object.hasOwnProperty.call(e3, "nftID") && $root.proto.NftID.encode(e3.nftID, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenGetNftInfoQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.nftID = $root.proto.NftID.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenNftInfo: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.nftID = null, e2.prototype.accountID = null, e2.prototype.creationTime = null, e2.prototype.metadata = $util.newBuffer([]), e2.prototype.ledgerId = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.nftID != null && Object.hasOwnProperty.call(e3, "nftID") && $root.proto.NftID.encode(e3.nftID, o.uint32(10).fork()).ldelim(), e3.accountID != null && Object.hasOwnProperty.call(e3, "accountID") && $root.proto.AccountID.encode(e3.accountID, o.uint32(18).fork()).ldelim(), e3.creationTime != null && Object.hasOwnProperty.call(e3, "creationTime") && $root.proto.Timestamp.encode(e3.creationTime, o.uint32(26).fork()).ldelim(), e3.metadata != null && Object.hasOwnProperty.call(e3, "metadata") && o.uint32(34).bytes(e3.metadata), e3.ledgerId != null && Object.hasOwnProperty.call(e3, "ledgerId") && o.uint32(42).bytes(e3.ledgerId), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenNftInfo(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.nftID = $root.proto.NftID.decode(e3, e3.uint32());
                break;
              case 2:
                i.accountID = $root.proto.AccountID.decode(e3, e3.uint32());
                break;
              case 3:
                i.creationTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 4:
                i.metadata = e3.bytes();
                break;
              case 5:
                i.ledgerId = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenGetNftInfoResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.nft = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.nft != null && Object.hasOwnProperty.call(e3, "nft") && $root.proto.TokenNftInfo.encode(e3.nft, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenGetNftInfoResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.nft = $root.proto.TokenNftInfo.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenGetNftInfosQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.tokenID = null, e2.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.QueryHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.tokenID != null && Object.hasOwnProperty.call(e3, "tokenID") && $root.proto.TokenID.encode(e3.tokenID, o.uint32(18).fork()).ldelim(), e3.start != null && Object.hasOwnProperty.call(e3, "start") && o.uint32(24).int64(e3.start), e3.end != null && Object.hasOwnProperty.call(e3, "end") && o.uint32(32).int64(e3.end), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenGetNftInfosQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.QueryHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.tokenID = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 3:
                i.start = e3.int64();
                break;
              case 4:
                i.end = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenGetNftInfosResponse: function() {
        function e2(e3) {
          if (this.nfts = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.header = null, e2.prototype.tokenID = null, e2.prototype.nfts = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.header != null && Object.hasOwnProperty.call(e3, "header") && $root.proto.ResponseHeader.encode(e3.header, o.uint32(10).fork()).ldelim(), e3.tokenID != null && Object.hasOwnProperty.call(e3, "tokenID") && $root.proto.TokenID.encode(e3.tokenID, o.uint32(18).fork()).ldelim(), e3.nfts != null && e3.nfts.length)
            for (var t = 0; t < e3.nfts.length; ++t)
              $root.proto.TokenNftInfo.encode(e3.nfts[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TokenGetNftInfosResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.header = $root.proto.ResponseHeader.decode(e3, e3.uint32());
                break;
              case 2:
                i.tokenID = $root.proto.TokenID.decode(e3, e3.uint32());
                break;
              case 3:
                i.nfts && i.nfts.length || (i.nfts = []), i.nfts.push($root.proto.TokenNftInfo.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), Response: function() {
        function e2(e3) {
          if (e3)
            for (var o2 = Object.keys(e3), t = 0; t < o2.length; ++t)
              e3[o2[t]] != null && (this[o2[t]] = e3[o2[t]]);
        }
        e2.prototype.getByKey = null, e2.prototype.getBySolidityID = null, e2.prototype.contractCallLocal = null, e2.prototype.contractGetBytecodeResponse = null, e2.prototype.contractGetInfo = null, e2.prototype.contractGetRecordsResponse = null, e2.prototype.cryptogetAccountBalance = null, e2.prototype.cryptoGetAccountRecords = null, e2.prototype.cryptoGetInfo = null, e2.prototype.cryptoGetLiveHash = null, e2.prototype.cryptoGetProxyStakers = null, e2.prototype.fileGetContents = null, e2.prototype.fileGetInfo = null, e2.prototype.transactionGetReceipt = null, e2.prototype.transactionGetRecord = null, e2.prototype.transactionGetFastRecord = null, e2.prototype.consensusGetTopicInfo = null, e2.prototype.networkGetVersionInfo = null, e2.prototype.tokenGetInfo = null, e2.prototype.scheduleGetInfo = null, e2.prototype.tokenGetAccountNftInfos = null, e2.prototype.tokenGetNftInfo = null, e2.prototype.tokenGetNftInfos = null, e2.prototype.networkGetExecutionTime = null;
        let o;
        return Object.defineProperty(e2.prototype, "response", { get: $util.oneOfGetter(o = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetBytecodeResponse", "contractGetInfo", "contractGetRecordsResponse", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo", "tokenGetInfo", "scheduleGetInfo", "tokenGetAccountNftInfos", "tokenGetNftInfo", "tokenGetNftInfos", "networkGetExecutionTime"]), set: $util.oneOfSetter(o) }), e2.create = function(o2) {
          return new e2(o2);
        }, e2.encode = function(e3, o2) {
          return o2 || (o2 = $Writer.create()), e3.getByKey != null && Object.hasOwnProperty.call(e3, "getByKey") && $root.proto.GetByKeyResponse.encode(e3.getByKey, o2.uint32(10).fork()).ldelim(), e3.getBySolidityID != null && Object.hasOwnProperty.call(e3, "getBySolidityID") && $root.proto.GetBySolidityIDResponse.encode(e3.getBySolidityID, o2.uint32(18).fork()).ldelim(), e3.contractCallLocal != null && Object.hasOwnProperty.call(e3, "contractCallLocal") && $root.proto.ContractCallLocalResponse.encode(e3.contractCallLocal, o2.uint32(26).fork()).ldelim(), e3.contractGetInfo != null && Object.hasOwnProperty.call(e3, "contractGetInfo") && $root.proto.ContractGetInfoResponse.encode(e3.contractGetInfo, o2.uint32(34).fork()).ldelim(), e3.contractGetBytecodeResponse != null && Object.hasOwnProperty.call(e3, "contractGetBytecodeResponse") && $root.proto.ContractGetBytecodeResponse.encode(e3.contractGetBytecodeResponse, o2.uint32(42).fork()).ldelim(), e3.contractGetRecordsResponse != null && Object.hasOwnProperty.call(e3, "contractGetRecordsResponse") && $root.proto.ContractGetRecordsResponse.encode(e3.contractGetRecordsResponse, o2.uint32(50).fork()).ldelim(), e3.cryptogetAccountBalance != null && Object.hasOwnProperty.call(e3, "cryptogetAccountBalance") && $root.proto.CryptoGetAccountBalanceResponse.encode(e3.cryptogetAccountBalance, o2.uint32(58).fork()).ldelim(), e3.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(e3, "cryptoGetAccountRecords") && $root.proto.CryptoGetAccountRecordsResponse.encode(e3.cryptoGetAccountRecords, o2.uint32(66).fork()).ldelim(), e3.cryptoGetInfo != null && Object.hasOwnProperty.call(e3, "cryptoGetInfo") && $root.proto.CryptoGetInfoResponse.encode(e3.cryptoGetInfo, o2.uint32(74).fork()).ldelim(), e3.cryptoGetLiveHash != null && Object.hasOwnProperty.call(e3, "cryptoGetLiveHash") && $root.proto.CryptoGetLiveHashResponse.encode(e3.cryptoGetLiveHash, o2.uint32(82).fork()).ldelim(), e3.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(e3, "cryptoGetProxyStakers") && $root.proto.CryptoGetStakersResponse.encode(e3.cryptoGetProxyStakers, o2.uint32(90).fork()).ldelim(), e3.fileGetContents != null && Object.hasOwnProperty.call(e3, "fileGetContents") && $root.proto.FileGetContentsResponse.encode(e3.fileGetContents, o2.uint32(98).fork()).ldelim(), e3.fileGetInfo != null && Object.hasOwnProperty.call(e3, "fileGetInfo") && $root.proto.FileGetInfoResponse.encode(e3.fileGetInfo, o2.uint32(106).fork()).ldelim(), e3.transactionGetReceipt != null && Object.hasOwnProperty.call(e3, "transactionGetReceipt") && $root.proto.TransactionGetReceiptResponse.encode(e3.transactionGetReceipt, o2.uint32(114).fork()).ldelim(), e3.transactionGetRecord != null && Object.hasOwnProperty.call(e3, "transactionGetRecord") && $root.proto.TransactionGetRecordResponse.encode(e3.transactionGetRecord, o2.uint32(122).fork()).ldelim(), e3.transactionGetFastRecord != null && Object.hasOwnProperty.call(e3, "transactionGetFastRecord") && $root.proto.TransactionGetFastRecordResponse.encode(e3.transactionGetFastRecord, o2.uint32(130).fork()).ldelim(), e3.consensusGetTopicInfo != null && Object.hasOwnProperty.call(e3, "consensusGetTopicInfo") && $root.proto.ConsensusGetTopicInfoResponse.encode(e3.consensusGetTopicInfo, o2.uint32(1202).fork()).ldelim(), e3.networkGetVersionInfo != null && Object.hasOwnProperty.call(e3, "networkGetVersionInfo") && $root.proto.NetworkGetVersionInfoResponse.encode(e3.networkGetVersionInfo, o2.uint32(1210).fork()).ldelim(), e3.tokenGetInfo != null && Object.hasOwnProperty.call(e3, "tokenGetInfo") && $root.proto.TokenGetInfoResponse.encode(e3.tokenGetInfo, o2.uint32(1218).fork()).ldelim(), e3.scheduleGetInfo != null && Object.hasOwnProperty.call(e3, "scheduleGetInfo") && $root.proto.ScheduleGetInfoResponse.encode(e3.scheduleGetInfo, o2.uint32(1226).fork()).ldelim(), e3.tokenGetAccountNftInfos != null && Object.hasOwnProperty.call(e3, "tokenGetAccountNftInfos") && $root.proto.TokenGetAccountNftInfosResponse.encode(e3.tokenGetAccountNftInfos, o2.uint32(1234).fork()).ldelim(), e3.tokenGetNftInfo != null && Object.hasOwnProperty.call(e3, "tokenGetNftInfo") && $root.proto.TokenGetNftInfoResponse.encode(e3.tokenGetNftInfo, o2.uint32(1242).fork()).ldelim(), e3.tokenGetNftInfos != null && Object.hasOwnProperty.call(e3, "tokenGetNftInfos") && $root.proto.TokenGetNftInfosResponse.encode(e3.tokenGetNftInfos, o2.uint32(1250).fork()).ldelim(), e3.networkGetExecutionTime != null && Object.hasOwnProperty.call(e3, "networkGetExecutionTime") && $root.proto.NetworkGetExecutionTimeResponse.encode(e3.networkGetExecutionTime, o2.uint32(1258).fork()).ldelim(), o2;
        }, e2.decode = function(e3, o2) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o2 === void 0 ? e3.len : e3.pos + o2, i = new $root.proto.Response(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.getByKey = $root.proto.GetByKeyResponse.decode(e3, e3.uint32());
                break;
              case 2:
                i.getBySolidityID = $root.proto.GetBySolidityIDResponse.decode(e3, e3.uint32());
                break;
              case 3:
                i.contractCallLocal = $root.proto.ContractCallLocalResponse.decode(e3, e3.uint32());
                break;
              case 5:
                i.contractGetBytecodeResponse = $root.proto.ContractGetBytecodeResponse.decode(e3, e3.uint32());
                break;
              case 4:
                i.contractGetInfo = $root.proto.ContractGetInfoResponse.decode(e3, e3.uint32());
                break;
              case 6:
                i.contractGetRecordsResponse = $root.proto.ContractGetRecordsResponse.decode(e3, e3.uint32());
                break;
              case 7:
                i.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceResponse.decode(e3, e3.uint32());
                break;
              case 8:
                i.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsResponse.decode(e3, e3.uint32());
                break;
              case 9:
                i.cryptoGetInfo = $root.proto.CryptoGetInfoResponse.decode(e3, e3.uint32());
                break;
              case 10:
                i.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashResponse.decode(e3, e3.uint32());
                break;
              case 11:
                i.cryptoGetProxyStakers = $root.proto.CryptoGetStakersResponse.decode(e3, e3.uint32());
                break;
              case 12:
                i.fileGetContents = $root.proto.FileGetContentsResponse.decode(e3, e3.uint32());
                break;
              case 13:
                i.fileGetInfo = $root.proto.FileGetInfoResponse.decode(e3, e3.uint32());
                break;
              case 14:
                i.transactionGetReceipt = $root.proto.TransactionGetReceiptResponse.decode(e3, e3.uint32());
                break;
              case 15:
                i.transactionGetRecord = $root.proto.TransactionGetRecordResponse.decode(e3, e3.uint32());
                break;
              case 16:
                i.transactionGetFastRecord = $root.proto.TransactionGetFastRecordResponse.decode(e3, e3.uint32());
                break;
              case 150:
                i.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoResponse.decode(e3, e3.uint32());
                break;
              case 151:
                i.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoResponse.decode(e3, e3.uint32());
                break;
              case 152:
                i.tokenGetInfo = $root.proto.TokenGetInfoResponse.decode(e3, e3.uint32());
                break;
              case 153:
                i.scheduleGetInfo = $root.proto.ScheduleGetInfoResponse.decode(e3, e3.uint32());
                break;
              case 154:
                i.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosResponse.decode(e3, e3.uint32());
                break;
              case 155:
                i.tokenGetNftInfo = $root.proto.TokenGetNftInfoResponse.decode(e3, e3.uint32());
                break;
              case 156:
                i.tokenGetNftInfos = $root.proto.TokenGetNftInfosResponse.decode(e3, e3.uint32());
                break;
              case 157:
                i.networkGetExecutionTime = $root.proto.NetworkGetExecutionTimeResponse.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), CryptoService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createAccount = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "createAccount" }), Object.defineProperty(e2.prototype.updateAccount = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "updateAccount" }), Object.defineProperty(e2.prototype.cryptoTransfer = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "cryptoTransfer" }), Object.defineProperty(e2.prototype.cryptoDelete = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "cryptoDelete" }), Object.defineProperty(e2.prototype.addLiveHash = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "addLiveHash" }), Object.defineProperty(e2.prototype.deleteLiveHash = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "deleteLiveHash" }), Object.defineProperty(e2.prototype.getLiveHash = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getLiveHash" }), Object.defineProperty(e2.prototype.getAccountRecords = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getAccountRecords" }), Object.defineProperty(e2.prototype.cryptoGetBalance = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "cryptoGetBalance" }), Object.defineProperty(e2.prototype.getAccountInfo = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getAccountInfo" }), Object.defineProperty(e2.prototype.getTransactionReceipts = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getTransactionReceipts" }), Object.defineProperty(e2.prototype.getFastTransactionRecord = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getFastTransactionRecord" }), Object.defineProperty(e2.prototype.getTxRecordByTxID = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getTxRecordByTxID" }), Object.defineProperty(e2.prototype.getStakersByAccountID = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getStakersByAccountID" }), e2;
      }(), FileService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createFile = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "createFile" }), Object.defineProperty(e2.prototype.updateFile = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "updateFile" }), Object.defineProperty(e2.prototype.deleteFile = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "deleteFile" }), Object.defineProperty(e2.prototype.appendContent = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "appendContent" }), Object.defineProperty(e2.prototype.getFileContent = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getFileContent" }), Object.defineProperty(e2.prototype.getFileInfo = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getFileInfo" }), Object.defineProperty(e2.prototype.systemDelete = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "systemDelete" }), Object.defineProperty(e2.prototype.systemUndelete = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "systemUndelete" }), e2;
      }(), FreezeService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.freeze = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "freeze" }), e2;
      }(), ConsensusTopicQuery: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.topicID = null, e2.prototype.consensusStartTime = null, e2.prototype.consensusEndTime = null, e2.prototype.limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.topicID != null && Object.hasOwnProperty.call(e3, "topicID") && $root.proto.TopicID.encode(e3.topicID, o.uint32(10).fork()).ldelim(), e3.consensusStartTime != null && Object.hasOwnProperty.call(e3, "consensusStartTime") && $root.proto.Timestamp.encode(e3.consensusStartTime, o.uint32(18).fork()).ldelim(), e3.consensusEndTime != null && Object.hasOwnProperty.call(e3, "consensusEndTime") && $root.proto.Timestamp.encode(e3.consensusEndTime, o.uint32(26).fork()).ldelim(), e3.limit != null && Object.hasOwnProperty.call(e3, "limit") && o.uint32(32).uint64(e3.limit), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ConsensusTopicQuery(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.topicID = $root.proto.TopicID.decode(e3, e3.uint32());
                break;
              case 2:
                i.consensusStartTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 3:
                i.consensusEndTime = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 4:
                i.limit = e3.uint64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ConsensusTopicResponse: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.consensusTimestamp = null, e2.prototype.message = $util.newBuffer([]), e2.prototype.runningHash = $util.newBuffer([]), e2.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.runningHashVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.chunkInfo = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.consensusTimestamp != null && Object.hasOwnProperty.call(e3, "consensusTimestamp") && $root.proto.Timestamp.encode(e3.consensusTimestamp, o.uint32(10).fork()).ldelim(), e3.message != null && Object.hasOwnProperty.call(e3, "message") && o.uint32(18).bytes(e3.message), e3.runningHash != null && Object.hasOwnProperty.call(e3, "runningHash") && o.uint32(26).bytes(e3.runningHash), e3.sequenceNumber != null && Object.hasOwnProperty.call(e3, "sequenceNumber") && o.uint32(32).uint64(e3.sequenceNumber), e3.runningHashVersion != null && Object.hasOwnProperty.call(e3, "runningHashVersion") && o.uint32(40).uint64(e3.runningHashVersion), e3.chunkInfo != null && Object.hasOwnProperty.call(e3, "chunkInfo") && $root.proto.ConsensusMessageChunkInfo.encode(e3.chunkInfo, o.uint32(50).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ConsensusTopicResponse(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.consensusTimestamp = $root.proto.Timestamp.decode(e3, e3.uint32());
                break;
              case 2:
                i.message = e3.bytes();
                break;
              case 3:
                i.runningHash = e3.bytes();
                break;
              case 4:
                i.sequenceNumber = e3.uint64();
                break;
              case 5:
                i.runningHashVersion = e3.uint64();
                break;
              case 6:
                i.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), MirrorConsensusService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.subscribeTopic = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.ConsensusTopicQuery, $root.proto.ConsensusTopicResponse, o, t);
        }, "name", { value: "subscribeTopic" }), e2;
      }(), NetworkService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.getVersionInfo = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getVersionInfo" }), Object.defineProperty(e2.prototype.getExecutionTime = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getExecutionTime" }), Object.defineProperty(e2.prototype.uncheckedSubmit = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "uncheckedSubmit" }), e2;
      }(), ScheduleService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createSchedule = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "createSchedule" }), Object.defineProperty(e2.prototype.signSchedule = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "signSchedule" }), Object.defineProperty(e2.prototype.deleteSchedule = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "deleteSchedule" }), Object.defineProperty(e2.prototype.getScheduleInfo = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getScheduleInfo" }), e2;
      }(), SmartContractService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createContract = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "createContract" }), Object.defineProperty(e2.prototype.updateContract = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "updateContract" }), Object.defineProperty(e2.prototype.contractCallMethod = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "contractCallMethod" }), Object.defineProperty(e2.prototype.getContractInfo = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getContractInfo" }), Object.defineProperty(e2.prototype.contractCallLocalMethod = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "contractCallLocalMethod" }), Object.defineProperty(e2.prototype.contractGetBytecode = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "ContractGetBytecode" }), Object.defineProperty(e2.prototype.getBySolidityID = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getBySolidityID" }), Object.defineProperty(e2.prototype.getTxRecordByContractID = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getTxRecordByContractID" }), Object.defineProperty(e2.prototype.deleteContract = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "deleteContract" }), Object.defineProperty(e2.prototype.systemDelete = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "systemDelete" }), Object.defineProperty(e2.prototype.systemUndelete = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "systemUndelete" }), e2;
      }(), ThrottleGroup: function() {
        function e2(e3) {
          if (this.operations = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.operations = $util.emptyArray, e2.prototype.milliOpsPerSec = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.operations != null && e3.operations.length) {
            o.uint32(10).fork();
            for (var t = 0; t < e3.operations.length; ++t)
              o.int32(e3.operations[t]);
            o.ldelim();
          }
          return e3.milliOpsPerSec != null && Object.hasOwnProperty.call(e3, "milliOpsPerSec") && o.uint32(16).uint64(e3.milliOpsPerSec), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ThrottleGroup(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                if (i.operations && i.operations.length || (i.operations = []), (7 & d) == 2)
                  for (var a = e3.uint32() + e3.pos; e3.pos < a; )
                    i.operations.push(e3.int32());
                else
                  i.operations.push(e3.int32());
                break;
              case 2:
                i.milliOpsPerSec = e3.uint64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ThrottleBucket: function() {
        function e2(e3) {
          if (this.throttleGroups = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.name = "", e2.prototype.burstPeriodMs = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.prototype.throttleGroups = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.name != null && Object.hasOwnProperty.call(e3, "name") && o.uint32(10).string(e3.name), e3.burstPeriodMs != null && Object.hasOwnProperty.call(e3, "burstPeriodMs") && o.uint32(16).uint64(e3.burstPeriodMs), e3.throttleGroups != null && e3.throttleGroups.length)
            for (var t = 0; t < e3.throttleGroups.length; ++t)
              $root.proto.ThrottleGroup.encode(e3.throttleGroups[t], o.uint32(26).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ThrottleBucket(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.name = e3.string();
                break;
              case 2:
                i.burstPeriodMs = e3.uint64();
                break;
              case 3:
                i.throttleGroups && i.throttleGroups.length || (i.throttleGroups = []), i.throttleGroups.push($root.proto.ThrottleGroup.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), ThrottleDefinitions: function() {
        function e2(e3) {
          if (this.throttleBuckets = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.throttleBuckets = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.throttleBuckets != null && e3.throttleBuckets.length)
            for (var t = 0; t < e3.throttleBuckets.length; ++t)
              $root.proto.ThrottleBucket.encode(e3.throttleBuckets[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.ThrottleDefinitions(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.throttleBuckets && i.throttleBuckets.length || (i.throttleBuckets = []), i.throttleBuckets.push($root.proto.ThrottleBucket.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TokenService: function() {
        function e2(e3, o, t) {
          $protobuf.rpc.Service.call(this, e3, o, t);
        }
        return (e2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = e2, e2.create = function(e3, o, t) {
          return new this(e3, o, t);
        }, Object.defineProperty(e2.prototype.createToken = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "createToken" }), Object.defineProperty(e2.prototype.updateToken = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "updateToken" }), Object.defineProperty(e2.prototype.mintToken = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "mintToken" }), Object.defineProperty(e2.prototype.burnToken = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "burnToken" }), Object.defineProperty(e2.prototype.deleteToken = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "deleteToken" }), Object.defineProperty(e2.prototype.wipeTokenAccount = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "wipeTokenAccount" }), Object.defineProperty(e2.prototype.freezeTokenAccount = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "freezeTokenAccount" }), Object.defineProperty(e2.prototype.unfreezeTokenAccount = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "unfreezeTokenAccount" }), Object.defineProperty(e2.prototype.grantKycToTokenAccount = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "grantKycToTokenAccount" }), Object.defineProperty(e2.prototype.revokeKycFromTokenAccount = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "revokeKycFromTokenAccount" }), Object.defineProperty(e2.prototype.associateTokens = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "associateTokens" }), Object.defineProperty(e2.prototype.dissociateTokens = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "dissociateTokens" }), Object.defineProperty(e2.prototype.updateTokenFeeSchedule = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "updateTokenFeeSchedule" }), Object.defineProperty(e2.prototype.getTokenInfo = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getTokenInfo" }), Object.defineProperty(e2.prototype.getAccountNftInfos = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getAccountNftInfos" }), Object.defineProperty(e2.prototype.getTokenNftInfo = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getTokenNftInfo" }), Object.defineProperty(e2.prototype.getTokenNftInfos = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Query, $root.proto.Response, o, t);
        }, "name", { value: "getTokenNftInfos" }), Object.defineProperty(e2.prototype.pauseToken = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "pauseToken" }), Object.defineProperty(e2.prototype.unpauseToken = function e3(o, t) {
          return this.rpcCall(e3, $root.proto.Transaction, $root.proto.TransactionResponse, o, t);
        }, "name", { value: "unpauseToken" }), e2;
      }(), SignedTransaction: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.bodyBytes = $util.newBuffer([]), e2.prototype.sigMap = null, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.bodyBytes != null && Object.hasOwnProperty.call(e3, "bodyBytes") && o.uint32(10).bytes(e3.bodyBytes), e3.sigMap != null && Object.hasOwnProperty.call(e3, "sigMap") && $root.proto.SignatureMap.encode(e3.sigMap, o.uint32(18).fork()).ldelim(), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.SignedTransaction(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.bodyBytes = e3.bytes();
                break;
              case 2:
                i.sigMap = $root.proto.SignatureMap.decode(e3, e3.uint32());
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), TransactionList: function() {
        function e2(e3) {
          if (this.transactionList = [], e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.transactionList = $util.emptyArray, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          if (o || (o = $Writer.create()), e3.transactionList != null && e3.transactionList.length)
            for (var t = 0; t < e3.transactionList.length; ++t)
              $root.proto.Transaction.encode(e3.transactionList[t], o.uint32(10).fork()).ldelim();
          return o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.TransactionList(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.transactionList && i.transactionList.length || (i.transactionList = []), i.transactionList.push($root.proto.Transaction.decode(e3, e3.uint32()));
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), DoubleValue: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.value = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.value != null && Object.hasOwnProperty.call(e3, "value") && o.uint32(9).double(e3.value), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.DoubleValue(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.value = e3.double();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), FloatValue: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.value = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.value != null && Object.hasOwnProperty.call(e3, "value") && o.uint32(13).float(e3.value), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.FloatValue(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.value = e3.float();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), Int64Value: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.value != null && Object.hasOwnProperty.call(e3, "value") && o.uint32(8).int64(e3.value), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.Int64Value(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.value = e3.int64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), UInt64Value: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.value != null && Object.hasOwnProperty.call(e3, "value") && o.uint32(8).uint64(e3.value), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.UInt64Value(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.value = e3.uint64();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), Int32Value: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.value = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.value != null && Object.hasOwnProperty.call(e3, "value") && o.uint32(8).int32(e3.value), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.Int32Value(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.value = e3.int32();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), UInt32Value: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.value = 0, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.value != null && Object.hasOwnProperty.call(e3, "value") && o.uint32(8).uint32(e3.value), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.UInt32Value(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.value = e3.uint32();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), BoolValue: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.value = false, e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.value != null && Object.hasOwnProperty.call(e3, "value") && o.uint32(8).bool(e3.value), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.BoolValue(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.value = e3.bool();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), StringValue: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.value = "", e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.value != null && Object.hasOwnProperty.call(e3, "value") && o.uint32(10).string(e3.value), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.StringValue(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.value = e3.string();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }(), BytesValue: function() {
        function e2(e3) {
          if (e3)
            for (var o = Object.keys(e3), t = 0; t < o.length; ++t)
              e3[o[t]] != null && (this[o[t]] = e3[o[t]]);
        }
        return e2.prototype.value = $util.newBuffer([]), e2.create = function(o) {
          return new e2(o);
        }, e2.encode = function(e3, o) {
          return o || (o = $Writer.create()), e3.value != null && Object.hasOwnProperty.call(e3, "value") && o.uint32(10).bytes(e3.value), o;
        }, e2.decode = function(e3, o) {
          e3 instanceof $Reader || (e3 = $Reader.create(e3));
          for (var n = o === void 0 ? e3.len : e3.pos + o, i = new $root.proto.BytesValue(), d; e3.pos < n; )
            switch (d = e3.uint32(), d >>> 3) {
              case 1:
                i.value = e3.bytes();
                break;
              default:
                e3.skipType(7 & d);
            }
          return i;
        }, e2;
      }() };
      return e;
    })();
    exports2.proto = proto19;
    var google = $root.google = (() => {
      const e = { protobuf: function() {
        const e2 = { DoubleValue: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), e4.value != null && Object.hasOwnProperty.call(e4, "value") && o.uint32(9).double(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.google.protobuf.DoubleValue(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.value = e4.double();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), FloatValue: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), e4.value != null && Object.hasOwnProperty.call(e4, "value") && o.uint32(13).float(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.google.protobuf.FloatValue(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.value = e4.float();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), Int64Value: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), e4.value != null && Object.hasOwnProperty.call(e4, "value") && o.uint32(8).int64(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.google.protobuf.Int64Value(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.value = e4.int64();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), UInt64Value: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, true) : 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), e4.value != null && Object.hasOwnProperty.call(e4, "value") && o.uint32(8).uint64(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.google.protobuf.UInt64Value(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.value = e4.uint64();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), Int32Value: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), e4.value != null && Object.hasOwnProperty.call(e4, "value") && o.uint32(8).int32(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.google.protobuf.Int32Value(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.value = e4.int32();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), UInt32Value: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = 0, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), e4.value != null && Object.hasOwnProperty.call(e4, "value") && o.uint32(8).uint32(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.google.protobuf.UInt32Value(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.value = e4.uint32();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), BoolValue: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = false, e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), e4.value != null && Object.hasOwnProperty.call(e4, "value") && o.uint32(8).bool(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.google.protobuf.BoolValue(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.value = e4.bool();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), StringValue: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = "", e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), e4.value != null && Object.hasOwnProperty.call(e4, "value") && o.uint32(10).string(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.google.protobuf.StringValue(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.value = e4.string();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }(), BytesValue: function() {
          function e3(e4) {
            if (e4)
              for (var o = Object.keys(e4), t = 0; t < o.length; ++t)
                e4[o[t]] != null && (this[o[t]] = e4[o[t]]);
          }
          return e3.prototype.value = $util.newBuffer([]), e3.create = function(o) {
            return new e3(o);
          }, e3.encode = function(e4, o) {
            return o || (o = $Writer.create()), e4.value != null && Object.hasOwnProperty.call(e4, "value") && o.uint32(10).bytes(e4.value), o;
          }, e3.decode = function(e4, o) {
            e4 instanceof $Reader || (e4 = $Reader.create(e4));
            for (var n = o === void 0 ? e4.len : e4.pos + o, i = new $root.google.protobuf.BytesValue(), d; e4.pos < n; )
              switch (d = e4.uint32(), d >>> 3) {
                case 1:
                  i.value = e4.bytes();
                  break;
                default:
                  e4.skipType(7 & d);
              }
            return i;
          }, e3;
        }() };
        return e2;
      }() };
      return e;
    })();
    exports2.google = google;
  }
});

// node_modules/@hashgraph/proto/lib/index.js
var require_lib = __commonJS({
  "node_modules/@hashgraph/proto/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true }), exports2.SchedulableTransactionBody = exports2.ScheduleCreateTransactionBody = exports2.TokenFeeScheduleUpdateTransactionBody = exports2.TokenDissociateTransactionBody = exports2.TokenAssociateTransactionBody = exports2.TokenWipeAccountTransactionBody = exports2.TokenBurnTransactionBody = exports2.TokenMintTransactionBody = exports2.TokenUpdateTransactionBody = exports2.TokenDeleteTransactionBody = exports2.TokenRevokeKycTransactionBody = exports2.TokenGrantKycTransactionBody = exports2.TokenUnfreezeAccountTransactionBody = exports2.TokenFreezeAccountTransactionBody = exports2.RoyaltyFee = exports2.AssessedCustomFee = exports2.CustomFee = exports2.FixedFee = exports2.FractionalFee = exports2.TokenCreateTransactionBody = exports2.UncheckedSubmitBody = exports2.ConsensusSubmitMessageTransactionBody = exports2.ConsensusMessageChunkInfo = exports2.ConsensusUpdateTopicTransactionBody = exports2.ContractDeleteTransactionBody = exports2.FileUpdateTransactionBody = exports2.FileDeleteTransactionBody = exports2.FileCreateTransactionBody = exports2.FileAppendTransactionBody = exports2.CryptoUpdateTransactionBody = exports2.CryptoTransferTransactionBody = exports2.CryptoDeleteLiveHashTransactionBody = exports2.CryptoDeleteTransactionBody = exports2.CryptoCreateTransactionBody = exports2.CryptoAddLiveHashTransactionBody = exports2.LiveHash = exports2.ContractUpdateTransactionBody = exports2.ContractCreateTransactionBody = exports2.ContractCallTransactionBody = exports2.FreezeTransactionBody = exports2.SystemUndeleteTransactionBody = exports2.SystemDeleteTransactionBody = exports2.TransactionBody = exports2.Transaction = exports2.QueryHeader = exports2.ResponseType = exports2.ConsensusGetTopicInfoResponse = exports2.ConsensusGetTopicInfoQuery = exports2.ConsensusDeleteTopicTransactionBody = exports2.Duration = exports2.ConsensusCreateTopicTransactionBody = exports2.TimestampSeconds = exports2.Timestamp = exports2.TokenBalances = exports2.TokenBalance = exports2.TokenRelationship = exports2.ServicesConfigurationList = exports2.Setting = exports2.SemanticVersion = exports2.NodeAddressBook = exports2.NodeAddress = exports2.ServiceEndpoint = exports2.CurrentAndNextFeeSchedule = exports2.FeeSchedule = exports2.FeeData = exports2.TransactionFeeSchedule = exports2.FeeComponents = exports2.HederaFunctionality = exports2.SignatureMap = exports2.SignaturePair = exports2.SignatureList = exports2.ThresholdSignature = exports2.Signature = exports2.KeyList = exports2.ThresholdKey = exports2.Key = exports2.TokenKycStatus = exports2.TokenFreezeStatus = exports2.TokenSupplyType = exports2.SubType = exports2.TokenType = exports2.ScheduleID = exports2.TokenID = exports2.TopicID = exports2.Fraction = exports2.TokenTransferList = exports2.NftTransfer = exports2.TransferList = exports2.AccountAmount = exports2.TransactionID = exports2.ContractID = exports2.FileID = exports2.AccountID = exports2.RealmID = exports2.ShardID = exports2.AllAccountBalances = exports2.SingleAccountBalances = exports2.TokenUnitBalance = exports2.Writer = exports2.Reader = void 0, exports2.FreezeType = exports2.TokenPauseStatus = exports2.TokenUnpauseTransactionBody = exports2.TokenPauseTransactionBody = exports2.BytesValue = exports2.StringValue = exports2.BoolValue = exports2.UInt32Value = exports2.UInt64Value = exports2.FloatValue = exports2.DoubleValue = exports2.TransactionList = exports2.SignedTransaction = exports2.TokenService = exports2.ThrottleDefinitions = exports2.ThrottleBucket = exports2.ThrottleGroup = exports2.SmartContractService = exports2.ScheduleService = exports2.NetworkService = exports2.MirrorConsensusService = exports2.ConsensusTopicResponse = exports2.ConsensusTopicQuery = exports2.FreezeService = exports2.FileService = exports2.CryptoService = exports2.Response = exports2.TokenGetNftInfosResponse = exports2.TokenGetNftInfosQuery = exports2.TokenGetNftInfoResponse = exports2.TokenNftInfo = exports2.TokenGetNftInfoQuery = exports2.NftID = exports2.TokenGetAccountNftInfosResponse = exports2.TokenGetAccountNftInfosQuery = exports2.ScheduleGetInfoResponse = exports2.ScheduleInfo = exports2.ScheduleGetInfoQuery = exports2.TokenGetInfoResponse = exports2.TokenInfo = exports2.TokenGetInfoQuery = exports2.NetworkGetVersionInfoResponse = exports2.NetworkGetVersionInfoQuery = exports2.TransactionGetFastRecordResponse = exports2.TransactionGetFastRecordQuery = exports2.TransactionGetRecordResponse = exports2.TransactionGetRecordQuery = exports2.TransactionGetReceiptResponse = exports2.TransactionGetReceiptQuery = exports2.FileInfo = exports2.FileGetInfoResponse = exports2.FileGetInfoQuery = exports2.FileContents = exports2.FileGetContentsResponse = exports2.FileGetContentsQuery = exports2.CryptoGetStakersResponse = exports2.AllProxyStakers = exports2.ProxyStaker = exports2.CryptoGetStakersQuery = exports2.CryptoGetLiveHashResponse = exports2.CryptoGetLiveHashQuery = exports2.AccountInfo = exports2.CryptoGetInfoResponse = exports2.CryptoGetInfoQuery = exports2.CryptoGetAccountRecordsResponse = exports2.CryptoGetAccountRecordsQuery = exports2.CryptoGetAccountBalanceResponse = exports2.CryptoGetAccountBalanceQuery = exports2.ExchangeRateSet = exports2.ExchangeRate = exports2.TransactionReceipt = exports2.TransactionRecord = exports2.ContractGetRecordsResponse = exports2.ContractGetRecordsQuery = exports2.ContractGetBytecodeResponse = exports2.ContractGetBytecodeQuery = exports2.ContractInfo = exports2.ContractGetInfoResponse = exports2.ContractGetInfoQuery = exports2.ContractCallLocalResponse = exports2.ContractCallLocalQuery = exports2.ContractFunctionResult = exports2.ContractLoginfo = exports2.GetBySolidityIDResponse = exports2.GetBySolidityIDQuery = exports2.GetByKeyResponse = exports2.EntityID = exports2.GetByKeyQuery = exports2.Query = exports2.ConsensusService = exports2.ConsensusTopicInfo = exports2.ResponseCodeEnum = exports2.TransactionResponse = exports2.ResponseHeader = exports2.ScheduleSignTransactionBody = exports2.ScheduleDeleteTransactionBody = void 0;
    var $protobuf = _interopRequireWildcard(require_minimal2());
    var _proto = require_proto();
    function _getRequireWildcardCache(a) {
      if (typeof WeakMap != "function")
        return null;
      var b = new WeakMap(), c = new WeakMap();
      return (_getRequireWildcardCache = function(a2) {
        return a2 ? c : b;
      })(a);
    }
    function _interopRequireWildcard(a, b) {
      if (!b && a && a.__esModule)
        return a;
      if (a === null || typeof a != "object" && typeof a != "function")
        return { default: a };
      var c = _getRequireWildcardCache(b);
      if (c && c.has(a))
        return c.get(a);
      var d = {}, e = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var f3 in a)
        if (f3 != "default" && Object.prototype.hasOwnProperty.call(a, f3)) {
          var g = e ? Object.getOwnPropertyDescriptor(a, f3) : null;
          g && (g.get || g.set) ? Object.defineProperty(d, f3, g) : d[f3] = a[f3];
        }
      return d.default = a, c && c.set(a, d), d;
    }
    var Reader = $protobuf.Reader;
    exports2.Reader = Reader;
    var Writer = $protobuf.Writer;
    exports2.Writer = Writer;
    var TokenUnitBalance = _proto.proto.TokenUnitBalance;
    exports2.TokenUnitBalance = TokenUnitBalance;
    var SingleAccountBalances = _proto.proto.SingleAccountBalances;
    exports2.SingleAccountBalances = SingleAccountBalances;
    var AllAccountBalances = _proto.proto.AllAccountBalances;
    exports2.AllAccountBalances = AllAccountBalances;
    var ShardID = _proto.proto.ShardID;
    exports2.ShardID = ShardID;
    var RealmID = _proto.proto.RealmID;
    exports2.RealmID = RealmID;
    var AccountID2 = _proto.proto.AccountID;
    exports2.AccountID = AccountID2;
    var FileID2 = _proto.proto.FileID;
    exports2.FileID = FileID2;
    var ContractID2 = _proto.proto.ContractID;
    exports2.ContractID = ContractID2;
    var TransactionID2 = _proto.proto.TransactionID;
    exports2.TransactionID = TransactionID2;
    var AccountAmount = _proto.proto.AccountAmount;
    exports2.AccountAmount = AccountAmount;
    var TransferList = _proto.proto.TransferList;
    exports2.TransferList = TransferList;
    var NftTransfer = _proto.proto.NftTransfer;
    exports2.NftTransfer = NftTransfer;
    var TokenTransferList = _proto.proto.TokenTransferList;
    exports2.TokenTransferList = TokenTransferList;
    var Fraction = _proto.proto.Fraction;
    exports2.Fraction = Fraction;
    var TopicID = _proto.proto.TopicID;
    exports2.TopicID = TopicID;
    var TokenID2 = _proto.proto.TokenID;
    exports2.TokenID = TokenID2;
    var ScheduleID2 = _proto.proto.ScheduleID;
    exports2.ScheduleID = ScheduleID2;
    var TokenType2 = _proto.proto.TokenType;
    exports2.TokenType = TokenType2;
    var SubType = _proto.proto.SubType;
    exports2.SubType = SubType;
    var TokenSupplyType2 = _proto.proto.TokenSupplyType;
    exports2.TokenSupplyType = TokenSupplyType2;
    var TokenFreezeStatus = _proto.proto.TokenFreezeStatus;
    exports2.TokenFreezeStatus = TokenFreezeStatus;
    var TokenKycStatus = _proto.proto.TokenKycStatus;
    exports2.TokenKycStatus = TokenKycStatus;
    var Key6 = _proto.proto.Key;
    exports2.Key = Key6;
    var ThresholdKey = _proto.proto.ThresholdKey;
    exports2.ThresholdKey = ThresholdKey;
    var KeyList3 = _proto.proto.KeyList;
    exports2.KeyList = KeyList3;
    var Signature = _proto.proto.Signature;
    exports2.Signature = Signature;
    var ThresholdSignature = _proto.proto.ThresholdSignature;
    exports2.ThresholdSignature = ThresholdSignature;
    var SignatureList = _proto.proto.SignatureList;
    exports2.SignatureList = SignatureList;
    var SignaturePair = _proto.proto.SignaturePair;
    exports2.SignaturePair = SignaturePair;
    var SignatureMap2 = _proto.proto.SignatureMap;
    exports2.SignatureMap = SignatureMap2;
    var HederaFunctionality = _proto.proto.HederaFunctionality;
    exports2.HederaFunctionality = HederaFunctionality;
    var FeeComponents = _proto.proto.FeeComponents;
    exports2.FeeComponents = FeeComponents;
    var TransactionFeeSchedule = _proto.proto.TransactionFeeSchedule;
    exports2.TransactionFeeSchedule = TransactionFeeSchedule;
    var FeeData = _proto.proto.FeeData;
    exports2.FeeData = FeeData;
    var FeeSchedule = _proto.proto.FeeSchedule;
    exports2.FeeSchedule = FeeSchedule;
    var CurrentAndNextFeeSchedule = _proto.proto.CurrentAndNextFeeSchedule;
    exports2.CurrentAndNextFeeSchedule = CurrentAndNextFeeSchedule;
    var ServiceEndpoint = _proto.proto.ServiceEndpoint;
    exports2.ServiceEndpoint = ServiceEndpoint;
    var NodeAddress2 = _proto.proto.NodeAddress;
    exports2.NodeAddress = NodeAddress2;
    var NodeAddressBook3 = _proto.proto.NodeAddressBook;
    exports2.NodeAddressBook = NodeAddressBook3;
    var SemanticVersion3 = _proto.proto.SemanticVersion;
    exports2.SemanticVersion = SemanticVersion3;
    var Setting = _proto.proto.Setting;
    exports2.Setting = Setting;
    var ServicesConfigurationList = _proto.proto.ServicesConfigurationList;
    exports2.ServicesConfigurationList = ServicesConfigurationList;
    var TokenRelationship2 = _proto.proto.TokenRelationship;
    exports2.TokenRelationship = TokenRelationship2;
    var TokenBalance = _proto.proto.TokenBalance;
    exports2.TokenBalance = TokenBalance;
    var TokenBalances = _proto.proto.TokenBalances;
    exports2.TokenBalances = TokenBalances;
    var Timestamp2 = _proto.proto.Timestamp;
    exports2.Timestamp = Timestamp2;
    var TimestampSeconds = _proto.proto.TimestampSeconds;
    exports2.TimestampSeconds = TimestampSeconds;
    var ConsensusCreateTopicTransactionBody = _proto.proto.ConsensusCreateTopicTransactionBody;
    exports2.ConsensusCreateTopicTransactionBody = ConsensusCreateTopicTransactionBody;
    var Duration2 = _proto.proto.Duration;
    exports2.Duration = Duration2;
    var ConsensusDeleteTopicTransactionBody = _proto.proto.ConsensusDeleteTopicTransactionBody;
    exports2.ConsensusDeleteTopicTransactionBody = ConsensusDeleteTopicTransactionBody;
    var ConsensusGetTopicInfoQuery = _proto.proto.ConsensusGetTopicInfoQuery;
    exports2.ConsensusGetTopicInfoQuery = ConsensusGetTopicInfoQuery;
    var ConsensusGetTopicInfoResponse = _proto.proto.ConsensusGetTopicInfoResponse;
    exports2.ConsensusGetTopicInfoResponse = ConsensusGetTopicInfoResponse;
    var ResponseType2 = _proto.proto.ResponseType;
    exports2.ResponseType = ResponseType2;
    var QueryHeader = _proto.proto.QueryHeader;
    exports2.QueryHeader = QueryHeader;
    var Transaction2 = _proto.proto.Transaction;
    exports2.Transaction = Transaction2;
    var TransactionBody = _proto.proto.TransactionBody;
    exports2.TransactionBody = TransactionBody;
    var SystemDeleteTransactionBody = _proto.proto.SystemDeleteTransactionBody;
    exports2.SystemDeleteTransactionBody = SystemDeleteTransactionBody;
    var SystemUndeleteTransactionBody = _proto.proto.SystemUndeleteTransactionBody;
    exports2.SystemUndeleteTransactionBody = SystemUndeleteTransactionBody;
    var FreezeTransactionBody = _proto.proto.FreezeTransactionBody;
    exports2.FreezeTransactionBody = FreezeTransactionBody;
    var ContractCallTransactionBody = _proto.proto.ContractCallTransactionBody;
    exports2.ContractCallTransactionBody = ContractCallTransactionBody;
    var ContractCreateTransactionBody = _proto.proto.ContractCreateTransactionBody;
    exports2.ContractCreateTransactionBody = ContractCreateTransactionBody;
    var ContractUpdateTransactionBody = _proto.proto.ContractUpdateTransactionBody;
    exports2.ContractUpdateTransactionBody = ContractUpdateTransactionBody;
    var LiveHash2 = _proto.proto.LiveHash;
    exports2.LiveHash = LiveHash2;
    var CryptoAddLiveHashTransactionBody = _proto.proto.CryptoAddLiveHashTransactionBody;
    exports2.CryptoAddLiveHashTransactionBody = CryptoAddLiveHashTransactionBody;
    var CryptoCreateTransactionBody = _proto.proto.CryptoCreateTransactionBody;
    exports2.CryptoCreateTransactionBody = CryptoCreateTransactionBody;
    var CryptoDeleteTransactionBody = _proto.proto.CryptoDeleteTransactionBody;
    exports2.CryptoDeleteTransactionBody = CryptoDeleteTransactionBody;
    var CryptoDeleteLiveHashTransactionBody = _proto.proto.CryptoDeleteLiveHashTransactionBody;
    exports2.CryptoDeleteLiveHashTransactionBody = CryptoDeleteLiveHashTransactionBody;
    var CryptoTransferTransactionBody = _proto.proto.CryptoTransferTransactionBody;
    exports2.CryptoTransferTransactionBody = CryptoTransferTransactionBody;
    var CryptoUpdateTransactionBody = _proto.proto.CryptoUpdateTransactionBody;
    exports2.CryptoUpdateTransactionBody = CryptoUpdateTransactionBody;
    var FileAppendTransactionBody = _proto.proto.FileAppendTransactionBody;
    exports2.FileAppendTransactionBody = FileAppendTransactionBody;
    var FileCreateTransactionBody = _proto.proto.FileCreateTransactionBody;
    exports2.FileCreateTransactionBody = FileCreateTransactionBody;
    var FileDeleteTransactionBody = _proto.proto.FileDeleteTransactionBody;
    exports2.FileDeleteTransactionBody = FileDeleteTransactionBody;
    var FileUpdateTransactionBody = _proto.proto.FileUpdateTransactionBody;
    exports2.FileUpdateTransactionBody = FileUpdateTransactionBody;
    var ContractDeleteTransactionBody = _proto.proto.ContractDeleteTransactionBody;
    exports2.ContractDeleteTransactionBody = ContractDeleteTransactionBody;
    var ConsensusUpdateTopicTransactionBody = _proto.proto.ConsensusUpdateTopicTransactionBody;
    exports2.ConsensusUpdateTopicTransactionBody = ConsensusUpdateTopicTransactionBody;
    var ConsensusMessageChunkInfo = _proto.proto.ConsensusMessageChunkInfo;
    exports2.ConsensusMessageChunkInfo = ConsensusMessageChunkInfo;
    var ConsensusSubmitMessageTransactionBody = _proto.proto.ConsensusSubmitMessageTransactionBody;
    exports2.ConsensusSubmitMessageTransactionBody = ConsensusSubmitMessageTransactionBody;
    var UncheckedSubmitBody = _proto.proto.UncheckedSubmitBody;
    exports2.UncheckedSubmitBody = UncheckedSubmitBody;
    var TokenCreateTransactionBody = _proto.proto.TokenCreateTransactionBody;
    exports2.TokenCreateTransactionBody = TokenCreateTransactionBody;
    var FractionalFee = _proto.proto.FractionalFee;
    exports2.FractionalFee = FractionalFee;
    var FixedFee = _proto.proto.FixedFee;
    exports2.FixedFee = FixedFee;
    var CustomFee2 = _proto.proto.CustomFee;
    exports2.CustomFee = CustomFee2;
    var AssessedCustomFee2 = _proto.proto.AssessedCustomFee;
    exports2.AssessedCustomFee = AssessedCustomFee2;
    var RoyaltyFee = _proto.proto.RoyaltyFee;
    exports2.RoyaltyFee = RoyaltyFee;
    var TokenFreezeAccountTransactionBody = _proto.proto.TokenFreezeAccountTransactionBody;
    exports2.TokenFreezeAccountTransactionBody = TokenFreezeAccountTransactionBody;
    var TokenUnfreezeAccountTransactionBody = _proto.proto.TokenUnfreezeAccountTransactionBody;
    exports2.TokenUnfreezeAccountTransactionBody = TokenUnfreezeAccountTransactionBody;
    var TokenGrantKycTransactionBody = _proto.proto.TokenGrantKycTransactionBody;
    exports2.TokenGrantKycTransactionBody = TokenGrantKycTransactionBody;
    var TokenRevokeKycTransactionBody = _proto.proto.TokenRevokeKycTransactionBody;
    exports2.TokenRevokeKycTransactionBody = TokenRevokeKycTransactionBody;
    var TokenDeleteTransactionBody = _proto.proto.TokenDeleteTransactionBody;
    exports2.TokenDeleteTransactionBody = TokenDeleteTransactionBody;
    var TokenUpdateTransactionBody = _proto.proto.TokenUpdateTransactionBody;
    exports2.TokenUpdateTransactionBody = TokenUpdateTransactionBody;
    var TokenMintTransactionBody = _proto.proto.TokenMintTransactionBody;
    exports2.TokenMintTransactionBody = TokenMintTransactionBody;
    var TokenBurnTransactionBody = _proto.proto.TokenBurnTransactionBody;
    exports2.TokenBurnTransactionBody = TokenBurnTransactionBody;
    var TokenWipeAccountTransactionBody = _proto.proto.TokenWipeAccountTransactionBody;
    exports2.TokenWipeAccountTransactionBody = TokenWipeAccountTransactionBody;
    var TokenAssociateTransactionBody = _proto.proto.TokenAssociateTransactionBody;
    exports2.TokenAssociateTransactionBody = TokenAssociateTransactionBody;
    var TokenDissociateTransactionBody = _proto.proto.TokenDissociateTransactionBody;
    exports2.TokenDissociateTransactionBody = TokenDissociateTransactionBody;
    var TokenFeeScheduleUpdateTransactionBody = _proto.proto.TokenFeeScheduleUpdateTransactionBody;
    exports2.TokenFeeScheduleUpdateTransactionBody = TokenFeeScheduleUpdateTransactionBody;
    var ScheduleCreateTransactionBody = _proto.proto.ScheduleCreateTransactionBody;
    exports2.ScheduleCreateTransactionBody = ScheduleCreateTransactionBody;
    var SchedulableTransactionBody = _proto.proto.SchedulableTransactionBody;
    exports2.SchedulableTransactionBody = SchedulableTransactionBody;
    var ScheduleDeleteTransactionBody = _proto.proto.ScheduleDeleteTransactionBody;
    exports2.ScheduleDeleteTransactionBody = ScheduleDeleteTransactionBody;
    var ScheduleSignTransactionBody = _proto.proto.ScheduleSignTransactionBody;
    exports2.ScheduleSignTransactionBody = ScheduleSignTransactionBody;
    var ResponseHeader = _proto.proto.ResponseHeader;
    exports2.ResponseHeader = ResponseHeader;
    var TransactionResponse2 = _proto.proto.TransactionResponse;
    exports2.TransactionResponse = TransactionResponse2;
    var ResponseCodeEnum5 = _proto.proto.ResponseCodeEnum;
    exports2.ResponseCodeEnum = ResponseCodeEnum5;
    var ConsensusTopicInfo2 = _proto.proto.ConsensusTopicInfo;
    exports2.ConsensusTopicInfo = ConsensusTopicInfo2;
    var ConsensusService2 = _proto.proto.ConsensusService;
    exports2.ConsensusService = ConsensusService2;
    var Query2 = _proto.proto.Query;
    exports2.Query = Query2;
    var GetByKeyQuery = _proto.proto.GetByKeyQuery;
    exports2.GetByKeyQuery = GetByKeyQuery;
    var EntityID = _proto.proto.EntityID;
    exports2.EntityID = EntityID;
    var GetByKeyResponse = _proto.proto.GetByKeyResponse;
    exports2.GetByKeyResponse = GetByKeyResponse;
    var GetBySolidityIDQuery = _proto.proto.GetBySolidityIDQuery;
    exports2.GetBySolidityIDQuery = GetBySolidityIDQuery;
    var GetBySolidityIDResponse = _proto.proto.GetBySolidityIDResponse;
    exports2.GetBySolidityIDResponse = GetBySolidityIDResponse;
    var ContractLoginfo = _proto.proto.ContractLoginfo;
    exports2.ContractLoginfo = ContractLoginfo;
    var ContractFunctionResult2 = _proto.proto.ContractFunctionResult;
    exports2.ContractFunctionResult = ContractFunctionResult2;
    var ContractCallLocalQuery = _proto.proto.ContractCallLocalQuery;
    exports2.ContractCallLocalQuery = ContractCallLocalQuery;
    var ContractCallLocalResponse = _proto.proto.ContractCallLocalResponse;
    exports2.ContractCallLocalResponse = ContractCallLocalResponse;
    var ContractGetInfoQuery = _proto.proto.ContractGetInfoQuery;
    exports2.ContractGetInfoQuery = ContractGetInfoQuery;
    var ContractGetInfoResponse2 = _proto.proto.ContractGetInfoResponse;
    exports2.ContractGetInfoResponse = ContractGetInfoResponse2;
    var ContractInfo2 = _proto.proto.ContractGetInfoResponse.ContractInfo;
    exports2.ContractInfo = ContractInfo2;
    var ContractGetBytecodeQuery = _proto.proto.ContractGetBytecodeQuery;
    exports2.ContractGetBytecodeQuery = ContractGetBytecodeQuery;
    var ContractGetBytecodeResponse = _proto.proto.ContractGetBytecodeResponse;
    exports2.ContractGetBytecodeResponse = ContractGetBytecodeResponse;
    var ContractGetRecordsQuery = _proto.proto.ContractGetRecordsQuery;
    exports2.ContractGetRecordsQuery = ContractGetRecordsQuery;
    var ContractGetRecordsResponse = _proto.proto.ContractGetRecordsResponse;
    exports2.ContractGetRecordsResponse = ContractGetRecordsResponse;
    var TransactionRecord2 = _proto.proto.TransactionRecord;
    exports2.TransactionRecord = TransactionRecord2;
    var TransactionReceipt2 = _proto.proto.TransactionReceipt;
    exports2.TransactionReceipt = TransactionReceipt2;
    var ExchangeRate2 = _proto.proto.ExchangeRate;
    exports2.ExchangeRate = ExchangeRate2;
    var ExchangeRateSet = _proto.proto.ExchangeRateSet;
    exports2.ExchangeRateSet = ExchangeRateSet;
    var CryptoGetAccountBalanceQuery = _proto.proto.CryptoGetAccountBalanceQuery;
    exports2.CryptoGetAccountBalanceQuery = CryptoGetAccountBalanceQuery;
    var CryptoGetAccountBalanceResponse = _proto.proto.CryptoGetAccountBalanceResponse;
    exports2.CryptoGetAccountBalanceResponse = CryptoGetAccountBalanceResponse;
    var CryptoGetAccountRecordsQuery = _proto.proto.CryptoGetAccountRecordsQuery;
    exports2.CryptoGetAccountRecordsQuery = CryptoGetAccountRecordsQuery;
    var CryptoGetAccountRecordsResponse = _proto.proto.CryptoGetAccountRecordsResponse;
    exports2.CryptoGetAccountRecordsResponse = CryptoGetAccountRecordsResponse;
    var CryptoGetInfoQuery = _proto.proto.CryptoGetInfoQuery;
    exports2.CryptoGetInfoQuery = CryptoGetInfoQuery;
    var CryptoGetInfoResponse2 = _proto.proto.CryptoGetInfoResponse;
    exports2.CryptoGetInfoResponse = CryptoGetInfoResponse2;
    var AccountInfo2 = _proto.proto.CryptoGetInfoResponse.AccountInfo;
    exports2.AccountInfo = AccountInfo2;
    var CryptoGetLiveHashQuery = _proto.proto.CryptoGetLiveHashQuery;
    exports2.CryptoGetLiveHashQuery = CryptoGetLiveHashQuery;
    var CryptoGetLiveHashResponse = _proto.proto.CryptoGetLiveHashResponse;
    exports2.CryptoGetLiveHashResponse = CryptoGetLiveHashResponse;
    var CryptoGetStakersQuery = _proto.proto.CryptoGetStakersQuery;
    exports2.CryptoGetStakersQuery = CryptoGetStakersQuery;
    var ProxyStaker2 = _proto.proto.ProxyStaker;
    exports2.ProxyStaker = ProxyStaker2;
    var AllProxyStakers = _proto.proto.AllProxyStakers;
    exports2.AllProxyStakers = AllProxyStakers;
    var CryptoGetStakersResponse = _proto.proto.CryptoGetStakersResponse;
    exports2.CryptoGetStakersResponse = CryptoGetStakersResponse;
    var FileGetContentsQuery = _proto.proto.FileGetContentsQuery;
    exports2.FileGetContentsQuery = FileGetContentsQuery;
    var FileGetContentsResponse = _proto.proto.FileGetContentsResponse;
    exports2.FileGetContentsResponse = FileGetContentsResponse;
    var FileContents = _proto.proto.FileGetContentsResponse.FileContents;
    exports2.FileContents = FileContents;
    var FileGetInfoQuery = _proto.proto.FileGetInfoQuery;
    exports2.FileGetInfoQuery = FileGetInfoQuery;
    var FileGetInfoResponse2 = _proto.proto.FileGetInfoResponse;
    exports2.FileGetInfoResponse = FileGetInfoResponse2;
    var FileInfo2 = _proto.proto.FileGetInfoResponse.FileInfo;
    exports2.FileInfo = FileInfo2;
    var TransactionGetReceiptQuery = _proto.proto.TransactionGetReceiptQuery;
    exports2.TransactionGetReceiptQuery = TransactionGetReceiptQuery;
    var TransactionGetReceiptResponse2 = _proto.proto.TransactionGetReceiptResponse;
    exports2.TransactionGetReceiptResponse = TransactionGetReceiptResponse2;
    var TransactionGetRecordQuery = _proto.proto.TransactionGetRecordQuery;
    exports2.TransactionGetRecordQuery = TransactionGetRecordQuery;
    var TransactionGetRecordResponse2 = _proto.proto.TransactionGetRecordResponse;
    exports2.TransactionGetRecordResponse = TransactionGetRecordResponse2;
    var TransactionGetFastRecordQuery = _proto.proto.TransactionGetFastRecordQuery;
    exports2.TransactionGetFastRecordQuery = TransactionGetFastRecordQuery;
    var TransactionGetFastRecordResponse = _proto.proto.TransactionGetFastRecordResponse;
    exports2.TransactionGetFastRecordResponse = TransactionGetFastRecordResponse;
    var NetworkGetVersionInfoQuery = _proto.proto.NetworkGetVersionInfoQuery;
    exports2.NetworkGetVersionInfoQuery = NetworkGetVersionInfoQuery;
    var NetworkGetVersionInfoResponse2 = _proto.proto.NetworkGetVersionInfoResponse;
    exports2.NetworkGetVersionInfoResponse = NetworkGetVersionInfoResponse2;
    var TokenGetInfoQuery = _proto.proto.TokenGetInfoQuery;
    exports2.TokenGetInfoQuery = TokenGetInfoQuery;
    var TokenInfo3 = _proto.proto.TokenInfo;
    exports2.TokenInfo = TokenInfo3;
    var TokenGetInfoResponse = _proto.proto.TokenGetInfoResponse;
    exports2.TokenGetInfoResponse = TokenGetInfoResponse;
    var ScheduleGetInfoQuery = _proto.proto.ScheduleGetInfoQuery;
    exports2.ScheduleGetInfoQuery = ScheduleGetInfoQuery;
    var ScheduleInfo2 = _proto.proto.ScheduleInfo;
    exports2.ScheduleInfo = ScheduleInfo2;
    var ScheduleGetInfoResponse = _proto.proto.ScheduleGetInfoResponse;
    exports2.ScheduleGetInfoResponse = ScheduleGetInfoResponse;
    var TokenGetAccountNftInfosQuery = _proto.proto.TokenGetAccountNftInfosQuery;
    exports2.TokenGetAccountNftInfosQuery = TokenGetAccountNftInfosQuery;
    var TokenGetAccountNftInfosResponse = _proto.proto.TokenGetAccountNftInfosResponse;
    exports2.TokenGetAccountNftInfosResponse = TokenGetAccountNftInfosResponse;
    var NftID2 = _proto.proto.NftID;
    exports2.NftID = NftID2;
    var TokenGetNftInfoQuery = _proto.proto.TokenGetNftInfoQuery;
    exports2.TokenGetNftInfoQuery = TokenGetNftInfoQuery;
    var TokenNftInfo2 = _proto.proto.TokenNftInfo;
    exports2.TokenNftInfo = TokenNftInfo2;
    var TokenGetNftInfoResponse = _proto.proto.TokenGetNftInfoResponse;
    exports2.TokenGetNftInfoResponse = TokenGetNftInfoResponse;
    var TokenGetNftInfosQuery = _proto.proto.TokenGetNftInfosQuery;
    exports2.TokenGetNftInfosQuery = TokenGetNftInfosQuery;
    var TokenGetNftInfosResponse = _proto.proto.TokenGetNftInfosResponse;
    exports2.TokenGetNftInfosResponse = TokenGetNftInfosResponse;
    var Response = _proto.proto.Response;
    exports2.Response = Response;
    var CryptoService2 = _proto.proto.CryptoService;
    exports2.CryptoService = CryptoService2;
    var FileService2 = _proto.proto.FileService;
    exports2.FileService = FileService2;
    var FreezeService2 = _proto.proto.FreezeService;
    exports2.FreezeService = FreezeService2;
    var ConsensusTopicQuery2 = _proto.proto.ConsensusTopicQuery;
    exports2.ConsensusTopicQuery = ConsensusTopicQuery2;
    var ConsensusTopicResponse2 = _proto.proto.ConsensusTopicResponse;
    exports2.ConsensusTopicResponse = ConsensusTopicResponse2;
    var MirrorConsensusService = _proto.proto.MirrorConsensusService;
    exports2.MirrorConsensusService = MirrorConsensusService;
    var NetworkService2 = _proto.proto.NetworkService;
    exports2.NetworkService = NetworkService2;
    var ScheduleService2 = _proto.proto.ScheduleService;
    exports2.ScheduleService = ScheduleService2;
    var SmartContractService2 = _proto.proto.SmartContractService;
    exports2.SmartContractService = SmartContractService2;
    var ThrottleGroup = _proto.proto.ThrottleGroup;
    exports2.ThrottleGroup = ThrottleGroup;
    var ThrottleBucket = _proto.proto.ThrottleBucket;
    exports2.ThrottleBucket = ThrottleBucket;
    var ThrottleDefinitions = _proto.proto.ThrottleDefinitions;
    exports2.ThrottleDefinitions = ThrottleDefinitions;
    var TokenService2 = _proto.proto.TokenService;
    exports2.TokenService = TokenService2;
    var SignedTransaction = _proto.proto.SignedTransaction;
    exports2.SignedTransaction = SignedTransaction;
    var TransactionList = _proto.proto.TransactionList;
    exports2.TransactionList = TransactionList;
    var DoubleValue = _proto.proto.DoubleValue;
    exports2.DoubleValue = DoubleValue;
    var FloatValue = _proto.proto.FloatValue;
    exports2.FloatValue = FloatValue;
    var UInt64Value = _proto.proto.UInt64Value;
    exports2.UInt64Value = UInt64Value;
    var UInt32Value = _proto.proto.UInt32Value;
    exports2.UInt32Value = UInt32Value;
    var BoolValue = _proto.proto.BoolValue;
    exports2.BoolValue = BoolValue;
    var StringValue = _proto.proto.StringValue;
    exports2.StringValue = StringValue;
    var BytesValue = _proto.proto.BytesValue;
    exports2.BytesValue = BytesValue;
    var TokenPauseTransactionBody = _proto.proto.TokenPauseTransactionBody;
    exports2.TokenPauseTransactionBody = TokenPauseTransactionBody;
    var TokenUnpauseTransactionBody = _proto.proto.TokenUnpauseTransactionBody;
    exports2.TokenUnpauseTransactionBody = TokenUnpauseTransactionBody;
    var TokenPauseStatus = _proto.proto.TokenPauseStatus;
    exports2.TokenPauseStatus = TokenPauseStatus;
    var FreezeType2 = _proto.proto.FreezeType;
    exports2.FreezeType = FreezeType2;
  }
});

// node_modules/@hashgraph/cryptography/src/Key.js
var Key = class {
};

// node_modules/@hashgraph/cryptography/src/KeyList.js
var KeyList = class extends Key {
  constructor(keys, threshold) {
    super();
    this._keys = keys == null ? [] : keys;
    this._threshold = threshold == null ? null : threshold;
  }
  static of(...keys) {
    return new KeyList(keys, null);
  }
  static from(arrayLike, mapFn, thisArg) {
    if (mapFn == null) {
      return new KeyList(Array.from(arrayLike));
    }
    return new KeyList(Array.from(arrayLike, mapFn, thisArg));
  }
  get threshold() {
    return this._threshold;
  }
  setThreshold(threshold) {
    this._threshold = threshold;
    return this;
  }
  push(...keys) {
    return this._keys.push(...keys);
  }
  splice(start, deleteCount, ...items) {
    return new KeyList(this._keys.splice(start, deleteCount, ...items), this.threshold);
  }
  slice(start, end) {
    return new KeyList(this._keys.slice(start, end), this.threshold);
  }
  [Symbol.iterator]() {
    return this._keys[Symbol.iterator]();
  }
  toArray() {
    return this._keys.slice();
  }
  toString() {
    return JSON.stringify({
      threshold: this._threshold,
      keys: this._keys.toString()
    });
  }
};

// node_modules/@hashgraph/cryptography/src/BadKeyError.js
var BadKeyError = class extends Error {
  constructor(messageOrCause) {
    super(messageOrCause instanceof Error ? messageOrCause.message : messageOrCause);
    this.name = "BadKeyError";
    if (messageOrCause instanceof Error) {
      this.cause = messageOrCause;
      this.stack = messageOrCause.stack;
    }
  }
};

// node_modules/@hashgraph/cryptography/src/Ed25519PublicKey.js
var import_tweetnacl = __toModule(require_nacl_fast());

// node_modules/@hashgraph/cryptography/src/util/array.js
function arrayEqual(array1, array2) {
  if (array1 === array2) {
    return true;
  }
  if (array1.byteLength !== array2.byteLength) {
    return false;
  }
  const view1 = new DataView(array1.buffer, array1.byteOffset, array1.byteLength);
  const view2 = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
  let i = array1.byteLength;
  while (i--) {
    if (view1.getUint8(i) !== view2.getUint8(i)) {
      return false;
    }
  }
  return true;
}
function arrayStartsWith(array, arrayPrefix) {
  if (array.byteLength < arrayPrefix.byteLength) {
    return false;
  }
  let i = arrayPrefix.byteLength;
  while (i--) {
    if (array[i] !== arrayPrefix[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@hashgraph/cryptography/src/encoding/hex.browser.js
var byteToHex = [];
for (let n = 0; n <= 255; n += 1) {
  byteToHex.push(n.toString(16).padStart(2, "0"));
}
function encode(data) {
  let string = "";
  for (const byte of data) {
    string += byteToHex[byte];
  }
  return string;
}
function decode(text) {
  const str = text.startsWith("0x") ? text.substring(2) : text;
  const result = str.match(/.{1,2}/gu);
  return new Uint8Array((result == null ? [] : result).map((byte) => parseInt(byte, 16)));
}

// node_modules/@hashgraph/cryptography/src/Ed25519PublicKey.js
var derPrefix = "302a300506032b6570032100";
var derPrefixBytes = decode(derPrefix);
var Ed25519PublicKey = class extends Key {
  constructor(keyData) {
    super();
    this._keyData = keyData;
  }
  get _type() {
    return "ED25519";
  }
  static fromBytes(data) {
    switch (data.length) {
      case 32:
        return Ed25519PublicKey.fromBytesRaw(data);
      case 44:
        return Ed25519PublicKey.fromBytesDer(data);
      default:
        throw new BadKeyError(`invalid public key length: ${data.length} bytes`);
    }
  }
  static fromBytesDer(data) {
    if (data.length != 44 || !arrayStartsWith(data, derPrefixBytes)) {
      throw new BadKeyError(`invalid public key length: ${data.length} bytes`);
    }
    return new Ed25519PublicKey(data.subarray(12));
  }
  static fromBytesRaw(data) {
    if (data.length != 32) {
      throw new BadKeyError(`invalid public key length: ${data.length} bytes`);
    }
    return new Ed25519PublicKey(data);
  }
  static fromString(text) {
    return Ed25519PublicKey.fromBytes(decode(text));
  }
  verify(message, signature) {
    return import_tweetnacl.default.sign.detached.verify(message, signature, this._keyData);
  }
  toBytesDer() {
    const bytes2 = new Uint8Array(derPrefixBytes.length + 32);
    bytes2.set(derPrefixBytes, 0);
    bytes2.set(this._keyData.subarray(0, 32), derPrefixBytes.length);
    return bytes2;
  }
  toBytesRaw() {
    return this._keyData.slice();
  }
  equals(other) {
    return arrayEqual(this._keyData, other._keyData);
  }
};

// node_modules/@hashgraph/cryptography/src/Ed25519PrivateKey.js
var import_tweetnacl3 = __toModule(require_nacl_fast());

// node_modules/@hashgraph/cryptography/src/primitive/random.js
var import_tweetnacl2 = __toModule(require_nacl_fast());
function bytes(count) {
  return import_tweetnacl2.default.randomBytes(count);
}
function bytesAsync(count) {
  return Promise.resolve(import_tweetnacl2.default.randomBytes(count));
}

// node_modules/@hashgraph/cryptography/src/Ed25519PrivateKey.js
var derPrefix2 = "302e020100300506032b657004220420";
var derPrefixBytes2 = decode(derPrefix2);
var Ed25519PrivateKey = class {
  constructor(keyPair, chainCode) {
    this._keyPair = keyPair instanceof Uint8Array ? import_tweetnacl3.default.sign.keyPair.fromSeed(keyPair) : keyPair;
    this._chainCode = chainCode != null ? chainCode : null;
  }
  get _type() {
    return "ED25519";
  }
  static generate() {
    const entropy2 = bytes(64);
    return new Ed25519PrivateKey(import_tweetnacl3.default.sign.keyPair.fromSeed(entropy2.subarray(0, 32)), entropy2.subarray(32));
  }
  static async generateAsync() {
    const entropy2 = await bytesAsync(64);
    return new Ed25519PrivateKey(import_tweetnacl3.default.sign.keyPair.fromSeed(entropy2.subarray(0, 32)), entropy2.subarray(32));
  }
  static fromBytes(data) {
    switch (data.length) {
      case 48:
        return Ed25519PrivateKey.fromBytesDer(data);
      case 32:
      case 64:
        return Ed25519PrivateKey.fromBytesRaw(data);
      default:
        throw new BadKeyError(`invalid private key length: ${data.length} bytes`);
    }
  }
  static fromBytesDer(data) {
    if (data.length != 48 || !arrayStartsWith(data, derPrefixBytes2)) {
      throw new BadKeyError(`invalid private key length: ${data.length} bytes`);
    }
    const keyPair = import_tweetnacl3.default.sign.keyPair.fromSeed(data.subarray(16));
    return new Ed25519PrivateKey(keyPair);
  }
  static fromBytesRaw(data) {
    switch (data.length) {
      case 32:
        return new Ed25519PrivateKey(import_tweetnacl3.default.sign.keyPair.fromSeed(data));
      case 64:
        return new Ed25519PrivateKey(import_tweetnacl3.default.sign.keyPair.fromSecretKey(data));
      default:
    }
    throw new BadKeyError(`invalid private key length: ${data.length} bytes`);
  }
  static fromString(text) {
    return Ed25519PrivateKey.fromBytes(decode(text));
  }
  static fromStringDer(text) {
    return Ed25519PrivateKey.fromBytesDer(decode(text));
  }
  static fromStringRaw(text) {
    return Ed25519PrivateKey.fromBytesRaw(decode(text));
  }
  get publicKey() {
    return new Ed25519PublicKey(this._keyPair.publicKey);
  }
  sign(bytes2) {
    return import_tweetnacl3.default.sign.detached(bytes2, this._keyPair.secretKey);
  }
  toBytesDer() {
    const bytes2 = new Uint8Array(derPrefixBytes2.length + 32);
    bytes2.set(derPrefixBytes2, 0);
    bytes2.set(this._keyPair.secretKey.subarray(0, 32), derPrefixBytes2.length);
    return bytes2;
  }
  toBytesRaw() {
    return this._keyPair.secretKey.slice(0, 32);
  }
};

// node_modules/@hashgraph/cryptography/src/BadMnemonicReason.js
var BadMnemonicReason = Object.freeze({
  BadLength: "BadLength",
  UnknownWords: "UnknownWords",
  ChecksumMismatch: "ChecksumMismatch"
});
var BadMnemonicReason_default = BadMnemonicReason;

// node_modules/@hashgraph/cryptography/src/BadMnemonicError.js
var BadMnemonicError = class extends Error {
  constructor(mnemonic, reason, unknownWordIndices) {
    let reasonMessage;
    switch (reason) {
      case BadMnemonicReason_default.BadLength:
        reasonMessage = "mnemonic is of an unexpected number of words";
        break;
      case BadMnemonicReason_default.ChecksumMismatch:
        reasonMessage = "checksum byte in mnemonic did not match the rest of the mnemonic";
        break;
      case BadMnemonicReason_default.UnknownWords:
        reasonMessage = "mnemonic contained words that are not in the standard word list";
        break;
      default:
        throw new Error(`unexpected value ${reason.toString()} for 'reason'`);
    }
    super(`invalid mnemonic: ${reasonMessage}`);
    if (typeof Error.captureStackTrace !== "undefined") {
      Error.captureStackTrace(this, BadMnemonicError);
    }
    this.name = "BadMnemonicError";
    this.reason = reason;
    this.mnemonic = mnemonic;
    this.unknownWordIndices = unknownWordIndices;
  }
};

// node_modules/@hashgraph/cryptography/src/words/legacy.js
var legacy_default = [
  "aback",
  "abbey",
  "abbot",
  "abide",
  "ablaze",
  "able",
  "aboard",
  "abode",
  "abort",
  "abound",
  "about",
  "above",
  "abroad",
  "abrupt",
  "absent",
  "absorb",
  "absurd",
  "abuse",
  "accent",
  "accept",
  "access",
  "accord",
  "accuse",
  "ace",
  "ache",
  "aching",
  "acid",
  "acidic",
  "acorn",
  "acre",
  "across",
  "act",
  "action",
  "active",
  "actor",
  "actual",
  "acute",
  "adam",
  "adapt",
  "add",
  "added",
  "addict",
  "adept",
  "adhere",
  "adjust",
  "admire",
  "admit",
  "adobe",
  "adopt",
  "adrift",
  "adult",
  "adverb",
  "advice",
  "aerial",
  "afar",
  "affair",
  "affect",
  "afford",
  "afghan",
  "afield",
  "afloat",
  "afraid",
  "afresh",
  "after",
  "again",
  "age",
  "agency",
  "agenda",
  "agent",
  "aghast",
  "agile",
  "ago",
  "agony",
  "agree",
  "agreed",
  "ahead",
  "aid",
  "aide",
  "aim",
  "air",
  "airman",
  "airy",
  "akin",
  "alarm",
  "alaska",
  "albeit",
  "album",
  "ale",
  "alert",
  "alibi",
  "alice",
  "alien",
  "alight",
  "align",
  "alike",
  "alive",
  "alkali",
  "all",
  "alley",
  "allied",
  "allow",
  "alloy",
  "ally",
  "almond",
  "almost",
  "aloft",
  "alone",
  "along",
  "aloof",
  "aloud",
  "alpha",
  "alpine",
  "also",
  "altar",
  "alter",
  "always",
  "amaze",
  "amazon",
  "amber",
  "ambush",
  "amen",
  "amend",
  "amid",
  "amidst",
  "amiss",
  "among",
  "amount",
  "ample",
  "amuse",
  "anchor",
  "and",
  "andrew",
  "anew",
  "angel",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "annoy",
  "annual",
  "answer",
  "anthem",
  "any",
  "anyhow",
  "anyway",
  "apart",
  "apathy",
  "apex",
  "apiece",
  "appeal",
  "appear",
  "apple",
  "apply",
  "april",
  "apron",
  "arab",
  "arcade",
  "arcane",
  "arch",
  "arctic",
  "ardent",
  "are",
  "area",
  "argue",
  "arid",
  "arise",
  "ark",
  "arm",
  "armful",
  "army",
  "aroma",
  "around",
  "arouse",
  "array",
  "arrest",
  "arrive",
  "arrow",
  "arson",
  "art",
  "artery",
  "artful",
  "artist",
  "ascent",
  "ash",
  "ashen",
  "ashore",
  "aside",
  "ask",
  "asleep",
  "aspect",
  "assay",
  "assent",
  "assert",
  "assess",
  "asset",
  "assign",
  "assist",
  "assume",
  "assure",
  "asthma",
  "astute",
  "asylum",
  "ate",
  "athens",
  "atlas",
  "atom",
  "atomic",
  "attach",
  "attack",
  "attain",
  "attend",
  "attic",
  "auburn",
  "audio",
  "audit",
  "august",
  "aunt",
  "auntie",
  "aura",
  "austin",
  "author",
  "auto",
  "autumn",
  "avail",
  "avenge",
  "avenue",
  "avert",
  "avid",
  "avoid",
  "await",
  "awake",
  "awaken",
  "award",
  "aware",
  "awash",
  "away",
  "awful",
  "awhile",
  "axe",
  "axes",
  "axiom",
  "axis",
  "axle",
  "aye",
  "babe",
  "baby",
  "bach",
  "back",
  "backup",
  "bacon",
  "bad",
  "badge",
  "badly",
  "bag",
  "baggy",
  "bail",
  "bait",
  "bake",
  "baker",
  "bakery",
  "bald",
  "ball",
  "ballad",
  "ballet",
  "ballot",
  "baltic",
  "bamboo",
  "ban",
  "banal",
  "banana",
  "band",
  "bang",
  "bank",
  "bar",
  "barber",
  "bare",
  "barely",
  "barge",
  "bark",
  "barley",
  "barn",
  "baron",
  "barrel",
  "barren",
  "basalt",
  "base",
  "basic",
  "basil",
  "basin",
  "basis",
  "basket",
  "bass",
  "bat",
  "batch",
  "bath",
  "baton",
  "battle",
  "bay",
  "beach",
  "beacon",
  "beak",
  "beam",
  "bean",
  "bear",
  "beard",
  "beast",
  "beat",
  "beauty",
  "become",
  "bed",
  "beech",
  "beef",
  "beefy",
  "beep",
  "beer",
  "beet",
  "beetle",
  "before",
  "beg",
  "beggar",
  "begin",
  "behalf",
  "behave",
  "behind",
  "beige",
  "being",
  "belief",
  "bell",
  "belly",
  "belong",
  "below",
  "belt",
  "bench",
  "bend",
  "benign",
  "bent",
  "berlin",
  "berry",
  "berth",
  "beset",
  "beside",
  "best",
  "bestow",
  "bet",
  "beta",
  "betray",
  "better",
  "beware",
  "beyond",
  "bias",
  "biceps",
  "bicker",
  "bid",
  "big",
  "bigger",
  "bike",
  "bile",
  "bill",
  "bin",
  "binary",
  "bind",
  "biopsy",
  "birch",
  "bird",
  "birdie",
  "birth",
  "bishop",
  "bit",
  "bitch",
  "bite",
  "bitter",
  "black",
  "blade",
  "blame",
  "bland",
  "blast",
  "blaze",
  "bleak",
  "blend",
  "bless",
  "blew",
  "blind",
  "blink",
  "blip",
  "bliss",
  "blitz",
  "block",
  "blond",
  "blood",
  "bloody",
  "bloom",
  "blot",
  "blouse",
  "blow",
  "blue",
  "bluff",
  "blunt",
  "blur",
  "blush",
  "boar",
  "board",
  "boast",
  "boat",
  "bob",
  "bodily",
  "body",
  "bogus",
  "boil",
  "bold",
  "bolt",
  "bomb",
  "bombay",
  "bond",
  "bone",
  "bonn",
  "bonnet",
  "bonus",
  "bony",
  "book",
  "boom",
  "boost",
  "boot",
  "booth",
  "booze",
  "border",
  "bore",
  "borrow",
  "bosom",
  "boss",
  "boston",
  "both",
  "bother",
  "bottle",
  "bottom",
  "bought",
  "bounce",
  "bound",
  "bounty",
  "bout",
  "bovine",
  "bow",
  "bowel",
  "bowl",
  "box",
  "boy",
  "boyish",
  "brace",
  "brain",
  "brainy",
  "brake",
  "bran",
  "branch",
  "brand",
  "brandy",
  "brass",
  "brave",
  "bravo",
  "brazil",
  "breach",
  "bread",
  "break",
  "breast",
  "breath",
  "bred",
  "breed",
  "breeze",
  "brew",
  "bribe",
  "brick",
  "bride",
  "bridge",
  "brief",
  "bright",
  "brim",
  "brine",
  "bring",
  "brink",
  "brisk",
  "broad",
  "broke",
  "broken",
  "bronze",
  "brook",
  "broom",
  "brown",
  "bruise",
  "brush",
  "brutal",
  "brute",
  "bubble",
  "buck",
  "bucket",
  "buckle",
  "budget",
  "buffet",
  "buggy",
  "build",
  "bulb",
  "bulge",
  "bulk",
  "bulky",
  "bull",
  "bullet",
  "bully",
  "bump",
  "bumpy",
  "bunch",
  "bundle",
  "bunk",
  "bunny",
  "burden",
  "bureau",
  "burial",
  "buried",
  "burly",
  "burn",
  "burnt",
  "burrow",
  "burst",
  "bury",
  "bus",
  "bush",
  "bust",
  "bustle",
  "busy",
  "but",
  "butler",
  "butt",
  "butter",
  "button",
  "buy",
  "buyer",
  "buzz",
  "bye",
  "byte",
  "cab",
  "cabin",
  "cable",
  "cache",
  "cactus",
  "caesar",
  "cage",
  "cairo",
  "cajun",
  "cajole",
  "cake",
  "calf",
  "call",
  "caller",
  "calm",
  "calmly",
  "came",
  "camel",
  "camera",
  "camp",
  "campus",
  "can",
  "canada",
  "canal",
  "canary",
  "cancel",
  "cancer",
  "candid",
  "candle",
  "candy",
  "cane",
  "canine",
  "canoe",
  "canopy",
  "canvas",
  "canyon",
  "cap",
  "cape",
  "car",
  "carbon",
  "card",
  "care",
  "career",
  "caress",
  "cargo",
  "carl",
  "carnal",
  "carol",
  "carp",
  "carpet",
  "carrot",
  "carry",
  "cart",
  "cartel",
  "case",
  "cash",
  "cask",
  "cast",
  "castle",
  "casual",
  "cat",
  "catch",
  "cater",
  "cattle",
  "caught",
  "causal",
  "cause",
  "cave",
  "cease",
  "celery",
  "cell",
  "cellar",
  "celtic",
  "cement",
  "censor",
  "census",
  "cent",
  "cereal",
  "chain",
  "chair",
  "chalk",
  "chalky",
  "champ",
  "chance",
  "change",
  "chant",
  "chaos",
  "chap",
  "chapel",
  "charge",
  "charm",
  "chart",
  "chase",
  "chat",
  "cheap",
  "cheat",
  "check",
  "cheek",
  "cheeky",
  "cheer",
  "cheery",
  "cheese",
  "chef",
  "cheque",
  "cherry",
  "chess",
  "chest",
  "chew",
  "chic",
  "chick",
  "chief",
  "child",
  "chile",
  "chill",
  "chilly",
  "chin",
  "china",
  "chip",
  "choice",
  "choir",
  "choose",
  "chop",
  "choppy",
  "chord",
  "chorus",
  "chose",
  "chosen",
  "chris",
  "chrome",
  "chunk",
  "chunky",
  "church",
  "cider",
  "cigar",
  "cinema",
  "circa",
  "circle",
  "circus",
  "cite",
  "city",
  "civic",
  "civil",
  "clad",
  "claim",
  "clammy",
  "clan",
  "clap",
  "clash",
  "clasp",
  "class",
  "clause",
  "claw",
  "clay",
  "clean",
  "clear",
  "clergy",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climax",
  "climb",
  "clinch",
  "cling",
  "clinic",
  "clip",
  "cloak",
  "clock",
  "clone",
  "close",
  "closer",
  "closet",
  "cloth",
  "cloud",
  "cloudy",
  "clout",
  "clown",
  "club",
  "clue",
  "clumsy",
  "clung",
  "clutch",
  "coach",
  "coal",
  "coarse",
  "coast",
  "coat",
  "coax",
  "cobalt",
  "cobra",
  "coca",
  "cock",
  "cocoa",
  "code",
  "coffee",
  "coffin",
  "cohort",
  "coil",
  "coin",
  "coke",
  "cold",
  "collar",
  "colon",
  "colony",
  "colt",
  "column",
  "comb",
  "combat",
  "come",
  "comedy",
  "comic",
  "commit",
  "common",
  "compel",
  "comply",
  "concur",
  "cone",
  "confer",
  "congo",
  "consul",
  "convex",
  "convey",
  "convoy",
  "cook",
  "cool",
  "cope",
  "copper",
  "copy",
  "coral",
  "cord",
  "core",
  "cork",
  "corn",
  "corner",
  "corps",
  "corpse",
  "corpus",
  "cortex",
  "cosmic",
  "cosmos",
  "cost",
  "costly",
  "cotton",
  "couch",
  "cough",
  "could",
  "count",
  "county",
  "coup",
  "couple",
  "coupon",
  "course",
  "court",
  "cousin",
  "cove",
  "cover",
  "covert",
  "cow",
  "coward",
  "cowboy",
  "cozy",
  "crab",
  "crack",
  "cradle",
  "craft",
  "crafty",
  "crag",
  "crane",
  "crash",
  "crate",
  "crater",
  "crawl",
  "crazy",
  "creak",
  "cream",
  "creamy",
  "create",
  "credit",
  "creed",
  "creek",
  "creep",
  "creepy",
  "crept",
  "crest",
  "crew",
  "cried",
  "crime",
  "crisis",
  "crisp",
  "critic",
  "crook",
  "crop",
  "cross",
  "crow",
  "crowd",
  "crown",
  "crude",
  "cruel",
  "cruise",
  "crunch",
  "crush",
  "crust",
  "crux",
  "cry",
  "crypt",
  "cuba",
  "cube",
  "cubic",
  "cuckoo",
  "cuff",
  "cult",
  "cup",
  "curb",
  "cure",
  "curfew",
  "curl",
  "curry",
  "curse",
  "cursor",
  "curve",
  "cuss",
  "custom",
  "cut",
  "cute",
  "cycle",
  "cyclic",
  "cynic",
  "czech",
  "dad",
  "daddy",
  "dagger",
  "daily",
  "dairy",
  "daisy",
  "dale",
  "dam",
  "damage",
  "damp",
  "dampen",
  "dance",
  "danger",
  "danish",
  "dare",
  "dark",
  "darken",
  "darn",
  "dart",
  "dash",
  "data",
  "date",
  "david",
  "dawn",
  "day",
  "dead",
  "deadly",
  "deaf",
  "deal",
  "dealer",
  "dean",
  "dear",
  "death",
  "debate",
  "debit",
  "debris",
  "debt",
  "debtor",
  "decade",
  "decay",
  "decent",
  "decide",
  "deck",
  "decor",
  "decree",
  "deduce",
  "deed",
  "deep",
  "deeply",
  "deer",
  "defeat",
  "defect",
  "defend",
  "defer",
  "define",
  "defy",
  "degree",
  "deity",
  "delay",
  "delete",
  "delhi",
  "delta",
  "demand",
  "demise",
  "demo",
  "demure",
  "denial",
  "denote",
  "dense",
  "dental",
  "deny",
  "depart",
  "depend",
  "depict",
  "deploy",
  "depot",
  "depth",
  "deputy",
  "derive",
  "desert",
  "design",
  "desire",
  "desist",
  "desk",
  "detail",
  "detect",
  "deter",
  "detest",
  "detour",
  "device",
  "devise",
  "devoid",
  "devote",
  "devour",
  "dial",
  "diana",
  "diary",
  "dice",
  "dictum",
  "did",
  "die",
  "diesel",
  "diet",
  "differ",
  "dig",
  "digest",
  "digit",
  "dine",
  "dinghy",
  "dinner",
  "diode",
  "dip",
  "dire",
  "direct",
  "dirt",
  "dirty",
  "disc",
  "disco",
  "dish",
  "disk",
  "dismal",
  "dispel",
  "ditch",
  "dive",
  "divert",
  "divide",
  "divine",
  "dizzy",
  "docile",
  "dock",
  "doctor",
  "dog",
  "dogma",
  "dole",
  "doll",
  "dollar",
  "dolly",
  "domain",
  "dome",
  "domino",
  "donate",
  "done",
  "donkey",
  "donor",
  "doom",
  "door",
  "dorsal",
  "dose",
  "dot",
  "double",
  "doubt",
  "dough",
  "dour",
  "dove",
  "down",
  "dozen",
  "draft",
  "drag",
  "dragon",
  "drain",
  "drama",
  "drank",
  "draw",
  "drawer",
  "dread",
  "dream",
  "dreary",
  "dress",
  "drew",
  "dried",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "driver",
  "drop",
  "drove",
  "drown",
  "drug",
  "drum",
  "drunk",
  "dry",
  "dual",
  "duck",
  "duct",
  "due",
  "duel",
  "duet",
  "duke",
  "dull",
  "duly",
  "dumb",
  "dummy",
  "dump",
  "dune",
  "dung",
  "duress",
  "during",
  "dusk",
  "dust",
  "dusty",
  "dutch",
  "duty",
  "dwarf",
  "dwell",
  "dyer",
  "dying",
  "dynamo",
  "each",
  "eager",
  "eagle",
  "ear",
  "earl",
  "early",
  "earn",
  "earth",
  "ease",
  "easel",
  "easily",
  "east",
  "easter",
  "easy",
  "eat",
  "eaten",
  "eater",
  "echo",
  "eddy",
  "eden",
  "edge",
  "edible",
  "edict",
  "edit",
  "editor",
  "eel",
  "eerie",
  "eerily",
  "effect",
  "effort",
  "egg",
  "ego",
  "eight",
  "eighth",
  "eighty",
  "either",
  "elbow",
  "elder",
  "eldest",
  "elect",
  "eleven",
  "elicit",
  "elite",
  "else",
  "elude",
  "elves",
  "embark",
  "emblem",
  "embryo",
  "emerge",
  "emit",
  "empire",
  "employ",
  "empty",
  "enable",
  "enamel",
  "end",
  "endure",
  "enemy",
  "energy",
  "engage",
  "engine",
  "enjoy",
  "enlist",
  "enough",
  "ensure",
  "entail",
  "enter",
  "entire",
  "entry",
  "envoy",
  "envy",
  "enzyme",
  "epic",
  "epoch",
  "equal",
  "equate",
  "equip",
  "equity",
  "era",
  "erect",
  "eric",
  "erode",
  "erotic",
  "errant",
  "error",
  "escape",
  "escort",
  "essay",
  "essex",
  "estate",
  "esteem",
  "ethic",
  "ethnic",
  "europe",
  "evade",
  "eve",
  "even",
  "event",
  "ever",
  "every",
  "evict",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "exam",
  "exceed",
  "excel",
  "except",
  "excess",
  "excise",
  "excite",
  "excuse",
  "exempt",
  "exert",
  "exile",
  "exist",
  "exit",
  "exodus",
  "exotic",
  "expand",
  "expect",
  "expert",
  "expire",
  "export",
  "expose",
  "extend",
  "extra",
  "eye",
  "eyed",
  "fabric",
  "face",
  "facial",
  "fact",
  "factor",
  "fade",
  "fail",
  "faint",
  "fair",
  "fairly",
  "fairy",
  "faith",
  "fake",
  "falcon",
  "fall",
  "false",
  "falter",
  "fame",
  "family",
  "famine",
  "famous",
  "fan",
  "fancy",
  "far",
  "farce",
  "fare",
  "farm",
  "farmer",
  "fast",
  "fasten",
  "faster",
  "fat",
  "fatal",
  "fate",
  "father",
  "fatty",
  "fault",
  "faulty",
  "fauna",
  "fear",
  "feast",
  "feat",
  "fed",
  "fee",
  "feeble",
  "feed",
  "feel",
  "feet",
  "fell",
  "fellow",
  "felt",
  "female",
  "fence",
  "fend",
  "ferry",
  "fetal",
  "fetch",
  "feudal",
  "fever",
  "few",
  "fewer",
  "fiasco",
  "fiddle",
  "field",
  "fiend",
  "fierce",
  "fiery",
  "fifth",
  "fifty",
  "fig",
  "fight",
  "figure",
  "file",
  "fill",
  "filled",
  "filler",
  "film",
  "filter",
  "filth",
  "filthy",
  "final",
  "finale",
  "find",
  "fine",
  "finery",
  "finger",
  "finish",
  "finite",
  "fire",
  "firm",
  "firmly",
  "first",
  "fiscal",
  "fish",
  "fisher",
  "fist",
  "fit",
  "fitful",
  "five",
  "fix",
  "flag",
  "flair",
  "flak",
  "flame",
  "flank",
  "flap",
  "flare",
  "flash",
  "flask",
  "flat",
  "flavor",
  "flaw",
  "fled",
  "flee",
  "fleece",
  "fleet",
  "flesh",
  "fleshy",
  "flew",
  "flick",
  "flight",
  "flimsy",
  "flint",
  "flirt",
  "float",
  "flock",
  "flood",
  "floor",
  "floppy",
  "flora",
  "floral",
  "flour",
  "flow",
  "flower",
  "fluent",
  "fluffy",
  "fluid",
  "flung",
  "flurry",
  "flush",
  "flute",
  "flux",
  "fly",
  "flyer",
  "foal",
  "foam",
  "focal",
  "focus",
  "fog",
  "foil",
  "fold",
  "folk",
  "follow",
  "folly",
  "fond",
  "fondly",
  "font",
  "food",
  "fool",
  "foot",
  "for",
  "forbid",
  "force",
  "ford",
  "forest",
  "forge",
  "forget",
  "fork",
  "form",
  "formal",
  "format",
  "former",
  "fort",
  "forth",
  "forty",
  "forum",
  "fossil",
  "foster",
  "foul",
  "found",
  "four",
  "fourth",
  "fox",
  "foyer",
  "frail",
  "frame",
  "franc",
  "france",
  "frank",
  "fraud",
  "fred",
  "free",
  "freed",
  "freely",
  "freeze",
  "french",
  "frenzy",
  "fresh",
  "friar",
  "friday",
  "fridge",
  "fried",
  "friend",
  "fright",
  "fringe",
  "frock",
  "frog",
  "from",
  "front",
  "frost",
  "frosty",
  "frown",
  "frozen",
  "frugal",
  "fruit",
  "fry",
  "fudge",
  "fuel",
  "full",
  "fully",
  "fumes",
  "fun",
  "fund",
  "funny",
  "fur",
  "furry",
  "fury",
  "fuse",
  "fusion",
  "fuss",
  "fussy",
  "futile",
  "future",
  "fuzzy",
  "gadget",
  "gain",
  "gala",
  "galaxy",
  "gale",
  "gall",
  "galley",
  "gallon",
  "gallop",
  "gamble",
  "game",
  "gamma",
  "gandhi",
  "gang",
  "gap",
  "garage",
  "garden",
  "garlic",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaunt",
  "gave",
  "gaze",
  "gear",
  "geese",
  "gem",
  "gemini",
  "gender",
  "gene",
  "geneva",
  "genial",
  "genius",
  "genre",
  "gentle",
  "gently",
  "gentry",
  "genus",
  "george",
  "germ",
  "get",
  "ghetto",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "gill",
  "gilt",
  "ginger",
  "girl",
  "give",
  "given",
  "glad",
  "glade",
  "glance",
  "gland",
  "glare",
  "glass",
  "glassy",
  "gleam",
  "glee",
  "glide",
  "global",
  "globe",
  "gloom",
  "gloomy",
  "gloria",
  "glory",
  "gloss",
  "glossy",
  "glove",
  "glow",
  "glue",
  "gnat",
  "gnu",
  "goal",
  "goat",
  "gold",
  "golden",
  "golf",
  "gone",
  "gong",
  "goo",
  "good",
  "goose",
  "gore",
  "gorge",
  "gory",
  "gosh",
  "gospel",
  "gossip",
  "got",
  "gothic",
  "govern",
  "gown",
  "grab",
  "grace",
  "grade",
  "grail",
  "grain",
  "grand",
  "grant",
  "grape",
  "graph",
  "grasp",
  "grass",
  "grassy",
  "grate",
  "grave",
  "gravel",
  "gravy",
  "grease",
  "greasy",
  "great",
  "greece",
  "greed",
  "greedy",
  "greek",
  "green",
  "greet",
  "grew",
  "grey",
  "grid",
  "grief",
  "grill",
  "grim",
  "grin",
  "grind",
  "grip",
  "grit",
  "gritty",
  "groan",
  "groin",
  "groom",
  "groove",
  "gross",
  "ground",
  "group",
  "grove",
  "grow",
  "grown",
  "growth",
  "grudge",
  "grunt",
  "guard",
  "guess",
  "guest",
  "guide",
  "guild",
  "guilt",
  "guilty",
  "guise",
  "guitar",
  "gulf",
  "gully",
  "gun",
  "gunman",
  "guru",
  "gut",
  "guy",
  "gypsy",
  "habit",
  "hack",
  "had",
  "hail",
  "hair",
  "hairy",
  "haiti",
  "hale",
  "half",
  "hall",
  "halt",
  "hamlet",
  "hammer",
  "hand",
  "handle",
  "handy",
  "hang",
  "hangar",
  "hanoi",
  "happen",
  "happy",
  "harass",
  "harbor",
  "hard",
  "harder",
  "hardly",
  "hare",
  "harem",
  "harm",
  "harp",
  "harry",
  "harsh",
  "has",
  "hash",
  "hassle",
  "haste",
  "hasten",
  "hasty",
  "hat",
  "hatch",
  "hate",
  "haul",
  "haunt",
  "havana",
  "have",
  "haven",
  "havoc",
  "hawaii",
  "hawk",
  "hay",
  "hazard",
  "haze",
  "hazel",
  "hazy",
  "head",
  "heal",
  "health",
  "heap",
  "hear",
  "heard",
  "heart",
  "hearth",
  "hearty",
  "heat",
  "heater",
  "heaven",
  "heavy",
  "hebrew",
  "heck",
  "hectic",
  "hedge",
  "heel",
  "hefty",
  "height",
  "heir",
  "held",
  "helium",
  "helix",
  "hell",
  "hello",
  "helm",
  "helmet",
  "help",
  "hemp",
  "hence",
  "henry",
  "her",
  "herald",
  "herb",
  "herd",
  "here",
  "hereby",
  "hermes",
  "hernia",
  "hero",
  "heroic",
  "heroin",
  "hey",
  "heyday",
  "hick",
  "hidden",
  "hide",
  "high",
  "higher",
  "highly",
  "hill",
  "him",
  "hind",
  "hinder",
  "hint",
  "hippie",
  "hire",
  "his",
  "hiss",
  "hit",
  "hive",
  "hoard",
  "hoarse",
  "hobby",
  "hockey",
  "hold",
  "holder",
  "hole",
  "hollow",
  "holly",
  "holy",
  "home",
  "honest",
  "honey",
  "hood",
  "hook",
  "hope",
  "horn",
  "horrid",
  "horror",
  "horse",
  "hose",
  "host",
  "hot",
  "hotel",
  "hound",
  "hour",
  "house",
  "hover",
  "how",
  "huge",
  "hull",
  "human",
  "humane",
  "humble",
  "humid",
  "hung",
  "hunger",
  "hungry",
  "hunt",
  "hurdle",
  "hurl",
  "hurry",
  "hurt",
  "hush",
  "hut",
  "hybrid",
  "hymn",
  "hyphen",
  "ice",
  "icing",
  "icon",
  "idaho",
  "idea",
  "ideal",
  "idiom",
  "idiot",
  "idle",
  "idly",
  "idol",
  "ignite",
  "ignore",
  "ill",
  "image",
  "immune",
  "impact",
  "imply",
  "import",
  "impose",
  "inca",
  "incest",
  "inch",
  "income",
  "incur",
  "indeed",
  "index",
  "india",
  "indian",
  "indoor",
  "induce",
  "inept",
  "inert",
  "infant",
  "infect",
  "infer",
  "influx",
  "inform",
  "inject",
  "injure",
  "injury",
  "ink",
  "inlaid",
  "inland",
  "inlet",
  "inmate",
  "inn",
  "innate",
  "inner",
  "input",
  "insane",
  "insect",
  "insert",
  "inset",
  "inside",
  "insist",
  "insult",
  "insure",
  "intact",
  "intake",
  "intend",
  "inter",
  "into",
  "invade",
  "invent",
  "invest",
  "invite",
  "invoke",
  "inward",
  "iowa",
  "iran",
  "iraq",
  "irish",
  "iron",
  "ironic",
  "irony",
  "isaac",
  "isabel",
  "island",
  "isle",
  "israel",
  "issue",
  "italy",
  "itch",
  "item",
  "itself",
  "ivan",
  "ivory",
  "jack",
  "jacket",
  "jacob",
  "jade",
  "jaguar",
  "jail",
  "james",
  "jane",
  "japan",
  "jargon",
  "java",
  "jaw",
  "jazz",
  "jeep",
  "jelly",
  "jerky",
  "jest",
  "jet",
  "jewel",
  "jewish",
  "jim",
  "job",
  "jock",
  "jockey",
  "joe",
  "john",
  "join",
  "joint",
  "joke",
  "jolly",
  "jolt",
  "jordan",
  "joseph",
  "joy",
  "joyful",
  "joyous",
  "judge",
  "judy",
  "juice",
  "juicy",
  "july",
  "jumble",
  "jumbo",
  "jump",
  "june",
  "jungle",
  "junior",
  "junk",
  "junta",
  "jury",
  "just",
  "kansas",
  "karate",
  "karl",
  "keel",
  "keen",
  "keep",
  "keeper",
  "kenya",
  "kept",
  "kernel",
  "kettle",
  "key",
  "khaki",
  "kick",
  "kid",
  "kidnap",
  "kidney",
  "kill",
  "killer",
  "kin",
  "kind",
  "kindly",
  "king",
  "kiss",
  "kite",
  "kitten",
  "knack",
  "knee",
  "kneel",
  "knew",
  "knife",
  "knight",
  "knit",
  "knob",
  "knock",
  "knot",
  "know",
  "known",
  "koran",
  "korea",
  "kuwait",
  "label",
  "lace",
  "lack",
  "lad",
  "ladder",
  "laden",
  "lady",
  "lagoon",
  "laity",
  "lake",
  "lamb",
  "lame",
  "lamp",
  "lance",
  "land",
  "lane",
  "lap",
  "lapse",
  "large",
  "larval",
  "laser",
  "last",
  "latch",
  "late",
  "lately",
  "latent",
  "later",
  "latest",
  "latin",
  "latter",
  "laugh",
  "launch",
  "lava",
  "lavish",
  "law",
  "lawful",
  "lawn",
  "lawyer",
  "lay",
  "layer",
  "layman",
  "lazy",
  "lead",
  "leader",
  "leaf",
  "leafy",
  "league",
  "leak",
  "leaky",
  "lean",
  "leap",
  "learn",
  "lease",
  "leash",
  "least",
  "leave",
  "led",
  "ledge",
  "left",
  "leg",
  "legacy",
  "legal",
  "legend",
  "legion",
  "lemon",
  "lend",
  "length",
  "lens",
  "lent",
  "leo",
  "leper",
  "lesion",
  "less",
  "lessen",
  "lesser",
  "lesson",
  "lest",
  "let",
  "lethal",
  "letter",
  "level",
  "lever",
  "levy",
  "lewis",
  "liable",
  "liar",
  "libel",
  "libya",
  "lice",
  "lick",
  "lid",
  "lie",
  "lied",
  "lier",
  "life",
  "lift",
  "light",
  "like",
  "likely",
  "limb",
  "lime",
  "limit",
  "limp",
  "line",
  "linear",
  "linen",
  "linger",
  "link",
  "lint",
  "lion",
  "lip",
  "liquid",
  "liquor",
  "list",
  "listen",
  "lit",
  "live",
  "lively",
  "liver",
  "liz",
  "lizard",
  "load",
  "loaf",
  "loan",
  "lobby",
  "lobe",
  "local",
  "locate",
  "lock",
  "locus",
  "lodge",
  "loft",
  "lofty",
  "log",
  "logic",
  "logo",
  "london",
  "lone",
  "lonely",
  "long",
  "longer",
  "look",
  "loop",
  "loose",
  "loosen",
  "loot",
  "lord",
  "lorry",
  "lose",
  "loss",
  "lost",
  "lot",
  "lotion",
  "lotus",
  "loud",
  "loudly",
  "lounge",
  "lousy",
  "love",
  "lovely",
  "lover",
  "low",
  "lower",
  "lowest",
  "loyal",
  "lucid",
  "luck",
  "lucky",
  "lucy",
  "lull",
  "lump",
  "lumpy",
  "lunacy",
  "lunar",
  "lunch",
  "lung",
  "lure",
  "lurid",
  "lush",
  "lust",
  "lute",
  "luther",
  "luxury",
  "lying",
  "lymph",
  "lynch",
  "lyric",
  "macho",
  "macro",
  "mad",
  "madam",
  "made",
  "mafia",
  "magic",
  "magma",
  "magnet",
  "magnum",
  "magpie",
  "maid",
  "maiden",
  "mail",
  "main",
  "mainly",
  "major",
  "make",
  "maker",
  "male",
  "malice",
  "mall",
  "malt",
  "mammal",
  "manage",
  "mane",
  "mania",
  "manic",
  "manner",
  "manor",
  "mantle",
  "manual",
  "manure",
  "many",
  "map",
  "maple",
  "marble",
  "march",
  "mare",
  "margin",
  "maria",
  "marina",
  "mark",
  "market",
  "marry",
  "mars",
  "marsh",
  "martin",
  "martyr",
  "mary",
  "mask",
  "mason",
  "mass",
  "mast",
  "master",
  "mat",
  "match",
  "mate",
  "matrix",
  "matter",
  "mature",
  "maxim",
  "may",
  "maybe",
  "mayor",
  "maze",
  "mead",
  "meadow",
  "meal",
  "mean",
  "meant",
  "meat",
  "medal",
  "media",
  "median",
  "medic",
  "medium",
  "meet",
  "mellow",
  "melody",
  "melon",
  "melt",
  "member",
  "memo",
  "memory",
  "menace",
  "mend",
  "mental",
  "mentor",
  "menu",
  "mercy",
  "mere",
  "merely",
  "merge",
  "merger",
  "merit",
  "merry",
  "mesh",
  "mess",
  "messy",
  "met",
  "metal",
  "meter",
  "method",
  "methyl",
  "metric",
  "metro",
  "mexico",
  "miami",
  "mickey",
  "mid",
  "midday",
  "middle",
  "midst",
  "midway",
  "might",
  "mighty",
  "mild",
  "mildew",
  "mile",
  "milk",
  "milky",
  "mill",
  "mimic",
  "mince",
  "mind",
  "mine",
  "mini",
  "mink",
  "minor",
  "mint",
  "minus",
  "minute",
  "mire",
  "mirror",
  "mirth",
  "misery",
  "miss",
  "mist",
  "misty",
  "mite",
  "mix",
  "moan",
  "moat",
  "mob",
  "mobile",
  "mock",
  "mode",
  "model",
  "modem",
  "modern",
  "modest",
  "modify",
  "module",
  "moist",
  "molar",
  "mold",
  "mole",
  "molten",
  "moment",
  "monday",
  "money",
  "monk",
  "monkey",
  "month",
  "mood",
  "moody",
  "moon",
  "moor",
  "moral",
  "morale",
  "morbid",
  "more",
  "morgue",
  "mortal",
  "mortar",
  "mosaic",
  "moscow",
  "moses",
  "mosque",
  "moss",
  "most",
  "mostly",
  "moth",
  "mother",
  "motion",
  "motive",
  "motor",
  "mount",
  "mourn",
  "mouse",
  "mouth",
  "move",
  "movie",
  "mrs",
  "much",
  "muck",
  "mucus",
  "mud",
  "muddle",
  "muddy",
  "mule",
  "mummy",
  "munich",
  "murder",
  "murky",
  "murmur",
  "muscle",
  "museum",
  "music",
  "mussel",
  "must",
  "mutant",
  "mute",
  "mutiny",
  "mutter",
  "mutton",
  "mutual",
  "muzzle",
  "myopic",
  "myriad",
  "myself",
  "mystic",
  "myth",
  "nadir",
  "nail",
  "naked",
  "name",
  "namely",
  "nape",
  "napkin",
  "naples",
  "narrow",
  "nasal",
  "nasty",
  "nathan",
  "nation",
  "native",
  "nature",
  "nausea",
  "naval",
  "nave",
  "navy",
  "near",
  "nearer",
  "nearly",
  "neat",
  "neatly",
  "neck",
  "need",
  "needle",
  "needy",
  "negate",
  "neon",
  "nepal",
  "nephew",
  "nerve",
  "nest",
  "net",
  "neural",
  "never",
  "newly",
  "next",
  "nice",
  "nicely",
  "niche",
  "nickel",
  "niece",
  "night",
  "nile",
  "nimble",
  "nine",
  "ninety",
  "ninth",
  "nobel",
  "noble",
  "nobody",
  "node",
  "noise",
  "noisy",
  "none",
  "noon",
  "nor",
  "norm",
  "normal",
  "north",
  "norway",
  "nose",
  "nosy",
  "not",
  "note",
  "notice",
  "notify",
  "notion",
  "noun",
  "novel",
  "novice",
  "now",
  "nozzle",
  "null",
  "numb",
  "number",
  "nurse",
  "nut",
  "nylon",
  "nymph",
  "oak",
  "oar",
  "oasis",
  "oath",
  "obese",
  "obey",
  "object",
  "oblige",
  "oboe",
  "obtain",
  "obtuse",
  "occult",
  "occupy",
  "occur",
  "ocean",
  "octave",
  "odd",
  "off",
  "offend",
  "offer",
  "office",
  "offset",
  "often",
  "ohio",
  "oil",
  "oily",
  "okay",
  "old",
  "older",
  "oldest",
  "olive",
  "omega",
  "omen",
  "omit",
  "once",
  "one",
  "onion",
  "only",
  "onset",
  "onto",
  "onus",
  "onward",
  "opaque",
  "open",
  "openly",
  "opera",
  "opium",
  "oppose",
  "optic",
  "option",
  "oracle",
  "oral",
  "orange",
  "orbit",
  "orchid",
  "ordeal",
  "order",
  "organ",
  "orgasm",
  "orient",
  "origin",
  "ornate",
  "orphan",
  "oscar",
  "other",
  "otter",
  "ought",
  "ounce",
  "our",
  "out",
  "outer",
  "output",
  "outset",
  "oval",
  "oven",
  "over",
  "overt",
  "owe",
  "owing",
  "owl",
  "own",
  "owner",
  "oxford",
  "oxide",
  "oxygen",
  "oyster",
  "ozone",
  "pace",
  "pack",
  "packet",
  "pact",
  "pad",
  "paddle",
  "paddy",
  "pagan",
  "page",
  "paid",
  "pain",
  "paint",
  "pair",
  "palace",
  "pale",
  "palm",
  "pan",
  "panama",
  "panel",
  "panic",
  "papa",
  "papal",
  "paper",
  "parade",
  "parcel",
  "pardon",
  "parent",
  "paris",
  "parish",
  "park",
  "parody",
  "parrot",
  "part",
  "partly",
  "party",
  "pascal",
  "pass",
  "past",
  "paste",
  "pastel",
  "pastor",
  "pastry",
  "pat",
  "patch",
  "patent",
  "path",
  "patio",
  "patrol",
  "patron",
  "paul",
  "pause",
  "pave",
  "paw",
  "pawn",
  "pay",
  "peace",
  "peach",
  "peak",
  "pear",
  "pearl",
  "pedal",
  "peel",
  "peer",
  "peking",
  "pelvic",
  "pelvis",
  "pen",
  "penal",
  "pence",
  "pencil",
  "penny",
  "people",
  "pepper",
  "per",
  "perch",
  "peril",
  "period",
  "perish",
  "permit",
  "person",
  "peru",
  "pest",
  "pet",
  "peter",
  "petite",
  "petrol",
  "petty",
  "phase",
  "philip",
  "phone",
  "photo",
  "phrase",
  "piano",
  "pick",
  "picket",
  "picnic",
  "pie",
  "piece",
  "pier",
  "pierce",
  "piety",
  "pig",
  "pigeon",
  "piggy",
  "pike",
  "pile",
  "pill",
  "pillar",
  "pillow",
  "pilot",
  "pin",
  "pinch",
  "pine",
  "pink",
  "pint",
  "pious",
  "pipe",
  "pirate",
  "piss",
  "pistol",
  "piston",
  "pit",
  "pitch",
  "pity",
  "pivot",
  "pixel",
  "pizza",
  "place",
  "placid",
  "plague",
  "plain",
  "plan",
  "plane",
  "planet",
  "plank",
  "plant",
  "plasma",
  "plate",
  "play",
  "player",
  "plea",
  "plead",
  "please",
  "pledge",
  "plenty",
  "plight",
  "plot",
  "plough",
  "ploy",
  "plug",
  "plum",
  "plump",
  "plunge",
  "plural",
  "plus",
  "plush",
  "pocket",
  "poem",
  "poet",
  "poetic",
  "poetry",
  "point",
  "poison",
  "poland",
  "polar",
  "pole",
  "police",
  "policy",
  "polish",
  "polite",
  "poll",
  "pollen",
  "polo",
  "pond",
  "ponder",
  "pony",
  "pool",
  "poor",
  "poorly",
  "pop",
  "poppy",
  "pore",
  "pork",
  "port",
  "portal",
  "pose",
  "posh",
  "post",
  "postal",
  "pot",
  "potato",
  "potent",
  "pouch",
  "pound",
  "pour",
  "powder",
  "power",
  "praise",
  "pray",
  "prayer",
  "preach",
  "prefer",
  "prefix",
  "press",
  "pretty",
  "price",
  "pride",
  "priest",
  "primal",
  "prime",
  "prince",
  "print",
  "prior",
  "prism",
  "prison",
  "privy",
  "prize",
  "probe",
  "profit",
  "prompt",
  "prone",
  "proof",
  "propel",
  "proper",
  "prose",
  "proton",
  "proud",
  "prove",
  "proven",
  "proxy",
  "prune",
  "pry",
  "psalm",
  "pseudo",
  "psyche",
  "pub",
  "public",
  "puff",
  "pull",
  "pulp",
  "pulpit",
  "pulsar",
  "pulse",
  "pump",
  "punch",
  "punish",
  "punk",
  "pupil",
  "puppet",
  "puppy",
  "pure",
  "purely",
  "purge",
  "purify",
  "purple",
  "purse",
  "pursue",
  "push",
  "pushy",
  "put",
  "putt",
  "puzzle",
  "quaint",
  "quake",
  "quarry",
  "quart",
  "quartz",
  "quebec",
  "queen",
  "queer",
  "query",
  "quest",
  "queue",
  "quick",
  "quid",
  "quiet",
  "quilt",
  "quirk",
  "quit",
  "quite",
  "quiver",
  "quiz",
  "quota",
  "quote",
  "rabbit",
  "race",
  "racial",
  "racism",
  "rack",
  "racket",
  "radar",
  "radio",
  "radish",
  "radius",
  "raffle",
  "raft",
  "rage",
  "raid",
  "rail",
  "rain",
  "rainy",
  "raise",
  "rake",
  "rally",
  "ramp",
  "random",
  "range",
  "rank",
  "ransom",
  "rape",
  "rapid",
  "rare",
  "rarely",
  "rarity",
  "rash",
  "rat",
  "rate",
  "rather",
  "ratify",
  "ratio",
  "rattle",
  "rave",
  "raven",
  "raw",
  "ray",
  "razor",
  "reach",
  "react",
  "read",
  "reader",
  "ready",
  "real",
  "really",
  "realm",
  "reap",
  "rear",
  "reason",
  "rebel",
  "recall",
  "recent",
  "recess",
  "recipe",
  "reckon",
  "record",
  "recoup",
  "rector",
  "red",
  "redeem",
  "redo",
  "reduce",
  "reed",
  "reef",
  "reek",
  "refer",
  "reform",
  "refuge",
  "refuse",
  "regal",
  "regard",
  "regent",
  "regime",
  "region",
  "regret",
  "reign",
  "reject",
  "relate",
  "relax",
  "relay",
  "relic",
  "relief",
  "relish",
  "rely",
  "remain",
  "remark",
  "remedy",
  "remind",
  "remit",
  "remote",
  "remove",
  "renal",
  "render",
  "rent",
  "rental",
  "repair",
  "repeal",
  "repeat",
  "repent",
  "reply",
  "report",
  "rescue",
  "resent",
  "reside",
  "resign",
  "resin",
  "resist",
  "resort",
  "rest",
  "result",
  "resume",
  "retail",
  "retain",
  "retina",
  "retire",
  "return",
  "reveal",
  "review",
  "revise",
  "revive",
  "revolt",
  "reward",
  "rex",
  "rhine",
  "rhino",
  "rhyme",
  "rhythm",
  "ribbon",
  "rice",
  "rich",
  "rick",
  "rid",
  "ride",
  "rider",
  "ridge",
  "rife",
  "rifle",
  "rift",
  "right",
  "rigid",
  "rile",
  "rim",
  "ring",
  "rinse",
  "riot",
  "ripe",
  "ripen",
  "ripple",
  "rise",
  "risk",
  "risky",
  "rite",
  "ritual",
  "ritz",
  "rival",
  "river",
  "road",
  "roar",
  "roast",
  "rob",
  "robe",
  "robert",
  "robin",
  "robot",
  "robust",
  "rock",
  "rocket",
  "rocky",
  "rod",
  "rode",
  "rodent",
  "rogue",
  "role",
  "roll",
  "roman",
  "rome",
  "roof",
  "room",
  "root",
  "rope",
  "rose",
  "rosy",
  "rot",
  "rotate",
  "rotor",
  "rotten",
  "rouge",
  "rough",
  "round",
  "route",
  "rover",
  "row",
  "royal",
  "rub",
  "rubber",
  "rubble",
  "ruby",
  "rudder",
  "rude",
  "rug",
  "rugby",
  "ruin",
  "rule",
  "ruler",
  "rumble",
  "rump",
  "run",
  "rune",
  "rung",
  "runway",
  "rural",
  "rush",
  "russia",
  "rust",
  "rustic",
  "rusty",
  "sack",
  "sacred",
  "sad",
  "saddle",
  "sadism",
  "sadly",
  "safari",
  "safe",
  "safely",
  "safer",
  "safety",
  "saga",
  "sage",
  "sahara",
  "said",
  "sail",
  "sailor",
  "saint",
  "sake",
  "salad",
  "salary",
  "sale",
  "saline",
  "saliva",
  "salmon",
  "saloon",
  "salt",
  "salty",
  "salute",
  "sam",
  "same",
  "sample",
  "sand",
  "sandy",
  "sane",
  "sash",
  "satin",
  "satire",
  "saturn",
  "sauce",
  "saucer",
  "saudi",
  "sauna",
  "savage",
  "save",
  "saw",
  "say",
  "scale",
  "scalp",
  "scan",
  "scant",
  "scar",
  "scarce",
  "scare",
  "scarf",
  "scary",
  "scene",
  "scenic",
  "scent",
  "school",
  "scold",
  "scope",
  "score",
  "scorn",
  "scotch",
  "scott",
  "scout",
  "scrap",
  "scrape",
  "scream",
  "screen",
  "screw",
  "script",
  "scroll",
  "scrub",
  "scum",
  "sea",
  "seal",
  "seam",
  "seaman",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "sect",
  "sector",
  "secure",
  "see",
  "seed",
  "seeing",
  "seek",
  "seem",
  "seize",
  "seldom",
  "select",
  "self",
  "sell",
  "seller",
  "semi",
  "senate",
  "send",
  "senile",
  "senior",
  "sense",
  "sensor",
  "sent",
  "sentry",
  "seoul",
  "sequel",
  "serene",
  "serial",
  "series",
  "sermon",
  "serum",
  "serve",
  "server",
  "set",
  "settle",
  "seven",
  "severe",
  "sew",
  "sewage",
  "shabby",
  "shade",
  "shadow",
  "shady",
  "shaft",
  "shaggy",
  "shah",
  "shake",
  "shaky",
  "shall",
  "sham",
  "shame",
  "shape",
  "share",
  "shark",
  "sharp",
  "shawl",
  "she",
  "shear",
  "sheen",
  "sheep",
  "sheer",
  "sheet",
  "shelf",
  "shell",
  "sherry",
  "shield",
  "shift",
  "shine",
  "shiny",
  "ship",
  "shire",
  "shirk",
  "shirt",
  "shiver",
  "shock",
  "shoe",
  "shook",
  "shoot",
  "shop",
  "shore",
  "short",
  "shot",
  "should",
  "shout",
  "show",
  "shower",
  "shrank",
  "shrewd",
  "shrill",
  "shrimp",
  "shrine",
  "shrink",
  "shrub",
  "shrug",
  "shut",
  "shy",
  "shyly",
  "sick",
  "side",
  "siege",
  "sigh",
  "sight",
  "sigma",
  "sign",
  "signal",
  "silent",
  "silk",
  "silken",
  "silky",
  "sill",
  "silly",
  "silo",
  "silver",
  "simple",
  "simply",
  "since",
  "sinful",
  "sing",
  "singer",
  "single",
  "sink",
  "sir",
  "sire",
  "siren",
  "sister",
  "sit",
  "site",
  "sitter",
  "six",
  "sixth",
  "sixty",
  "size",
  "sketch",
  "skill",
  "skin",
  "skinny",
  "skip",
  "skirt",
  "skull",
  "sky",
  "slab",
  "slack",
  "slain",
  "slam",
  "slang",
  "slap",
  "slat",
  "slate",
  "slave",
  "sleek",
  "sleep",
  "sleepy",
  "sleeve",
  "slice",
  "slick",
  "slid",
  "slide",
  "slight",
  "slim",
  "slimy",
  "sling",
  "slip",
  "slit",
  "slogan",
  "slope",
  "sloppy",
  "slot",
  "slow",
  "slowly",
  "slug",
  "slum",
  "slump",
  "smack",
  "small",
  "smart",
  "smash",
  "smear",
  "smell",
  "smelly",
  "smelt",
  "smile",
  "smite",
  "smoke",
  "smoky",
  "smooth",
  "smug",
  "snack",
  "snail",
  "snake",
  "snap",
  "snatch",
  "sneak",
  "snow",
  "snowy",
  "snug",
  "soak",
  "soap",
  "sober",
  "soccer",
  "social",
  "sock",
  "socket",
  "socks",
  "soda",
  "sodden",
  "sodium",
  "sofa",
  "soft",
  "soften",
  "softly",
  "soggy",
  "soil",
  "solar",
  "sold",
  "sole",
  "solely",
  "solemn",
  "solid",
  "solo",
  "solve",
  "some",
  "son",
  "sonar",
  "sonata",
  "song",
  "sonic",
  "sony",
  "soon",
  "sooner",
  "soot",
  "soothe",
  "sordid",
  "sore",
  "sorrow",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "sour",
  "source",
  "soviet",
  "sow",
  "space",
  "spade",
  "spain",
  "span",
  "spare",
  "spark",
  "sparse",
  "spasm",
  "spat",
  "spate",
  "speak",
  "spear",
  "speech",
  "speed",
  "speedy",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spicy",
  "spider",
  "spiky",
  "spill",
  "spin",
  "spinal",
  "spine",
  "spiral",
  "spirit",
  "spit",
  "spite",
  "splash",
  "split",
  "spoil",
  "spoke",
  "sponge",
  "spoon",
  "sport",
  "spot",
  "spouse",
  "spray",
  "spread",
  "spree",
  "spring",
  "sprint",
  "spur",
  "squad",
  "square",
  "squash",
  "squat",
  "squid",
  "stab",
  "stable",
  "stack",
  "staff",
  "stage",
  "stain",
  "stair",
  "stairs",
  "stake",
  "stale",
  "stall",
  "stamp",
  "stance",
  "stand",
  "staple",
  "star",
  "starch",
  "stare",
  "stark",
  "start",
  "starve",
  "state",
  "static",
  "statue",
  "status",
  "stay",
  "stead",
  "steady",
  "steak",
  "steal",
  "steam",
  "steel",
  "steep",
  "steer",
  "stem",
  "stench",
  "step",
  "stereo",
  "stern",
  "stew",
  "stick",
  "sticky",
  "stiff",
  "stifle",
  "stigma",
  "still",
  "sting",
  "stint",
  "stir",
  "stitch",
  "stock",
  "stocky",
  "stone",
  "stony",
  "stool",
  "stop",
  "store",
  "storm",
  "stormy",
  "story",
  "stout",
  "stove",
  "stow",
  "strain",
  "strait",
  "strand",
  "strap",
  "strata",
  "straw",
  "stray",
  "streak",
  "stream",
  "street",
  "stress",
  "strict",
  "stride",
  "strife",
  "strike",
  "string",
  "strip",
  "stripe",
  "strive",
  "stroke",
  "stroll",
  "strong",
  "stud",
  "studio",
  "study",
  "stuff",
  "stuffy",
  "stunt",
  "stupid",
  "sturdy",
  "style",
  "submit",
  "subtle",
  "subtly",
  "suburb",
  "such",
  "sudden",
  "sue",
  "suez",
  "suffer",
  "sugar",
  "suit",
  "suite",
  "suitor",
  "sullen",
  "sultan",
  "sum",
  "summer",
  "summit",
  "summon",
  "sun",
  "sunday",
  "sunny",
  "sunset",
  "super",
  "superb",
  "supper",
  "supple",
  "supply",
  "sure",
  "surely",
  "surf",
  "surge",
  "survey",
  "suture",
  "swamp",
  "swan",
  "swap",
  "swarm",
  "sway",
  "swear",
  "sweat",
  "sweaty",
  "sweden",
  "sweep",
  "sweet",
  "swell",
  "swift",
  "swim",
  "swine",
  "swing",
  "swirl",
  "swiss",
  "switch",
  "sword",
  "swore",
  "sydney",
  "symbol",
  "synod",
  "syntax",
  "syria",
  "syrup",
  "system",
  "table",
  "tablet",
  "taboo",
  "tacit",
  "tackle",
  "tact",
  "tactic",
  "tail",
  "tailor",
  "taiwan",
  "take",
  "tale",
  "talent",
  "talk",
  "tall",
  "tally",
  "tame",
  "tampa",
  "tan",
  "tandem",
  "tangle",
  "tank",
  "tap",
  "tape",
  "target",
  "tariff",
  "tarp",
  "tart",
  "tarzan",
  "task",
  "taste",
  "tasty",
  "tattoo",
  "taurus",
  "taut",
  "tavern",
  "tax",
  "taxi",
  "tea",
  "teach",
  "teak",
  "team",
  "tear",
  "tease",
  "tech",
  "teeth",
  "tell",
  "temper",
  "temple",
  "tempo",
  "tempt",
  "ten",
  "tenant",
  "tend",
  "tender",
  "tendon",
  "tennis",
  "tenor",
  "tense",
  "tent",
  "tenth",
  "tenure",
  "teresa",
  "term",
  "terror",
  "terse",
  "test",
  "texas",
  "text",
  "thank",
  "thaw",
  "them",
  "theme",
  "thence",
  "theory",
  "there",
  "these",
  "thesis",
  "they",
  "thick",
  "thief",
  "thigh",
  "thin",
  "thing",
  "think",
  "third",
  "thirst",
  "thirty",
  "this",
  "thomas",
  "thorn",
  "those",
  "though",
  "thread",
  "threat",
  "three",
  "thrill",
  "thrive",
  "throat",
  "throne",
  "throng",
  "throw",
  "thrust",
  "thud",
  "thug",
  "thumb",
  "thus",
  "thyme",
  "tibet",
  "tick",
  "ticket",
  "tidal",
  "tide",
  "tidy",
  "tie",
  "tier",
  "tiger",
  "tight",
  "tile",
  "till",
  "tilt",
  "timber",
  "time",
  "timid",
  "tin",
  "tiny",
  "tip",
  "tire",
  "tissue",
  "title",
  "toad",
  "toast",
  "today",
  "toe",
  "toilet",
  "token",
  "tokyo",
  "told",
  "toll",
  "tom",
  "tomato",
  "tomb",
  "tonal",
  "tone",
  "tongue",
  "tonic",
  "too",
  "took",
  "tool",
  "tooth",
  "top",
  "topaz",
  "topic",
  "torch",
  "torque",
  "torso",
  "tort",
  "toss",
  "total",
  "touch",
  "tough",
  "tour",
  "toward",
  "towel",
  "tower",
  "town",
  "toxic",
  "toxin",
  "toy",
  "trace",
  "track",
  "tract",
  "trade",
  "tragic",
  "trail",
  "train",
  "trait",
  "tram",
  "trance",
  "trap",
  "trauma",
  "travel",
  "tray",
  "tread",
  "treat",
  "treaty",
  "treble",
  "tree",
  "trek",
  "tremor",
  "trench",
  "trend",
  "trendy",
  "trial",
  "tribal",
  "tribe",
  "trick",
  "tricky",
  "tried",
  "trifle",
  "trim",
  "trio",
  "trip",
  "triple",
  "troop",
  "trophy",
  "trot",
  "trough",
  "trout",
  "truce",
  "truck",
  "true",
  "truly",
  "trunk",
  "trust",
  "truth",
  "try",
  "tube",
  "tumble",
  "tuna",
  "tundra",
  "tune",
  "tunic",
  "tunnel",
  "turban",
  "turf",
  "turk",
  "turkey",
  "turn",
  "turtle",
  "tutor",
  "tweed",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "tycoon",
  "tying",
  "type",
  "tyrant",
  "ugly",
  "ulcer",
  "ultra",
  "umpire",
  "unable",
  "uncle",
  "under",
  "uneasy",
  "unfair",
  "unify",
  "union",
  "unique",
  "unit",
  "unite",
  "unity",
  "unlike",
  "unrest",
  "unruly",
  "until",
  "update",
  "upheld",
  "uphill",
  "uphold",
  "upon",
  "upper",
  "uproar",
  "upset",
  "upshot",
  "uptake",
  "upturn",
  "upward",
  "urban",
  "urge",
  "urgent",
  "urging",
  "urine",
  "usable",
  "usage",
  "use",
  "useful",
  "user",
  "usual",
  "utmost",
  "utter",
  "vacant",
  "vacuum",
  "vague",
  "vain",
  "valet",
  "valid",
  "valley",
  "value",
  "valve",
  "van",
  "vanish",
  "vanity",
  "vary",
  "vase",
  "vast",
  "vat",
  "vault",
  "vector",
  "veil",
  "vein",
  "velvet",
  "vendor",
  "veneer",
  "venice",
  "venom",
  "vent",
  "venue",
  "venus",
  "verb",
  "verbal",
  "verge",
  "verify",
  "verity",
  "verse",
  "versus",
  "very",
  "vessel",
  "vest",
  "vet",
  "veto",
  "via",
  "viable",
  "vicar",
  "vice",
  "victim",
  "victor",
  "video",
  "vienna",
  "view",
  "vigil",
  "viking",
  "vile",
  "villa",
  "vine",
  "vinyl",
  "viola",
  "violet",
  "violin",
  "viral",
  "virgo",
  "virtue",
  "virus",
  "visa",
  "vision",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "vodka",
  "vogue",
  "voice",
  "void",
  "volley",
  "volume",
  "vote",
  "vowel",
  "voyage",
  "vulgar",
  "wade",
  "wage",
  "waist",
  "wait",
  "waiter",
  "wake",
  "walk",
  "walker",
  "wall",
  "wallet",
  "walnut",
  "wander",
  "want",
  "war",
  "warden",
  "warm",
  "warmth",
  "warn",
  "warp",
  "warsaw",
  "wary",
  "was",
  "wash",
  "wasp",
  "waste",
  "watch",
  "water",
  "watery",
  "wave",
  "wax",
  "way",
  "weak",
  "weaken",
  "wealth",
  "weapon",
  "wear",
  "weary",
  "weave",
  "wedge",
  "wee",
  "weed",
  "week",
  "weekly",
  "weep",
  "weigh",
  "weight",
  "weird",
  "well",
  "were",
  "west",
  "wet",
  "whale",
  "wharf",
  "what",
  "wheat",
  "wheel",
  "when",
  "whence",
  "where",
  "which",
  "whiff",
  "while",
  "whim",
  "whip",
  "whisky",
  "white",
  "who",
  "whole",
  "wholly",
  "whom",
  "whose",
  "why",
  "wicked",
  "wide",
  "widely",
  "widen",
  "wider",
  "widow",
  "width",
  "wife",
  "wig",
  "wild",
  "wildly",
  "will",
  "willow",
  "wily",
  "win",
  "wind",
  "window",
  "windy",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wipe",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "wit",
  "witch",
  "with",
  "within",
  "witty",
  "wizard",
  "woke",
  "wolf",
  "wolves",
  "woman",
  "womb",
  "won",
  "wonder",
  "wood",
  "wooden",
  "woods",
  "woody",
  "wool",
  "word",
  "work",
  "worker",
  "world",
  "worm",
  "worry",
  "worse",
  "worst",
  "worth",
  "worthy",
  "would",
  "wound",
  "wrap",
  "wrath",
  "wreath",
  "wreck",
  "wring",
  "wrist",
  "writ",
  "write",
  "writer",
  "wrong",
  "xerox",
  "yacht",
  "yale",
  "yard",
  "yarn",
  "yeah",
  "year",
  "yeard",
  "yeast",
  "yellow",
  "yet",
  "yield",
  "yogurt",
  "yolk",
  "you",
  "young",
  "your",
  "youth",
  "zaire",
  "zeal",
  "zebra",
  "zenith",
  "zero",
  "zeus",
  "zigzag",
  "zinc",
  "zombie",
  "zone"
];

// node_modules/@hashgraph/cryptography/src/words/bip39.js
var bip39_default = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];

// node_modules/@hashgraph/cryptography/src/Mnemonic.js
var import_tweetnacl4 = __toModule(require_nacl_fast());

// node_modules/@hashgraph/cryptography/src/primitive/sha256.browser.js
async function digest(data) {
  return new Uint8Array(await crypto.subtle.digest("SHA-256", data));
}

// node_modules/@hashgraph/cryptography/src/encoding/utf8.browser.js
function decode2(data) {
  return new TextDecoder().decode(data);
}
function encode2(text) {
  return new TextEncoder().encode(text);
}

// node_modules/@hashgraph/cryptography/src/primitive/pbkdf2.browser.js
async function deriveKey(algorithm, password, salt, iterations, length) {
  const pass = typeof password === "string" ? encode2(password) : password;
  const nacl5 = typeof salt === "string" ? encode2(salt) : salt;
  try {
    const key = await window.crypto.subtle.importKey("raw", pass, {
      name: "PBKDF2",
      hash: algorithm
    }, false, ["deriveBits"]);
    return new Uint8Array(await window.crypto.subtle.deriveBits({
      name: "PBKDF2",
      hash: algorithm,
      salt: nacl5,
      iterations
    }, key, length << 3));
  } catch {
    throw new Error("(BUG) Non-Exhaustive switch statement for algorithms");
  }
}

// node_modules/@hashgraph/cryptography/src/primitive/hmac.browser.js
var HashAlgorithm = {
  Sha256: "SHA-256",
  Sha384: "SHA-384",
  Sha512: "SHA-512"
};
async function hash(algorithm, secretKey, data) {
  const key = typeof secretKey === "string" ? encode2(secretKey) : secretKey;
  const value = typeof data === "string" ? encode2(data) : data;
  try {
    const key_ = await window.crypto.subtle.importKey("raw", key, {
      name: "HMAC",
      hash: algorithm
    }, false, ["sign"]);
    return new Uint8Array(await window.crypto.subtle.sign("HMAC", key_, value));
  } catch {
    throw new Error("Fallback if SubtleCrypto fails is not implemented");
  }
}

// node_modules/@hashgraph/cryptography/src/primitive/slip10.js
async function derive(parentKey, chainCode, index) {
  const input = new Uint8Array(37);
  input[0] = 0;
  input.set(parentKey, 1);
  new DataView(input.buffer, input.byteOffset, input.byteLength).setUint32(33, index, false);
  input[33] |= 128;
  const digest3 = await hash(HashAlgorithm.Sha512, chainCode, input);
  return { keyData: digest3.subarray(0, 32), chainCode: digest3.subarray(32) };
}

// node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "\xA0",
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
    if (!(x instanceof BigNumber2))
      return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++)
            ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v)))
          return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0)
          e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b, 2, ALPHABET.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0)
          return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b);
      e = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str = convertBase(str, b, 10, x.s);
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0")
          ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object")
            FORMAT = v;
          else
            throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i, n, c = v.c, e = v.e, s = v.s;
    out:
      if ({}.toString.call(c) == "[object Array]") {
        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          if (c[0] === 0) {
            if (e === 0 && c.length === 1)
              return true;
            break out;
          }
          i = (e + 1) % LOG_BASE;
          if (i < 1)
            i += LOG_BASE;
          if (String(c[0]).length == i) {
            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n))
                break out;
            }
            if (n !== 0)
              return true;
          }
        }
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, P.lt);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, P.gt);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k; ) {
            v = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k; ) {
            v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k; ) {
          v = random53bitInt();
          if (v < 9e15)
            c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--)
        ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
          ;
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
          ;
        if (i < LOG_BASE)
          e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i < args.length; )
      sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign2, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign2;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; )
          ;
        for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
          ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x, k, base) {
      var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }
      if (carry)
        x = [carry].concat(x);
      return x;
    }
    function compare3(a, b, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1))
        ;
    }
    return function(x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++)
        ;
      if (yc[i] > (xc[i] || 0))
        e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n = 0;
          cmp = compare3(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base)
                n = base - 1;
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare3(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare3(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
          ;
        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n.c)
      return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n = round(new BigNumber2(n), i, rm);
      e = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++)
          ;
        str = toExponential(str, e);
      } else {
        i -= ne;
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i > 0)
            for (str += "."; i--; str += "0")
              ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len)
              str += ".";
            for (; i--; str += "0")
              ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, method) {
    var n, i = 1, m = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      n = new BigNumber2(args[i]);
      if (!n.s) {
        m = n;
        break;
      } else if (method.call(m, n)) {
        m = n;
      }
    }
    return m;
  }
  function normalise(n, c, e) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop())
      ;
    for (j = c[0]; j >= 10; j /= 10, i++)
      ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum, b) {
      var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base ? p1 : m;
          });
          if (b) {
            base = b;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s)
            return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  }();
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
          ;
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = n / pows10[d - j - 1] % 10 | 0;
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++)
              ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
          }
        }
        r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++)
                ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop())
          ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str, e = n.e;
    if (e === null)
      return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n.s < 0 ? "-" + str : str;
  }
  P.absoluteValue = P.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0)
      x.s = 1;
    return x;
  };
  P.comparedTo = function(y, b) {
    return compare(this, new BigNumber2(y, b));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c, n, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c))
      return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v])
      for (; v % 10 == 0; v /= 10, n--)
        ;
    if (n < 0)
      n = 0;
    return n;
  };
  P.dividedBy = P.div = function(y, b) {
    return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y, b) {
    return div(this, new BigNumber2(y, b), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m != null)
      m = new BigNumber2(m);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp)
        x = x.mod(m);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1)
        k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c)
          break;
        if (k) {
          if (y.c.length > k)
            y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0)
          break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k)
          x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp)
      return y;
    if (nIsNeg)
      y = ONE.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y, b) {
    return compare(this, new BigNumber2(y, b)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y, b) {
    var i, j, t, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; t.push(0))
        ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy)
      t = xc, xc = yc, yc = t, y.s = -y.s;
    b = (j = yc.length) - (i = xc.length);
    if (b > 0)
      for (; b--; xc[i++] = 0)
        ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b)
          ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P.modulo = P.mod = function(y, b) {
    var q, s, x = this;
    y = new BigNumber2(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1)
      y.s = x.s;
    return y;
  };
  P.multipliedBy = P.times = function(y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL)
      zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
    for (i = xcL + ycL, zc = []; i--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function(y, b) {
    var t, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0))
        ;
      t.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0)
      t = yc, yc = xc, xc = t, b = a;
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P.precision = P.sd = function(sd, rm) {
    var c, n, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c))
      return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n--)
        ;
      for (v = c[0]; v >= 10; v /= 10, n++)
        ;
    }
    if (sd && x.e + 1 > n)
      n = x.e + 1;
    return n;
  };
  P.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0)
        n += "0";
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3)
        s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e)
            --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format2) {
    var str, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2)
        i = g1, g1 = g2, g2 = i, len -= i;
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1)
          intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P.toFraction = function(md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc)
      return new BigNumber2(x);
    d = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }
    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P.toString = function(b) {
    var str, n = this, s = n.s, e = n.e;
    if (e === null) {
      if (s) {
        str = "Infinity";
        if (s < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
      }
      if (s < 0 && n.c[0])
        str = "-" + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z, i = 1, j = a.length, r = a[0] + "";
  for (; i < j; ) {
    s = a[i++] + "";
    z = LOG_BASE - s.length;
    for (; z--; s = "0" + s)
      ;
    r += s;
  }
  for (j = r.length; r.charCodeAt(--j) === 48; )
    ;
  return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!i || !j)
    return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b)
    return a ? b ? 0 : -j : i;
  if (i != j)
    return i;
  a = i < 0;
  b = k == l;
  if (!xc || !yc)
    return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b)
    return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++)
    if (xc[i] != yc[i])
      return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z) {
  var len, zs;
  if (e < 0) {
    for (zs = z + "."; ++e; zs += z)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z)
        ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone();
var bignumber_default = BigNumber;

// node_modules/@hashgraph/cryptography/src/util/entropy.js
function legacy1(words, wordlist) {
  const indicies = words.map((word) => wordlist.indexOf(word.toLowerCase()));
  const data = convertRadix(indicies, wordlist.length, 256, 33);
  const checksum = data[data.length - 1];
  const result = new Uint8Array(data.length - 1);
  for (let i = 0; i < data.length - 1; i += 1) {
    result[i] = data[i] ^ checksum;
  }
  return [result, checksum];
}
async function legacy2(words, wordlist) {
  const concatBitsLen = words.length * 11;
  const concatBits = [];
  concatBits.fill(false, 0, concatBitsLen);
  for (const [wordIndex, word] of words.entries()) {
    const index = wordlist.indexOf(word.toLowerCase());
    if (index < 0) {
      throw new Error(`Word not found in wordlist: ${word}`);
    }
    for (let i = 0; i < 11; i += 1) {
      concatBits[wordIndex * 11 + i] = (index & 1 << 10 - i) !== 0;
    }
  }
  const checksumBitsLen = concatBitsLen / 33;
  const entropyBitsLen = concatBitsLen - checksumBitsLen;
  const entropy2 = new Uint8Array(entropyBitsLen / 8);
  for (let i = 0; i < entropy2.length; i += 1) {
    for (let j = 0; j < 8; j += 1) {
      if (concatBits[i * 8 + j]) {
        entropy2[i] |= 1 << 7 - j;
      }
    }
  }
  const hash2 = await digest(entropy2);
  const hashBits = bytesToBits(hash2);
  for (let i = 0; i < checksumBitsLen; i += 1) {
    if (concatBits[entropyBitsLen + i] !== hashBits[i]) {
      throw new Error("Checksum mismatch");
    }
  }
  return entropy2;
}
function crc8(data) {
  let crc = 255;
  for (let i = 0; i < data.length - 1; i += 1) {
    crc ^= data[i];
    for (let j = 0; j < 8; j += 1) {
      crc = crc >>> 1 ^ ((crc & 1) === 0 ? 0 : 178);
    }
  }
  return crc ^ 255;
}
function convertRadix(nums, fromRadix, toRadix, toLength) {
  let num = new bignumber_default(0);
  for (const element of nums) {
    num = num.times(fromRadix);
    num = num.plus(element);
  }
  const result = new Uint8Array(toLength);
  for (let i = toLength - 1; i >= 0; i -= 1) {
    const tem = num.dividedToIntegerBy(toRadix);
    const rem = num.modulo(toRadix);
    num = tem;
    result[i] = rem.toNumber();
  }
  return result;
}
function bytesToBits(data) {
  const bits = [];
  bits.fill(false, 0, data.length * 8);
  for (let i = 0; i < data.length; i += 1) {
    for (let j = 0; j < 8; j += 1) {
      bits[i * 8 + j] = (data[i] & 1 << 7 - j) !== 0;
    }
  }
  return bits;
}

// node_modules/@hashgraph/cryptography/src/Mnemonic.js
var Mnemonic = class {
  constructor({ words, legacy: legacy3 }) {
    this.words = words;
    this._isLegacy = legacy3;
  }
  static generate() {
    return Mnemonic._generate(24);
  }
  static generate12() {
    return Mnemonic._generate(12);
  }
  static async _generate(length) {
    let neededEntropy;
    if (length === 12)
      neededEntropy = 16;
    else if (length === 24)
      neededEntropy = 32;
    else {
      throw new Error(`unsupported phrase length ${length}, only 12 or 24 are supported`);
    }
    const seed = await bytesAsync(neededEntropy);
    const entropyBits = bytesToBinary(Array.from(seed));
    const checksumBits = await deriveChecksumBits(seed);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = (chunks != null ? chunks : []).map((binary) => bip39_default[binaryToByte(binary)]);
    return new Mnemonic({ words, legacy: false });
  }
  static async fromWords(words) {
    return await new Mnemonic({
      words,
      legacy: words.length === 22
    })._validate();
  }
  async toPrivateKey(passphrase = "") {
    if (this._isLegacy) {
      if (passphrase.length > 0) {
        throw new Error("legacy 22-word mnemonics do not support passphrases");
      }
      return this.toLegacyPrivateKey();
    }
    return await this._toPrivateKey(passphrase);
  }
  static async fromString(mnemonic) {
    return Mnemonic.fromWords(mnemonic.split(/\s|,/));
  }
  async _validate() {
    if (this._isLegacy) {
      if (this.words.length !== 22) {
        throw new BadMnemonicError(this, BadMnemonicReason_default.BadLength, []);
      }
      const unknownWordIndices = this.words.reduce((unknowns, word, index) => legacy_default.includes(word.toLowerCase()) ? unknowns : [...unknowns, index], []);
      if (unknownWordIndices.length > 0) {
        throw new BadMnemonicError(this, BadMnemonicReason_default.UnknownWords, unknownWordIndices);
      }
      const [seed, checksum] = legacy1(this.words, legacy_default);
      const newChecksum = crc8(seed);
      if (checksum !== newChecksum) {
        throw new BadMnemonicError(this, BadMnemonicReason_default.ChecksumMismatch, []);
      }
    } else {
      if (!(this.words.length === 12 || this.words.length === 24)) {
        throw new BadMnemonicError(this, BadMnemonicReason_default.BadLength, []);
      }
      const unknownWordIndices = this.words.reduce((unknowns, word, index) => bip39_default.includes(word) ? unknowns : [...unknowns, index], []);
      if (unknownWordIndices.length > 0) {
        throw new BadMnemonicError(this, BadMnemonicReason_default.UnknownWords, unknownWordIndices);
      }
      const bits = this.words.map((word) => {
        return bip39_default.indexOf(word).toString(2).padStart(11, "0");
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBitsRegex = entropyBits.match(/(.{1,8})/g);
      const entropyBytes = entropyBitsRegex.map(binaryToByte);
      const newChecksum = await deriveChecksumBits(Uint8Array.from(entropyBytes));
      if (newChecksum !== checksumBits) {
        throw new BadMnemonicError(this, BadMnemonicReason_default.ChecksumMismatch, []);
      }
    }
    return this;
  }
  async _toPrivateKey(passphrase = "") {
    const input = this.words.join(" ");
    const salt = `mnemonic${passphrase}`;
    const seed = await deriveKey(HashAlgorithm.Sha512, input, salt, 2048, 64);
    const digest3 = await hash(HashAlgorithm.Sha512, "ed25519 seed", seed);
    let keyData = digest3.subarray(0, 32);
    let chainCode = digest3.subarray(32);
    for (const index of [44, 3030, 0, 0]) {
      ({ keyData, chainCode } = await derive(keyData, chainCode, index));
    }
    const keyPair = import_tweetnacl4.default.sign.keyPair.fromSeed(keyData);
    return new PrivateKey(new Ed25519PrivateKey(keyPair, chainCode));
  }
  async toLegacyPrivateKey() {
    let seed;
    if (this._isLegacy) {
      [seed] = legacy1(this.words, legacy_default);
    } else {
      seed = await legacy2(this.words, bip39_default);
    }
    return PrivateKey.fromBytes(seed);
  }
  toString() {
    return this.words.join(" ");
  }
};
function binaryToByte(bin) {
  return parseInt(bin, 2);
}
function bytesToBinary(bytes2) {
  return bytes2.map((x) => x.toString(2).padStart(8, "0")).join("");
}
async function deriveChecksumBits(entropyBuffer) {
  const ENT = entropyBuffer.length * 8;
  const CS = ENT / 32;
  const hash2 = await digest(entropyBuffer);
  return bytesToBinary(Array.from(hash2)).slice(0, CS);
}

// node_modules/@hashgraph/cryptography/src/primitive/keccak.js
var KECCAK_PADDING = [1, 256, 65536, 16777216];
var SHIFT = [0, 8, 16, 24];
var RC = [
  1,
  0,
  32898,
  0,
  32906,
  2147483648,
  2147516416,
  2147483648,
  32907,
  0,
  2147483649,
  0,
  2147516545,
  2147483648,
  32777,
  2147483648,
  138,
  0,
  136,
  0,
  2147516425,
  0,
  2147483658,
  0,
  2147516555,
  0,
  139,
  2147483648,
  32905,
  2147483648,
  32771,
  2147483648,
  32770,
  2147483648,
  128,
  2147483648,
  32778,
  0,
  2147483658,
  2147483648,
  2147516545,
  2147483648,
  32896,
  2147483648,
  2147483649,
  0,
  2147516424,
  2147483648
];
function createKeccakState(bits) {
  return {
    blocks: [],
    reset: true,
    block: 0,
    start: 0,
    lastByteIndex: null,
    blockCount: 1600 - (bits << 1) >> 5,
    outputBlocks: bits >> 5,
    s: zeroFill(50)
  };
}
function zeroFill(n) {
  let arr = Array(n);
  for (let i = 0; i < n; ++i)
    arr[i] = 0;
  return arr;
}
function update(state, message) {
  var length = message.length, blocks = state.blocks, byteCount = state.blockCount << 2, blockCount = state.blockCount, outputBlocks = state.outputBlocks, s = state.s, index = 0, i = 0, code;
  while (index < length) {
    if (state.reset) {
      state.reset = false;
      blocks[0] = state.block;
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    for (i = state.start; index < length && i < byteCount; ++index) {
      code = typeof message === "string" ? message.charCodeAt(index) : message[index];
      if (code < 128) {
        blocks[i >> 2] |= code << SHIFT[i++ & 3];
      } else if (code < 2048) {
        blocks[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
      } else if (code < 55296 || code >= 57344) {
        blocks[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
      } else {
        code = 65536 + ((code & 1023) << 10 | (typeof message === "string" ? message.charCodeAt(++index) : message[++index]) & 1023);
        blocks[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
      }
    }
    state.lastByteIndex = i;
    if (i >= byteCount) {
      state.start = i - byteCount;
      state.block = blocks[blockCount];
      for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
      }
      f(s);
      state.reset = true;
    } else {
      state.start = i;
    }
  }
  i = state.lastByteIndex;
  blocks[i >> 2] |= KECCAK_PADDING[i & 3];
  if (state.lastByteIndex === byteCount) {
    blocks[0] = blocks[blockCount];
    for (i = 1; i < blockCount + 1; ++i) {
      blocks[i] = 0;
    }
  }
  blocks[blockCount - 1] |= 2147483648;
  for (i = 0; i < blockCount; ++i) {
    s[i] ^= blocks[i];
  }
  f(s);
  const buffer = new ArrayBuffer(outputBlocks * 4);
  const view = new DataView(buffer);
  i = 0;
  var j = 0;
  while (j < outputBlocks) {
    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
      view.setInt32(i * 4, s[i], true);
    }
    if (j % blockCount === 0) {
      f(s);
      i = 0;
    }
  }
  return new Uint8Array(buffer);
}
function f(s) {
  var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
  for (n = 0; n < 48; n += 2) {
    c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
    c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
    c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
    c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
    c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
    c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
    c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
    c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
    c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
    c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
    h = c8 ^ (c2 << 1 | c3 >>> 31);
    l = c9 ^ (c3 << 1 | c2 >>> 31);
    s[0] ^= h;
    s[1] ^= l;
    s[10] ^= h;
    s[11] ^= l;
    s[20] ^= h;
    s[21] ^= l;
    s[30] ^= h;
    s[31] ^= l;
    s[40] ^= h;
    s[41] ^= l;
    h = c0 ^ (c4 << 1 | c5 >>> 31);
    l = c1 ^ (c5 << 1 | c4 >>> 31);
    s[2] ^= h;
    s[3] ^= l;
    s[12] ^= h;
    s[13] ^= l;
    s[22] ^= h;
    s[23] ^= l;
    s[32] ^= h;
    s[33] ^= l;
    s[42] ^= h;
    s[43] ^= l;
    h = c2 ^ (c6 << 1 | c7 >>> 31);
    l = c3 ^ (c7 << 1 | c6 >>> 31);
    s[4] ^= h;
    s[5] ^= l;
    s[14] ^= h;
    s[15] ^= l;
    s[24] ^= h;
    s[25] ^= l;
    s[34] ^= h;
    s[35] ^= l;
    s[44] ^= h;
    s[45] ^= l;
    h = c4 ^ (c8 << 1 | c9 >>> 31);
    l = c5 ^ (c9 << 1 | c8 >>> 31);
    s[6] ^= h;
    s[7] ^= l;
    s[16] ^= h;
    s[17] ^= l;
    s[26] ^= h;
    s[27] ^= l;
    s[36] ^= h;
    s[37] ^= l;
    s[46] ^= h;
    s[47] ^= l;
    h = c6 ^ (c0 << 1 | c1 >>> 31);
    l = c7 ^ (c1 << 1 | c0 >>> 31);
    s[8] ^= h;
    s[9] ^= l;
    s[18] ^= h;
    s[19] ^= l;
    s[28] ^= h;
    s[29] ^= l;
    s[38] ^= h;
    s[39] ^= l;
    s[48] ^= h;
    s[49] ^= l;
    b0 = s[0];
    b1 = s[1];
    b32 = s[11] << 4 | s[10] >>> 28;
    b33 = s[10] << 4 | s[11] >>> 28;
    b14 = s[20] << 3 | s[21] >>> 29;
    b15 = s[21] << 3 | s[20] >>> 29;
    b46 = s[31] << 9 | s[30] >>> 23;
    b47 = s[30] << 9 | s[31] >>> 23;
    b28 = s[40] << 18 | s[41] >>> 14;
    b29 = s[41] << 18 | s[40] >>> 14;
    b20 = s[2] << 1 | s[3] >>> 31;
    b21 = s[3] << 1 | s[2] >>> 31;
    b2 = s[13] << 12 | s[12] >>> 20;
    b3 = s[12] << 12 | s[13] >>> 20;
    b34 = s[22] << 10 | s[23] >>> 22;
    b35 = s[23] << 10 | s[22] >>> 22;
    b16 = s[33] << 13 | s[32] >>> 19;
    b17 = s[32] << 13 | s[33] >>> 19;
    b48 = s[42] << 2 | s[43] >>> 30;
    b49 = s[43] << 2 | s[42] >>> 30;
    b40 = s[5] << 30 | s[4] >>> 2;
    b41 = s[4] << 30 | s[5] >>> 2;
    b22 = s[14] << 6 | s[15] >>> 26;
    b23 = s[15] << 6 | s[14] >>> 26;
    b4 = s[25] << 11 | s[24] >>> 21;
    b5 = s[24] << 11 | s[25] >>> 21;
    b36 = s[34] << 15 | s[35] >>> 17;
    b37 = s[35] << 15 | s[34] >>> 17;
    b18 = s[45] << 29 | s[44] >>> 3;
    b19 = s[44] << 29 | s[45] >>> 3;
    b10 = s[6] << 28 | s[7] >>> 4;
    b11 = s[7] << 28 | s[6] >>> 4;
    b42 = s[17] << 23 | s[16] >>> 9;
    b43 = s[16] << 23 | s[17] >>> 9;
    b24 = s[26] << 25 | s[27] >>> 7;
    b25 = s[27] << 25 | s[26] >>> 7;
    b6 = s[36] << 21 | s[37] >>> 11;
    b7 = s[37] << 21 | s[36] >>> 11;
    b38 = s[47] << 24 | s[46] >>> 8;
    b39 = s[46] << 24 | s[47] >>> 8;
    b30 = s[8] << 27 | s[9] >>> 5;
    b31 = s[9] << 27 | s[8] >>> 5;
    b12 = s[18] << 20 | s[19] >>> 12;
    b13 = s[19] << 20 | s[18] >>> 12;
    b44 = s[29] << 7 | s[28] >>> 25;
    b45 = s[28] << 7 | s[29] >>> 25;
    b26 = s[38] << 8 | s[39] >>> 24;
    b27 = s[39] << 8 | s[38] >>> 24;
    b8 = s[48] << 14 | s[49] >>> 18;
    b9 = s[49] << 14 | s[48] >>> 18;
    s[0] = b0 ^ ~b2 & b4;
    s[1] = b1 ^ ~b3 & b5;
    s[10] = b10 ^ ~b12 & b14;
    s[11] = b11 ^ ~b13 & b15;
    s[20] = b20 ^ ~b22 & b24;
    s[21] = b21 ^ ~b23 & b25;
    s[30] = b30 ^ ~b32 & b34;
    s[31] = b31 ^ ~b33 & b35;
    s[40] = b40 ^ ~b42 & b44;
    s[41] = b41 ^ ~b43 & b45;
    s[2] = b2 ^ ~b4 & b6;
    s[3] = b3 ^ ~b5 & b7;
    s[12] = b12 ^ ~b14 & b16;
    s[13] = b13 ^ ~b15 & b17;
    s[22] = b22 ^ ~b24 & b26;
    s[23] = b23 ^ ~b25 & b27;
    s[32] = b32 ^ ~b34 & b36;
    s[33] = b33 ^ ~b35 & b37;
    s[42] = b42 ^ ~b44 & b46;
    s[43] = b43 ^ ~b45 & b47;
    s[4] = b4 ^ ~b6 & b8;
    s[5] = b5 ^ ~b7 & b9;
    s[14] = b14 ^ ~b16 & b18;
    s[15] = b15 ^ ~b17 & b19;
    s[24] = b24 ^ ~b26 & b28;
    s[25] = b25 ^ ~b27 & b29;
    s[34] = b34 ^ ~b36 & b38;
    s[35] = b35 ^ ~b37 & b39;
    s[44] = b44 ^ ~b46 & b48;
    s[45] = b45 ^ ~b47 & b49;
    s[6] = b6 ^ ~b8 & b0;
    s[7] = b7 ^ ~b9 & b1;
    s[16] = b16 ^ ~b18 & b10;
    s[17] = b17 ^ ~b19 & b11;
    s[26] = b26 ^ ~b28 & b20;
    s[27] = b27 ^ ~b29 & b21;
    s[36] = b36 ^ ~b38 & b30;
    s[37] = b37 ^ ~b39 & b31;
    s[46] = b46 ^ ~b48 & b40;
    s[47] = b47 ^ ~b49 & b41;
    s[8] = b8 ^ ~b0 & b2;
    s[9] = b9 ^ ~b1 & b3;
    s[18] = b18 ^ ~b10 & b12;
    s[19] = b19 ^ ~b11 & b13;
    s[28] = b28 ^ ~b20 & b22;
    s[29] = b29 ^ ~b21 & b23;
    s[38] = b38 ^ ~b30 & b32;
    s[39] = b39 ^ ~b31 & b33;
    s[48] = b48 ^ ~b40 & b42;
    s[49] = b49 ^ ~b41 & b43;
    s[0] ^= RC[n];
    s[1] ^= RC[n + 1];
  }
}
function createKeccak(bits) {
  return function(message) {
    return update(createKeccakState(bits), message);
  };
}
var keccak256 = createKeccak(256);

// node_modules/@hashgraph/cryptography/src/primitive/ecdsa.js
var import_elliptic = __toModule(require_elliptic());
var secp256k1 = new import_elliptic.default.ec("secp256k1");
function generate() {
  const keypair = secp256k1.genKeyPair();
  return {
    privateKey: decode(keypair.getPrivate("hex")),
    publicKey: decode(keypair.getPublic(true, "hex"))
  };
}
async function generateAsync() {
  return Promise.resolve(generate());
}
function fromBytes(data) {
  const keypair = secp256k1.keyFromPrivate(data);
  return {
    privateKey: decode(keypair.getPrivate("hex")),
    publicKey: decode(keypair.getPublic(true, "hex"))
  };
}
function sign(keydata, message) {
  const data = keccak256(message);
  const keypair = secp256k1.keyFromPrivate(keydata);
  const signature = keypair.sign(data);
  const r = signature.r.toArray("be", 32);
  const s = signature.s.toArray("be", 32);
  const result = new Uint8Array(64);
  result.set(r, 0);
  result.set(s, 32);
  return result;
}
function verify(keydata, message, signature) {
  const data = keccak256(message);
  const keypair = secp256k1.keyFromPublic(keydata);
  return keypair.verify(data, {
    r: signature.subarray(0, 32),
    s: signature.subarray(32, 64)
  });
}

// node_modules/@hashgraph/cryptography/src/EcdsaPublicKey.js
var derPrefix3 = "302f300706052b8104000a0324000421";
var derPrefixBytes3 = decode(derPrefix3);
var EcdsaPublicKey = class extends Key {
  constructor(keyData) {
    super();
    this._keyData = keyData;
  }
  get _type() {
    return "secp256k1";
  }
  static fromBytes(data) {
    switch (data.length) {
      case 33:
        return EcdsaPublicKey.fromBytesRaw(data);
      case 49:
        return EcdsaPublicKey.fromBytesDer(data);
      default:
        throw new BadKeyError(`invalid public key length: ${data.length} bytes`);
    }
  }
  static fromBytesDer(data) {
    if (data.length != 44 || !arrayStartsWith(data, derPrefixBytes3)) {
      throw new BadKeyError(`invalid public key length: ${data.length} bytes`);
    }
    return new EcdsaPublicKey(data.subarray(12));
  }
  static fromBytesRaw(data) {
    if (data.length != 32) {
      throw new BadKeyError(`invalid public key length: ${data.length} bytes`);
    }
    return new EcdsaPublicKey(data);
  }
  static fromString(text) {
    return EcdsaPublicKey.fromBytes(decode(text));
  }
  verify(message, signature) {
    return verify(this._keyData, message, signature);
  }
  toBytesDer() {
    const bytes2 = new Uint8Array(derPrefixBytes3.length + 32);
    bytes2.set(derPrefixBytes3, 0);
    bytes2.set(this._keyData.subarray(0, 32), derPrefixBytes3.length);
    return bytes2;
  }
  toBytesRaw() {
    return this._keyData.slice();
  }
  equals(other) {
    return arrayEqual(this._keyData, other._keyData);
  }
};

// node_modules/@hashgraph/cryptography/src/EcdsaPrivateKey.js
var derPrefix4 = "3030020100300706052b8104000a04220420";
var derPrefixBytes4 = decode(derPrefix4);
var EcdsaPrivateKey = class {
  constructor(keyPair, chainCode) {
    this._keyPair = keyPair;
    this._chainCode = chainCode != null ? chainCode : null;
  }
  get _type() {
    return "secp256k1";
  }
  static generate() {
    return new EcdsaPrivateKey(generate());
  }
  static async generateAsync() {
    return new EcdsaPrivateKey(await generateAsync());
  }
  static fromBytes(data) {
    switch (data.length) {
      case 32:
        return EcdsaPrivateKey.fromBytesRaw(data);
      case 45:
        return EcdsaPrivateKey.fromBytesDer(data);
      default:
        throw new BadKeyError(`invalid private key length: ${data.length} bytes`);
    }
  }
  static fromBytesDer(data) {
    if (data.length != 32 && !arrayStartsWith(data, derPrefixBytes4)) {
      throw new BadKeyError("invalid der header");
    }
    return new EcdsaPrivateKey(fromBytes(data.subarray(derPrefixBytes4.length)));
  }
  static fromBytesRaw(data) {
    return new EcdsaPrivateKey(fromBytes(data));
  }
  static fromString(text) {
    return EcdsaPrivateKey.fromBytes(decode(text));
  }
  static fromStringDer(text) {
    return EcdsaPrivateKey.fromBytesDer(decode(text));
  }
  static fromStringRaw(text) {
    return EcdsaPrivateKey.fromBytesRaw(decode(text));
  }
  get publicKey() {
    return new EcdsaPublicKey(this._keyPair.publicKey);
  }
  sign(bytes2) {
    return sign(this._keyPair.privateKey, bytes2);
  }
  toBytesDer() {
    const bytes2 = new Uint8Array(derPrefixBytes4.length + 32);
    bytes2.set(derPrefixBytes4, 0);
    bytes2.set(this._keyPair.privateKey.subarray(0, 32), derPrefixBytes4.length);
    return bytes2;
  }
  toBytesRaw() {
    return this._keyPair.privateKey.slice(0, 32);
  }
};

// node_modules/@hashgraph/cryptography/src/PublicKey.js
var PublicKey = class extends Key {
  constructor(key) {
    super();
    this._key = key;
  }
  get _type() {
    return this._key._type;
  }
  static fromBytes(data) {
    try {
      return new PublicKey(Ed25519PublicKey.fromBytes(data));
    } catch {
    }
    try {
      return new PublicKey(EcdsaPublicKey.fromBytes(data));
    } catch {
    }
    throw new BadKeyError(`invalid public key length: ${data.length} bytes`);
  }
  static fromBytesED25519(data) {
    return new PublicKey(Ed25519PublicKey.fromBytes(data));
  }
  static fromBytesECDSA(data) {
    return new PublicKey(EcdsaPublicKey.fromBytes(data));
  }
  static fromString(text) {
    return PublicKey.fromBytes(decode(text));
  }
  static fromStringED25519(text) {
    return PublicKey.fromBytesED25519(decode(text));
  }
  static fromStringECDSA(text) {
    return PublicKey.fromBytesECDSA(decode(text));
  }
  verify(message, signature) {
    return this._key.verify(message, signature);
  }
  verifyTransaction(transaction) {
    console.log("Deprecated: use `@hashgraph/sdk`.PublicKey instead");
    transaction._requireFrozen();
    if (!transaction.isFrozen()) {
      transaction.freeze();
    }
    for (const signedTransaction of transaction._signedTransactions) {
      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {
        let found = false;
        for (const sigPair of signedTransaction.sigMap.sigPair) {
          const pubKeyPrefix = sigPair.pubKeyPrefix;
          if (arrayEqual(pubKeyPrefix, this.toBytesRaw())) {
            found = true;
            const bodyBytes = signedTransaction.bodyBytes;
            const signature = sigPair.ed25519 != null ? sigPair.ed25519 : sigPair.ECDSASecp256k1;
            if (!this.verify(bodyBytes, signature)) {
              return false;
            }
          }
        }
        if (!found) {
          return false;
        }
      }
    }
    return true;
  }
  toBytes() {
    if (this._key instanceof Ed25519PublicKey) {
      return this.toBytesRaw();
    } else {
      return this.toBytesDer();
    }
  }
  toBytesDer() {
    return this._key.toBytesDer();
  }
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  toString() {
    return this.toStringDer();
  }
  toStringDer() {
    return encode(this.toBytesDer());
  }
  toStringRaw() {
    return encode(this.toBytesRaw());
  }
  equals(other) {
    if (this._key instanceof Ed25519PublicKey && other instanceof Ed25519PublicKey) {
      return this._key.equals(other);
    } else if (this._key instanceof EcdsaPublicKey && other instanceof EcdsaPublicKey) {
      return this._key.equals(other);
    } else {
      return false;
    }
  }
};

// node_modules/@hashgraph/cryptography/src/primitive/aes.browser.js
var CipherAlgorithm = {
  Aes128Ctr: "AES-128-CTR",
  Aes128Cbc: "AES-128-CBC"
};
async function createCipheriv(algorithm, key, iv, data) {
  let algorithm_;
  switch (algorithm.toUpperCase()) {
    case CipherAlgorithm.Aes128Ctr:
      algorithm_ = {
        name: "AES-CTR",
        counter: iv,
        length: 128
      };
      break;
    case CipherAlgorithm.Aes128Cbc:
      algorithm_ = {
        name: "AES-CBC",
        iv
      };
      break;
    default:
      throw new Error("(BUG) non-exhaustive switch statement for CipherAlgorithm");
  }
  const key_ = await window.crypto.subtle.importKey("raw", key, algorithm_.name, false, ["encrypt"]);
  return new Uint8Array(await window.crypto.subtle.encrypt(algorithm_, key_, data));
}
async function createDecipheriv(algorithm, key, iv, data) {
  let algorithm_;
  switch (algorithm.toUpperCase()) {
    case CipherAlgorithm.Aes128Ctr:
      algorithm_ = {
        name: "AES-CTR",
        counter: iv,
        length: 128
      };
      break;
    case CipherAlgorithm.Aes128Cbc:
      algorithm_ = {
        name: "AES-CBC",
        iv
      };
      break;
    default:
      throw new Error("(BUG) non-exhaustive switch statement for CipherAlgorithm");
  }
  const key_ = await window.crypto.subtle.importKey("raw", key, algorithm_.name, false, ["decrypt"]);
  return new Uint8Array(await window.crypto.subtle.decrypt(algorithm_, key_, data));
}

// node_modules/@hashgraph/cryptography/src/primitive/keystore.js
var HMAC_SHA256 = "hmac-sha256";
async function createKeystore(privateKey, passphrase) {
  const dkLen = 32;
  const c = 262144;
  const saltLen = 32;
  const salt = await bytesAsync(saltLen);
  const key = await deriveKey(HashAlgorithm.Sha256, passphrase, salt, c, dkLen);
  const iv = await bytesAsync(16);
  const cipherText = await createCipheriv(CipherAlgorithm.Aes128Ctr, key.slice(0, 16), iv, privateKey);
  const mac = await hash(HashAlgorithm.Sha384, key.slice(16), cipherText);
  const keystore = {
    version: 1,
    crypto: {
      ciphertext: encode(cipherText),
      cipherparams: { iv: encode(iv) },
      cipher: CipherAlgorithm.Aes128Ctr,
      kdf: "pbkdf2",
      kdfparams: {
        dkLen,
        salt: encode(salt),
        c,
        prf: HMAC_SHA256
      },
      mac: encode(mac)
    }
  };
  return encode2(JSON.stringify(keystore));
}
async function loadKeystore(keystoreBytes, passphrase) {
  const keystore = JSON.parse(decode2(keystoreBytes));
  if (keystore.version !== 1) {
    throw new BadKeyError(`unsupported keystore version: ${keystore.version}`);
  }
  const {
    ciphertext,
    cipherparams: { iv },
    cipher,
    kdf,
    kdfparams: { dkLen, salt, c, prf },
    mac
  } = keystore.crypto;
  if (kdf !== "pbkdf2") {
    throw new BadKeyError(`unsupported key derivation function:" + ${kdf}`);
  }
  if (prf !== HMAC_SHA256) {
    throw new BadKeyError(`unsupported key derivation hash function: ${prf}`);
  }
  const saltBytes = decode(salt);
  const ivBytes = decode(iv);
  const cipherBytes = decode(ciphertext);
  const key = await deriveKey(HashAlgorithm.Sha256, passphrase, saltBytes, c, dkLen);
  const macHex = decode(mac);
  const verifyHmac = await hash(HashAlgorithm.Sha384, key.slice(16), cipherBytes);
  if (!macHex.every((b, i) => b === verifyHmac[i])) {
    throw new BadKeyError("HMAC mismatch; passphrase is incorrect");
  }
  return createDecipheriv(cipher, key.slice(0, 16), ivBytes, cipherBytes);
}

// node_modules/@hashgraph/cryptography/src/encoding/der.js
function decode3(data) {
  return decodeIncremental(data)[0];
}
function decodeIncremental(bytes2) {
  const [len, rem] = decodeLength(bytes2.subarray(1));
  const data = rem.subarray(0, len);
  const tail = rem.subarray(len);
  switch (bytes2[0]) {
    case 2:
      return [{ int: decodeInt(data) }, tail];
    case 4:
      return [{ bytes: data }, tail];
    case 5:
      return [{}, tail];
    case 6:
      return [{ ident: decodeObjectIdent(data) }, tail];
    case 48:
      return [{ seq: decodeSeq(data) }, tail];
    default:
      throw new Error(`unsupported DER type tag: ${bytes2[0]}`);
  }
}
function decodeSeq(seqBytes) {
  let data = seqBytes;
  const seq = [];
  while (data.length !== 0) {
    const [decoded, remaining] = decodeIncremental(data);
    seq.push(decoded);
    data = remaining;
  }
  return seq;
}
function decodeObjectIdent(idBytes) {
  const id = [
    Math.floor(idBytes[0] / 40),
    idBytes[0] % 40
  ];
  let val = 0;
  for (const byte of idBytes.subarray(1)) {
    val *= 128;
    if (byte < 128) {
      val += byte;
      id.push(val);
      val = 0;
    } else {
      val += byte & 127;
    }
  }
  return id.join(".");
}
function decodeLength(lenBytes) {
  if (lenBytes[0] < 128) {
    return [lenBytes[0], lenBytes.subarray(1)];
  }
  const numBytes = lenBytes[0] - 128;
  const intBytes = lenBytes.subarray(1, numBytes + 1);
  const rem = lenBytes.subarray(numBytes + 1);
  return [decodeInt(intBytes), rem];
}
function decodeInt(intBytes) {
  const len = intBytes.length;
  if (len === 1) {
    return intBytes[0];
  }
  let view = new DataView(intBytes.buffer, intBytes.byteOffset, intBytes.byteLength);
  if (len === 2)
    return view.getUint16(0, false);
  if (len === 3) {
    const data = Uint8Array.of(0, ...intBytes);
    view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  if (len > 4) {
    throw new Error(`unsupported DER integer length of ${len} bytes`);
  }
  return view.getUint32(0, false);
}

// node_modules/@hashgraph/cryptography/src/primitive/pkcs.js
var AlgorithmIdentifier = class {
  constructor(asn) {
    if ("seq" in asn && asn.seq.length >= 1 && "ident" in asn.seq[0]) {
      this.algIdent = asn.seq[0].ident;
      this.parameters = asn.seq[1];
    } else {
      throw new Error(`error parsing AlgorithmIdentifier from ${JSON.stringify(asn)}`);
    }
  }
  toString() {
    return JSON.stringify(this);
  }
};
var PBES2Params = class {
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 2) {
      this.kdf = new AlgorithmIdentifier(asn.seq[0]);
      this.encScheme = new AlgorithmIdentifier(asn.seq[1]);
    } else {
      throw new Error(`error parsing PBES2Params from ${JSON.stringify(asn)}`);
    }
  }
};
var PBKDF2Params = class {
  constructor(asn) {
    if ("seq" in asn && asn.seq.length >= 2 && "bytes" in asn.seq[0] && "int" in asn.seq[1]) {
      this.salt = asn.seq[0].bytes;
      this.iterCount = asn.seq[1]["int"];
      if (asn.seq.length > 2) {
        if ("seq" in asn.seq[2]) {
          this.prf = new AlgorithmIdentifier(asn.seq[2]);
          return;
        } else if ("int" in asn.seq[2]) {
          this.keyLength = asn.seq[2]["int"];
        }
        if (asn.seq.length === 4) {
          this.prf = new AlgorithmIdentifier(asn.seq[3]);
        }
        return;
      }
    }
    throw new Error(`error parsing PBKDF2Params from ${JSON.stringify(asn)}`);
  }
};
var PrivateKeyInfo = class {
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 3) {
      if ("int" in asn.seq[0] && asn.seq[0]["int"] === 0) {
        this.version = 0;
      } else {
        throw new Error(`expected version = 0, got ${JSON.stringify(asn.seq[0])}`);
      }
      this.algId = new AlgorithmIdentifier(asn.seq[1]);
      if ("bytes" in asn.seq[2]) {
        this.privateKey = asn.seq[2].bytes;
      } else {
        throw new Error(`expected octet string as 3rd element, got ${JSON.stringify(asn.seq[2])}`);
      }
      return;
    }
    throw new Error(`error parsing PrivateKeyInfo from ${JSON.stringify(asn)}`);
  }
  static parse(encoded) {
    return new PrivateKeyInfo(decode3(encoded));
  }
};
var EncryptedPrivateKeyInfo = class {
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 2 && "bytes" in asn.seq[1]) {
      this.algId = new AlgorithmIdentifier(asn.seq[0]);
      this.data = asn.seq[1].bytes;
      return;
    }
    throw new Error(`error parsing EncryptedPrivateKeyInfo from ${JSON.stringify(asn)}`);
  }
  static parse(encoded) {
    return new EncryptedPrivateKeyInfo(decode3(encoded));
  }
  async decrypt(passphrase) {
    if (this.algId.algIdent !== "1.2.840.113549.1.5.13" || !this.algId.parameters) {
      throw new Error(`unsupported key encryption algorithm: ${this.algId.toString()}`);
    }
    const pbes2Params = new PBES2Params(this.algId.parameters);
    if (pbes2Params.kdf.algIdent !== "1.2.840.113549.1.5.12" || !pbes2Params.kdf.parameters) {
      throw new Error(`unsupported key derivation function: ${pbes2Params.kdf.toString()}`);
    }
    const pbkdf2Params = new PBKDF2Params(pbes2Params.kdf.parameters);
    if (!pbkdf2Params.prf) {
      throw new Error("unsupported PRF HMAC-SHA-1");
    } else if (pbkdf2Params.prf.algIdent !== "1.2.840.113549.2.9") {
      throw new Error(`unsupported PRF ${pbkdf2Params.prf.toString()}`);
    }
    if (pbes2Params.encScheme.algIdent !== "2.16.840.1.101.3.4.1.2") {
      throw new Error(`unsupported encryption scheme: ${pbes2Params.encScheme.toString()}`);
    }
    if (!pbes2Params.encScheme.parameters || !("bytes" in pbes2Params.encScheme.parameters)) {
      throw new Error(`expected IV as bytes for AES-128-CBC, got: ${JSON.stringify(pbes2Params.encScheme.parameters)}`);
    }
    const keyLen = pbkdf2Params.keyLength || 16;
    const iv = pbes2Params.encScheme.parameters.bytes;
    const key = await deriveKey(HashAlgorithm.Sha256, passphrase, pbkdf2Params.salt, pbkdf2Params.iterCount, keyLen);
    const decrypted = await createDecipheriv(CipherAlgorithm.Aes128Cbc, key, iv, this.data);
    return PrivateKeyInfo.parse(decrypted);
  }
};

// node_modules/@hashgraph/cryptography/src/encoding/base64.browser.js
function decode4(text) {
  return Uint8Array.from(atob(text), (c) => c.charCodeAt(0));
}

// node_modules/@hashgraph/cryptography/src/encoding/pem.js
var BEGIN_PRIVATEKEY = "-----BEGIN PRIVATE KEY-----\n";
var END_PRIVATEKEY = "-----END PRIVATE KEY-----\n";
var BEGIN_ENCRYPTED_PRIVATEKEY = "-----BEGIN ENCRYPTED PRIVATE KEY-----\n";
var END_ENCRYPTED_PRIVATEKEY = "-----END ENCRYPTED PRIVATE KEY-----\n";
async function read(pem, passphrase) {
  const beginTag = passphrase ? BEGIN_ENCRYPTED_PRIVATEKEY : BEGIN_PRIVATEKEY;
  const endTag = passphrase ? END_ENCRYPTED_PRIVATEKEY : END_PRIVATEKEY;
  const beginIndex = pem.indexOf(beginTag);
  const endIndex = pem.indexOf(endTag);
  if (beginIndex === -1 || endIndex === -1) {
    throw new BadKeyError("failed to find a private key in the PEM file");
  }
  const keyEncoded = pem.slice(beginIndex + beginTag.length, endIndex);
  const key = decode4(keyEncoded);
  if (passphrase) {
    let encrypted;
    try {
      encrypted = EncryptedPrivateKeyInfo.parse(key);
    } catch (error) {
      const message = error != null && error.message != null ? error.message : "";
      throw new BadKeyError(`failed to parse encrypted private key: ${message}`);
    }
    const decrypted = await encrypted.decrypt(passphrase);
    let privateKey = null;
    if (decrypted.algId.algIdent === "1.3.101.112") {
      privateKey = Ed25519PrivateKey;
    } else if (decrypted.algId.algIdent === "1.3.132.0.10") {
      privateKey = EcdsaPrivateKey;
    } else {
      throw new BadKeyError(`unknown private key algorithm ${decrypted.algId.toString()}`);
    }
    const keyData = decode3(decrypted.privateKey);
    if (!("bytes" in keyData)) {
      throw new BadKeyError(`expected ASN bytes, got ${JSON.stringify(keyData)}`);
    }
    return privateKey.fromBytes(keyData.bytes);
  }
  return key.subarray(16);
}

// node_modules/@hashgraph/cryptography/src/util/derive.js
function legacy(seed, index) {
  const password = new Uint8Array(seed.length + 8);
  password.set(seed, 0);
  const view = new DataView(password.buffer, password.byteOffset, password.byteLength);
  if (index === 1099511627775) {
    view.setInt32(seed.length + 0, 255);
    view.setInt32(seed.length + 4, -1);
  } else {
    view.setInt32(seed.length + 0, index < 0 ? -1 : 0);
    view.setInt32(seed.length + 4, index);
  }
  const salt = Uint8Array.from([255]);
  return deriveKey(HashAlgorithm.Sha512, password, salt, 2048, 32);
}

// node_modules/@hashgraph/cryptography/src/PrivateKey.js
var PrivateKey = class extends Key {
  constructor(key) {
    super();
    this._key = key;
  }
  get _type() {
    return this._key._type;
  }
  static generateED25519() {
    return new PrivateKey(Ed25519PrivateKey.generate());
  }
  static generateECDSA() {
    return new PrivateKey(EcdsaPrivateKey.generate());
  }
  static generate() {
    return PrivateKey.generateED25519();
  }
  static async generateAsync() {
    return PrivateKey.generateED25519Async();
  }
  static async generateED25519Async() {
    return new PrivateKey(await Ed25519PrivateKey.generateAsync());
  }
  static async generateECDSAAsync() {
    return new PrivateKey(await EcdsaPrivateKey.generateAsync());
  }
  static fromBytes(data) {
    try {
      return new PrivateKey(Ed25519PrivateKey.fromBytes(data));
    } catch {
    }
    try {
      return new PrivateKey(EcdsaPrivateKey.fromBytes(data));
    } catch {
    }
    throw new BadKeyError(`invalid private key length: ${data.length} bytes`);
  }
  static fromBytesECDSA(data) {
    return new PrivateKey(EcdsaPrivateKey.fromBytes(data));
  }
  static fromBytesED25519(data) {
    return new PrivateKey(Ed25519PrivateKey.fromBytes(data));
  }
  static fromString(text) {
    return PrivateKey.fromBytes(decode(text));
  }
  static fromStringECDSA(text) {
    return PrivateKey.fromBytesECDSA(decode(text));
  }
  static fromStringED25519(text) {
    return PrivateKey.fromBytesED25519(decode(text));
  }
  static async fromMnemonic(mnemonic, passphrase = "") {
    return (typeof mnemonic === "string" ? await Mnemonic.fromString(mnemonic) : mnemonic).toPrivateKey(passphrase);
  }
  static async fromKeystore(data, passphrase = "") {
    return PrivateKey.fromBytes(await loadKeystore(data, passphrase));
  }
  static async fromPem(data, passphrase = "") {
    const pem = await read(data, passphrase);
    if (pem instanceof Ed25519PrivateKey || pem instanceof EcdsaPrivateKey) {
      return new PrivateKey(pem);
    }
    return PrivateKey.fromBytes(pem);
  }
  async derive(index) {
    if (this._key._chainCode == null) {
      throw new Error("this private key does not support key derivation");
    }
    const { keyData, chainCode } = await derive(this.toBytesRaw(), this._key._chainCode, index);
    const constructor2 = this._key.constructor;
    return new PrivateKey(new constructor2(keyData, chainCode));
  }
  async legacyDerive(index) {
    const keyBytes = await legacy(this.toBytesRaw().subarray(0, 32), index);
    const constructor2 = this._key.constructor;
    return new PrivateKey(new constructor2(keyBytes));
  }
  get publicKey() {
    return new PublicKey(this._key.publicKey);
  }
  sign(bytes2) {
    return this._key.sign(bytes2);
  }
  signTransaction(transaction) {
    transaction._requireFrozen();
    if (!transaction.isFrozen()) {
      transaction.freeze();
    }
    if (transaction._signedTransactions.length != 1) {
      throw new Error("`PrivateKey.signTransaction()` requires `Transaction` to have a single node `AccountId` set");
    }
    const tx = transaction._signedTransactions[0];
    const publicKeyHex = encode(this.publicKey.toBytesRaw());
    if (tx.sigMap == null) {
      tx.sigMap = {};
    }
    if (tx.sigMap.sigPair == null) {
      tx.sigMap.sigPair = [];
    }
    for (const sigPair of tx.sigMap.sigPair) {
      if (sigPair.pubKeyPrefix != null && encode(sigPair.pubKeyPrefix) === publicKeyHex) {
        return sigPair.ed25519;
      }
    }
    const siganture = this.sign(tx.bodyBytes != null ? tx.bodyBytes : new Uint8Array());
    const protoSignature = {
      pubKeyPrefix: this.publicKey.toBytesRaw()
    };
    if (this._key instanceof Ed25519PrivateKey) {
      protoSignature.ed25519 = siganture;
    } else {
      protoSignature.ECDSASecp256k1 = siganture;
    }
    tx.sigMap.sigPair.push(protoSignature);
    transaction._signerPublicKeys.add(publicKeyHex);
    return siganture;
  }
  isDerivable() {
    return this._key._chainCode != null;
  }
  toBytes() {
    if (this._key instanceof Ed25519PrivateKey) {
      return this.toBytesRaw();
    } else {
      return this.toBytesDer();
    }
  }
  toBytesDer() {
    return this._key.toBytesDer();
  }
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  toString() {
    return this.toStringDer();
  }
  toStringDer() {
    return encode(this.toBytesDer());
  }
  toStringRaw() {
    return encode(this.toBytesRaw());
  }
  toKeystore(passphrase = "") {
    return createKeystore(this.toBytesRaw(), passphrase);
  }
};

// node_modules/@hashgraph/sdk/src/Cache.js
var CACHE = {
  contractId: null,
  keyList: null,
  thresholdKey: null,
  publicKeyED25519: null,
  publicKeyECDSA: null,
  privateKeyConstructor: null,
  accountIdConstructor: null
};
var Cache_default = CACHE;

// node_modules/@hashgraph/sdk/src/Mnemonic.js
var Mnemonic2 = class {
  constructor(mnemonic) {
    this._mnemonic = mnemonic;
  }
  static async generate() {
    return new Mnemonic2(await Mnemonic._generate(24));
  }
  static async generate12() {
    return new Mnemonic2(await Mnemonic._generate(12));
  }
  static async fromWords(words) {
    return new Mnemonic2(await Mnemonic.fromWords(words));
  }
  async toPrivateKey(passphrase = "") {
    if (Cache_default.privateKeyConstructor == null) {
      throw new Error("`PrivateKey` has not been loaded");
    }
    return Cache_default.privateKeyConstructor(await this._mnemonic.toPrivateKey(passphrase));
  }
  static async fromString(mnemonic) {
    return new Mnemonic2(await Mnemonic.fromString(mnemonic));
  }
  async toLegacyPrivateKey() {
    if (Cache_default.privateKeyConstructor == null) {
      throw new Error("`PrivateKey` has not been loaded");
    }
    return Cache_default.privateKeyConstructor(await this._mnemonic.toLegacyPrivateKey());
  }
  toString() {
    return this._mnemonic.toString();
  }
};

// node_modules/@hashgraph/sdk/src/array.js
function arrayEqual2(array1, array2) {
  if (array1 === array2) {
    return true;
  }
  if (array1.byteLength !== array2.byteLength) {
    return false;
  }
  const view1 = new DataView(array1.buffer, array1.byteOffset, array1.byteLength);
  const view2 = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
  let i = array1.byteLength;
  while (i--) {
    if (view1.getUint8(i) !== view2.getUint8(i)) {
      return false;
    }
  }
  return true;
}

// node_modules/@hashgraph/sdk/src/Key.js
var Key2 = class {
  _toProtobufKey() {
    throw new Error("not implemented");
  }
  static _fromProtobufKey(key) {
    if (key.contractID != null) {
      if (Cache_default.contractId == null) {
        throw new Error("`ContractId` was not loaded before decoding `Key`");
      }
      return Cache_default.contractId(key.contractID);
    }
    if (key.delegatableContractId != null) {
      if (Cache_default.contractId == null) {
        throw new Error("`ContractId` was not loaded before decoding `Key`");
      }
      return Cache_default.contractId(key.delegatableContractId);
    }
    if (key.ed25519 != null && key.ed25519.byteLength > 0) {
      if (Cache_default.publicKeyED25519 == null) {
        throw new Error("`PublicKey` was not loaded before decoding `Key`");
      }
      return Cache_default.publicKeyED25519(key.ed25519);
    }
    if (key.ECDSASecp256k1 != null && key.ECDSASecp256k1.byteLength > 0) {
      if (Cache_default.publicKeyECDSA == null) {
        throw new Error("`PublicKey` was not loaded before decoding `Key`");
      }
      return Cache_default.publicKeyECDSA(key.ECDSASecp256k1);
    }
    if (key.thresholdKey != null && key.thresholdKey.threshold != null) {
      if (Cache_default.thresholdKey == null) {
        throw new Error("`PublicKey` was not loaded before decoding `Key`");
      }
      return Cache_default.thresholdKey(key.thresholdKey);
    }
    if (key.keyList != null) {
      if (Cache_default.keyList == null) {
        throw new Error("`PublicKey` was not loaded before decoding `Key`");
      }
      return Cache_default.keyList(key.keyList);
    }
    throw new Error(`(BUG) keyFromProtobuf: not implemented key case: ${JSON.stringify(key)}`);
  }
};

// node_modules/@hashgraph/sdk/src/PublicKey.js
var PublicKey2 = class extends Key2 {
  constructor(key) {
    super();
    this._key = key;
  }
  static fromBytes(data) {
    return new PublicKey2(PublicKey.fromBytes(data));
  }
  static fromBytesED25519(data) {
    return new PublicKey2(PublicKey.fromBytesED25519(data));
  }
  static fromBytesECDSA(data) {
    return new PublicKey2(PublicKey.fromBytesECDSA(data));
  }
  static fromString(text) {
    return new PublicKey2(PublicKey.fromString(text));
  }
  verify(message, signature) {
    return this._key.verify(message, signature);
  }
  verifyTransaction(transaction) {
    transaction._requireFrozen();
    if (!transaction.isFrozen()) {
      transaction.freeze();
    }
    for (const signedTransaction of transaction._signedTransactions) {
      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {
        let found = false;
        for (const sigPair of signedTransaction.sigMap.sigPair) {
          const pubKeyPrefix = sigPair.pubKeyPrefix;
          if (arrayEqual2(pubKeyPrefix, this.toBytesRaw())) {
            found = true;
            const bodyBytes = signedTransaction.bodyBytes;
            let signature = null;
            if (sigPair.ed25519 != null) {
              signature = sigPair.ed25519;
            } else if (sigPair.ECDSASecp256k1 != null) {
              signature = sigPair.ECDSASecp256k1;
            }
            if (signature == null) {
              continue;
            }
            if (!this.verify(bodyBytes, signature)) {
              return false;
            }
          }
        }
        if (!found) {
          return false;
        }
      }
    }
    return true;
  }
  toBytes() {
    return this._key.toBytes();
  }
  toBytesDer() {
    return this._key.toBytesDer();
  }
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  toString() {
    return this._key.toString();
  }
  toStringDer() {
    return this._key.toStringDer();
  }
  toStringRaw() {
    return this._key.toStringRaw();
  }
  equals(other) {
    return this._key.equals(other._key);
  }
  _toProtobufKey() {
    switch (this._key._type) {
      case "ED25519":
        return {
          ed25519: this._key.toBytesRaw()
        };
      case "secp256k1":
        return {
          ECDSASecp256k1: this._key.toBytesRaw()
        };
      default:
        throw new Error(`unrecognized key type ${this._key._type}`);
    }
  }
  _toProtobufSignature(signature) {
    switch (this._key._type) {
      case "ED25519":
        return {
          pubKeyPrefix: this._key.toBytesRaw(),
          ed25519: signature
        };
      case "secp256k1":
        return {
          pubKeyPrefix: this._key.toBytesRaw(),
          ECDSASecp256k1: signature
        };
      default:
        throw new Error(`unrecognized key type ${this._key._type}`);
    }
  }
  toAccountId(shard, realm) {
    if (Cache_default.accountIdConstructor == null) {
      throw new Error("`AccountId` not loaded");
    }
    return Cache_default.accountIdConstructor(shard, realm, this);
  }
};
Cache_default.publicKeyED25519 = (key) => PublicKey2.fromBytesED25519(key);
Cache_default.publicKeyECDSA = (key) => PublicKey2.fromBytesECDSA(key);

// node_modules/@hashgraph/sdk/src/PrivateKey.js
var PrivateKey2 = class extends Key2 {
  constructor(key) {
    super();
    this._key = key;
  }
  static generateED25519() {
    return new PrivateKey2(PrivateKey.generateED25519());
  }
  static generateECDSA() {
    return new PrivateKey2(PrivateKey.generateECDSA());
  }
  static generate() {
    return PrivateKey2.generateED25519();
  }
  static async generateAsync() {
    return new PrivateKey2(await PrivateKey.generateAsync());
  }
  static async generateED25519Async() {
    return new PrivateKey2(await PrivateKey.generateED25519Async());
  }
  static async generateECDSAAsync() {
    return new PrivateKey2(await PrivateKey.generateECDSAAsync());
  }
  static fromBytes(data) {
    return new PrivateKey2(PrivateKey.fromBytes(data));
  }
  static fromBytesECDSA(data) {
    return new PrivateKey2(PrivateKey.fromBytesECDSA(data));
  }
  static fromBytesED25519(data) {
    return new PrivateKey2(PrivateKey.fromBytesED25519(data));
  }
  static fromString(text) {
    return new PrivateKey2(PrivateKey.fromString(text));
  }
  static fromStringECDSA(text) {
    return new PrivateKey2(PrivateKey.fromStringECDSA(text));
  }
  static fromStringED25519(text) {
    return new PrivateKey2(PrivateKey.fromStringED25519(text));
  }
  static async fromMnemonic(mnemonic, passphrase = "") {
    if (mnemonic instanceof Mnemonic2) {
      return new PrivateKey2(await PrivateKey.fromMnemonic(mnemonic._mnemonic, passphrase));
    }
    return new PrivateKey2(await PrivateKey.fromMnemonic(mnemonic, passphrase));
  }
  static async fromKeystore(data, passphrase = "") {
    return new PrivateKey2(await PrivateKey.fromKeystore(data, passphrase));
  }
  static async fromPem(data, passphrase = "") {
    return new PrivateKey2(await PrivateKey.fromPem(data, passphrase));
  }
  async derive(index) {
    return new PrivateKey2(await this._key.derive(index));
  }
  async legacyDerive(index) {
    return new PrivateKey2(await this._key.legacyDerive(index));
  }
  get publicKey() {
    return new PublicKey2(this._key.publicKey);
  }
  sign(bytes2) {
    return this._key.sign(bytes2);
  }
  signTransaction(transaction) {
    const tx = transaction._signedTransactions[0];
    const signature = tx.bodyBytes != null ? this.sign(tx.bodyBytes) : new Uint8Array();
    transaction.addSignature(this.publicKey, signature);
    return signature;
  }
  isDerivable() {
    return this._key.isDerivable();
  }
  toBytes() {
    return this._key.toBytes();
  }
  toBytesDer() {
    return this._key.toBytesDer();
  }
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  toString() {
    return this._key.toStringDer();
  }
  toStringDer() {
    return this._key.toStringDer();
  }
  toStringRaw() {
    return this._key.toStringRaw();
  }
  toKeystore(passphrase = "") {
    return this._key.toKeystore(passphrase);
  }
  _toProtobufKey() {
    return this.publicKey._toProtobufKey();
  }
  toAccountId(shard, realm) {
    return this.publicKey.toAccountId(shard, realm);
  }
};
Cache_default.privateKeyConstructor = (key) => new PrivateKey2(key);

// node_modules/@hashgraph/sdk/src/KeyList.js
var KeyList2 = class extends Key2 {
  constructor(keys, threshold) {
    super();
    this._keys = keys == null ? [] : keys;
    this._threshold = threshold == null ? null : threshold;
  }
  static of(...keys) {
    return new KeyList2(keys, null);
  }
  static from(arrayLike, mapFn, thisArg) {
    if (mapFn == null) {
      return new KeyList2(Array.from(arrayLike));
    }
    return new KeyList2(Array.from(arrayLike, mapFn, thisArg));
  }
  get threshold() {
    return this._threshold;
  }
  setThreshold(threshold) {
    this._threshold = threshold;
    return this;
  }
  push(...keys) {
    return this._keys.push(...keys);
  }
  splice(start, deleteCount, ...items) {
    return new KeyList2(this._keys.splice(start, deleteCount, ...items), this.threshold);
  }
  slice(start, end) {
    return new KeyList2(this._keys.slice(start, end), this.threshold);
  }
  [Symbol.iterator]() {
    return this._keys[Symbol.iterator]();
  }
  toArray() {
    return this._keys.slice();
  }
  toString() {
    return JSON.stringify({
      threshold: this._threshold,
      keys: this._keys.toString()
    });
  }
  _toProtobufKey() {
    const keys = this._keys.map((key) => key._toProtobufKey());
    if (this.threshold == null) {
      return { keyList: { keys } };
    } else {
      return {
        thresholdKey: {
          threshold: this.threshold,
          keys: { keys }
        }
      };
    }
  }
  static __fromProtobufKeyList(key) {
    const keys = (key.keys != null ? key.keys : []).map((key2) => Key2._fromProtobufKey(key2));
    return new KeyList2(keys);
  }
  static __fromProtobufThresoldKey(key) {
    const list = KeyList2.__fromProtobufKeyList(key.keys != null ? key.keys : {});
    list.setThreshold(key.threshold != null ? key.threshold : 0);
    return list;
  }
};
Cache_default.keyList = (key) => KeyList2.__fromProtobufKeyList(key);
Cache_default.thresholdKey = (key) => KeyList2.__fromProtobufThresoldKey(key);

// node_modules/@hashgraph/sdk/src/Status.js
var Status = class {
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  toString() {
    switch (this) {
      case Status.Ok:
        return "OK";
      case Status.InvalidTransaction:
        return "INVALID_TRANSACTION";
      case Status.PayerAccountNotFound:
        return "PAYER_ACCOUNT_NOT_FOUND";
      case Status.InvalidNodeAccount:
        return "INVALID_NODE_ACCOUNT";
      case Status.TransactionExpired:
        return "TRANSACTION_EXPIRED";
      case Status.InvalidTransactionStart:
        return "INVALID_TRANSACTION_START";
      case Status.InvalidTransactionDuration:
        return "INVALID_TRANSACTION_DURATION";
      case Status.InvalidSignature:
        return "INVALID_SIGNATURE";
      case Status.MemoTooLong:
        return "MEMO_TOO_LONG";
      case Status.InsufficientTxFee:
        return "INSUFFICIENT_TX_FEE";
      case Status.InsufficientPayerBalance:
        return "INSUFFICIENT_PAYER_BALANCE";
      case Status.DuplicateTransaction:
        return "DUPLICATE_TRANSACTION";
      case Status.Busy:
        return "BUSY";
      case Status.NotSupported:
        return "NOT_SUPPORTED";
      case Status.InvalidFileId:
        return "INVALID_FILE_ID";
      case Status.InvalidAccountId:
        return "INVALID_ACCOUNT_ID";
      case Status.InvalidContractId:
        return "INVALID_CONTRACT_ID";
      case Status.InvalidTransactionId:
        return "INVALID_TRANSACTION_ID";
      case Status.ReceiptNotFound:
        return "RECEIPT_NOT_FOUND";
      case Status.RecordNotFound:
        return "RECORD_NOT_FOUND";
      case Status.InvalidSolidityId:
        return "INVALID_SOLIDITY_ID";
      case Status.Unknown:
        return "UNKNOWN";
      case Status.Success:
        return "SUCCESS";
      case Status.FailInvalid:
        return "FAIL_INVALID";
      case Status.FailFee:
        return "FAIL_FEE";
      case Status.FailBalance:
        return "FAIL_BALANCE";
      case Status.KeyRequired:
        return "KEY_REQUIRED";
      case Status.BadEncoding:
        return "BAD_ENCODING";
      case Status.InsufficientAccountBalance:
        return "INSUFFICIENT_ACCOUNT_BALANCE";
      case Status.InvalidSolidityAddress:
        return "INVALID_SOLIDITY_ADDRESS";
      case Status.InsufficientGas:
        return "INSUFFICIENT_GAS";
      case Status.ContractSizeLimitExceeded:
        return "CONTRACT_SIZE_LIMIT_EXCEEDED";
      case Status.LocalCallModificationException:
        return "LOCAL_CALL_MODIFICATION_EXCEPTION";
      case Status.ContractRevertExecuted:
        return "CONTRACT_REVERT_EXECUTED";
      case Status.ContractExecutionException:
        return "CONTRACT_EXECUTION_EXCEPTION";
      case Status.InvalidReceivingNodeAccount:
        return "INVALID_RECEIVING_NODE_ACCOUNT";
      case Status.MissingQueryHeader:
        return "MISSING_QUERY_HEADER";
      case Status.AccountUpdateFailed:
        return "ACCOUNT_UPDATE_FAILED";
      case Status.InvalidKeyEncoding:
        return "INVALID_KEY_ENCODING";
      case Status.NullSolidityAddress:
        return "NULL_SOLIDITY_ADDRESS";
      case Status.ContractUpdateFailed:
        return "CONTRACT_UPDATE_FAILED";
      case Status.InvalidQueryHeader:
        return "INVALID_QUERY_HEADER";
      case Status.InvalidFeeSubmitted:
        return "INVALID_FEE_SUBMITTED";
      case Status.InvalidPayerSignature:
        return "INVALID_PAYER_SIGNATURE";
      case Status.KeyNotProvided:
        return "KEY_NOT_PROVIDED";
      case Status.InvalidExpirationTime:
        return "INVALID_EXPIRATION_TIME";
      case Status.NoWaclKey:
        return "NO_WACL_KEY";
      case Status.FileContentEmpty:
        return "FILE_CONTENT_EMPTY";
      case Status.InvalidAccountAmounts:
        return "INVALID_ACCOUNT_AMOUNTS";
      case Status.EmptyTransactionBody:
        return "EMPTY_TRANSACTION_BODY";
      case Status.InvalidTransactionBody:
        return "INVALID_TRANSACTION_BODY";
      case Status.InvalidSignatureTypeMismatchingKey:
        return "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY";
      case Status.InvalidSignatureCountMismatchingKey:
        return "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY";
      case Status.EmptyLiveHashBody:
        return "EMPTY_LIVE_HASH_BODY";
      case Status.EmptyLiveHash:
        return "EMPTY_LIVE_HASH";
      case Status.EmptyLiveHashKeys:
        return "EMPTY_LIVE_HASH_KEYS";
      case Status.InvalidLiveHashSize:
        return "INVALID_LIVE_HASH_SIZE";
      case Status.EmptyQueryBody:
        return "EMPTY_QUERY_BODY";
      case Status.EmptyLiveHashQuery:
        return "EMPTY_LIVE_HASH_QUERY";
      case Status.LiveHashNotFound:
        return "LIVE_HASH_NOT_FOUND";
      case Status.AccountIdDoesNotExist:
        return "ACCOUNT_ID_DOES_NOT_EXIST";
      case Status.LiveHashAlreadyExists:
        return "LIVE_HASH_ALREADY_EXISTS";
      case Status.InvalidFileWacl:
        return "INVALID_FILE_WACL";
      case Status.SerializationFailed:
        return "SERIALIZATION_FAILED";
      case Status.TransactionOversize:
        return "TRANSACTION_OVERSIZE";
      case Status.TransactionTooManyLayers:
        return "TRANSACTION_TOO_MANY_LAYERS";
      case Status.ContractDeleted:
        return "CONTRACT_DELETED";
      case Status.PlatformNotActive:
        return "PLATFORM_NOT_ACTIVE";
      case Status.KeyPrefixMismatch:
        return "KEY_PREFIX_MISMATCH";
      case Status.PlatformTransactionNotCreated:
        return "PLATFORM_TRANSACTION_NOT_CREATED";
      case Status.InvalidRenewalPeriod:
        return "INVALID_RENEWAL_PERIOD";
      case Status.InvalidPayerAccountId:
        return "INVALID_PAYER_ACCOUNT_ID";
      case Status.AccountDeleted:
        return "ACCOUNT_DELETED";
      case Status.FileDeleted:
        return "FILE_DELETED";
      case Status.AccountRepeatedInAccountAmounts:
        return "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS";
      case Status.SettingNegativeAccountBalance:
        return "SETTING_NEGATIVE_ACCOUNT_BALANCE";
      case Status.ObtainerRequired:
        return "OBTAINER_REQUIRED";
      case Status.ObtainerSameContractId:
        return "OBTAINER_SAME_CONTRACT_ID";
      case Status.ObtainerDoesNotExist:
        return "OBTAINER_DOES_NOT_EXIST";
      case Status.ModifyingImmutableContract:
        return "MODIFYING_IMMUTABLE_CONTRACT";
      case Status.FileSystemException:
        return "FILE_SYSTEM_EXCEPTION";
      case Status.AutorenewDurationNotInRange:
        return "AUTORENEW_DURATION_NOT_IN_RANGE";
      case Status.ErrorDecodingBytestring:
        return "ERROR_DECODING_BYTESTRING";
      case Status.ContractFileEmpty:
        return "CONTRACT_FILE_EMPTY";
      case Status.ContractBytecodeEmpty:
        return "CONTRACT_BYTECODE_EMPTY";
      case Status.InvalidInitialBalance:
        return "INVALID_INITIAL_BALANCE";
      case Status.InvalidReceiveRecordThreshold:
        return "INVALID_RECEIVE_RECORD_THRESHOLD";
      case Status.InvalidSendRecordThreshold:
        return "INVALID_SEND_RECORD_THRESHOLD";
      case Status.AccountIsNotGenesisAccount:
        return "ACCOUNT_IS_NOT_GENESIS_ACCOUNT";
      case Status.PayerAccountUnauthorized:
        return "PAYER_ACCOUNT_UNAUTHORIZED";
      case Status.InvalidFreezeTransactionBody:
        return "INVALID_FREEZE_TRANSACTION_BODY";
      case Status.FreezeTransactionBodyNotFound:
        return "FREEZE_TRANSACTION_BODY_NOT_FOUND";
      case Status.TransferListSizeLimitExceeded:
        return "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
      case Status.ResultSizeLimitExceeded:
        return "RESULT_SIZE_LIMIT_EXCEEDED";
      case Status.NotSpecialAccount:
        return "NOT_SPECIAL_ACCOUNT";
      case Status.ContractNegativeGas:
        return "CONTRACT_NEGATIVE_GAS";
      case Status.ContractNegativeValue:
        return "CONTRACT_NEGATIVE_VALUE";
      case Status.InvalidFeeFile:
        return "INVALID_FEE_FILE";
      case Status.InvalidExchangeRateFile:
        return "INVALID_EXCHANGE_RATE_FILE";
      case Status.InsufficientLocalCallGas:
        return "INSUFFICIENT_LOCAL_CALL_GAS";
      case Status.EntityNotAllowedToDelete:
        return "ENTITY_NOT_ALLOWED_TO_DELETE";
      case Status.AuthorizationFailed:
        return "AUTHORIZATION_FAILED";
      case Status.FileUploadedProtoInvalid:
        return "FILE_UPLOADED_PROTO_INVALID";
      case Status.FileUploadedProtoNotSavedToDisk:
        return "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK";
      case Status.FeeScheduleFilePartUploaded:
        return "FEE_SCHEDULE_FILE_PART_UPLOADED";
      case Status.ExchangeRateChangeLimitExceeded:
        return "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED";
      case Status.MaxContractStorageExceeded:
        return "MAX_CONTRACT_STORAGE_EXCEEDED";
      case Status.TransferAccountSameAsDeleteAccount:
        return "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT";
      case Status.TotalLedgerBalanceInvalid:
        return "TOTAL_LEDGER_BALANCE_INVALID";
      case Status.ExpirationReductionNotAllowed:
        return "EXPIRATION_REDUCTION_NOT_ALLOWED";
      case Status.MaxGasLimitExceeded:
        return "MAX_GAS_LIMIT_EXCEEDED";
      case Status.MaxFileSizeExceeded:
        return "MAX_FILE_SIZE_EXCEEDED";
      case Status.ReceiverSigRequired:
        return "RECEIVER_SIG_REQUIRED";
      case Status.InvalidTopicId:
        return "INVALID_TOPIC_ID";
      case Status.InvalidAdminKey:
        return "INVALID_ADMIN_KEY";
      case Status.InvalidSubmitKey:
        return "INVALID_SUBMIT_KEY";
      case Status.Unauthorized:
        return "UNAUTHORIZED";
      case Status.InvalidTopicMessage:
        return "INVALID_TOPIC_MESSAGE";
      case Status.InvalidAutorenewAccount:
        return "INVALID_AUTORENEW_ACCOUNT";
      case Status.AutorenewAccountNotAllowed:
        return "AUTORENEW_ACCOUNT_NOT_ALLOWED";
      case Status.TopicExpired:
        return "TOPIC_EXPIRED";
      case Status.InvalidChunkNumber:
        return "INVALID_CHUNK_NUMBER";
      case Status.InvalidChunkTransactionId:
        return "INVALID_CHUNK_TRANSACTION_ID";
      case Status.AccountFrozenForToken:
        return "ACCOUNT_FROZEN_FOR_TOKEN";
      case Status.TokensPerAccountLimitExceeded:
        return "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED";
      case Status.InvalidTokenId:
        return "INVALID_TOKEN_ID";
      case Status.InvalidTokenDecimals:
        return "INVALID_TOKEN_DECIMALS";
      case Status.InvalidTokenInitialSupply:
        return "INVALID_TOKEN_INITIAL_SUPPLY";
      case Status.InvalidTreasuryAccountForToken:
        return "INVALID_TREASURY_ACCOUNT_FOR_TOKEN";
      case Status.InvalidTokenSymbol:
        return "INVALID_TOKEN_SYMBOL";
      case Status.TokenHasNoFreezeKey:
        return "TOKEN_HAS_NO_FREEZE_KEY";
      case Status.TransfersNotZeroSumForToken:
        return "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN";
      case Status.MissingTokenSymbol:
        return "MISSING_TOKEN_SYMBOL";
      case Status.TokenSymbolTooLong:
        return "TOKEN_SYMBOL_TOO_LONG";
      case Status.AccountKycNotGrantedForToken:
        return "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN";
      case Status.TokenHasNoKycKey:
        return "TOKEN_HAS_NO_KYC_KEY";
      case Status.InsufficientTokenBalance:
        return "INSUFFICIENT_TOKEN_BALANCE";
      case Status.TokenWasDeleted:
        return "TOKEN_WAS_DELETED";
      case Status.TokenHasNoSupplyKey:
        return "TOKEN_HAS_NO_SUPPLY_KEY";
      case Status.TokenHasNoWipeKey:
        return "TOKEN_HAS_NO_WIPE_KEY";
      case Status.InvalidTokenMintAmount:
        return "INVALID_TOKEN_MINT_AMOUNT";
      case Status.InvalidTokenBurnAmount:
        return "INVALID_TOKEN_BURN_AMOUNT";
      case Status.TokenNotAssociatedToAccount:
        return "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT";
      case Status.CannotWipeTokenTreasuryAccount:
        return "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT";
      case Status.InvalidKycKey:
        return "INVALID_KYC_KEY";
      case Status.InvalidWipeKey:
        return "INVALID_WIPE_KEY";
      case Status.InvalidFreezeKey:
        return "INVALID_FREEZE_KEY";
      case Status.InvalidSupplyKey:
        return "INVALID_SUPPLY_KEY";
      case Status.MissingTokenName:
        return "MISSING_TOKEN_NAME";
      case Status.TokenNameTooLong:
        return "TOKEN_NAME_TOO_LONG";
      case Status.InvalidWipingAmount:
        return "INVALID_WIPING_AMOUNT";
      case Status.TokenIsImmutable:
        return "TOKEN_IS_IMMUTABLE";
      case Status.TokenAlreadyAssociatedToAccount:
        return "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT";
      case Status.TransactionRequiresZeroTokenBalances:
        return "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES";
      case Status.AccountIsTreasury:
        return "ACCOUNT_IS_TREASURY";
      case Status.TokenIdRepeatedInTokenList:
        return "TOKEN_ID_REPEATED_IN_TOKEN_LIST";
      case Status.TokenTransferListSizeLimitExceeded:
        return "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
      case Status.EmptyTokenTransferBody:
        return "EMPTY_TOKEN_TRANSFER_BODY";
      case Status.EmptyTokenTransferAccountAmounts:
        return "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS";
      case Status.InvalidScheduleId:
        return "INVALID_SCHEDULE_ID";
      case Status.ScheduleIsImmutable:
        return "SCHEDULE_IS_IMMUTABLE";
      case Status.InvalidSchedulePayerId:
        return "INVALID_SCHEDULE_PAYER_ID";
      case Status.InvalidScheduleAccountId:
        return "INVALID_SCHEDULE_ACCOUNT_ID";
      case Status.NoNewValidSignatures:
        return "NO_NEW_VALID_SIGNATURES";
      case Status.UnresolvableRequiredSigners:
        return "UNRESOLVABLE_REQUIRED_SIGNERS";
      case Status.ScheduledTransactionNotInWhitelist:
        return "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST";
      case Status.SomeSignaturesWereInvalid:
        return "SOME_SIGNATURES_WERE_INVALID";
      case Status.TransactionIdFieldNotAllowed:
        return "TRANSACTION_ID_FIELD_NOT_ALLOWED";
      case Status.IdenticalScheduleAlreadyCreated:
        return "IDENTICAL_SCHEDULE_ALREADY_CREATED";
      case Status.InvalidZeroByteInString:
        return "INVALID_ZERO_BYTE_IN_STRING";
      case Status.ScheduleAlreadyDeleted:
        return "SCHEDULE_ALREADY_DELETED";
      case Status.ScheduleAlreadyExecuted:
        return "SCHEDULE_ALREADY_EXECUTED";
      case Status.MessageSizeTooLarge:
        return "MESSAGE_SIZE_TOO_LARGE";
      case Status.OperationRepeatedInBucketGroups:
        return "OPERATION_REPEATED_IN_BUCKET_GROUPS";
      case Status.BucketCapacityOverflow:
        return "BUCKET_CAPACITY_OVERFLOW";
      case Status.NodeCapacityNotSufficientForOperation:
        return "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION";
      case Status.BucketHasNoThrottleGroups:
        return "BUCKET_HAS_NO_THROTTLE_GROUPS";
      case Status.ThrottleGroupHasZeroOpsPerSec:
        return "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC";
      case Status.SuccessButMissingExpectedOperation:
        return "SUCCESS_BUT_MISSING_EXPECTED_OPERATION";
      case Status.UnparseableThrottleDefinitions:
        return "UNPARSEABLE_THROTTLE_DEFINITIONS";
      case Status.InvalidThrottleDefinitions:
        return "INVALID_THROTTLE_DEFINITIONS";
      case Status.AccountExpiredAndPendingRemoval:
        return "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL";
      case Status.InvalidTokenMaxSupply:
        return "INVALID_TOKEN_MAX_SUPPLY";
      case Status.InvalidTokenNftSerialNumber:
        return "INVALID_TOKEN_NFT_SERIAL_NUMBER";
      case Status.InvalidNftId:
        return "INVALID_NFT_ID";
      case Status.MetadataTooLong:
        return "METADATA_TOO_LONG";
      case Status.BatchSizeLimitExceeded:
        return "BATCH_SIZE_LIMIT_EXCEEDED";
      case Status.InvalidQueryRange:
        return "INVALID_QUERY_RANGE";
      case Status.FractionDividesByZero:
        return "FRACTION_DIVIDES_BY_ZERO";
      case Status.InsufficientPayerBalanceForCustomFee:
        return "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE";
      case Status.CustomFeesListTooLong:
        return "CUSTOM_FEES_LIST_TOO_LONG";
      case Status.InvalidCustomFeeCollector:
        return "INVALID_CUSTOM_FEE_COLLECTOR";
      case Status.InvalidTokenIdInCustomFees:
        return "INVALID_TOKEN_ID_IN_CUSTOM_FEES";
      case Status.TokenNotAssociatedToFeeCollector:
        return "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR";
      case Status.TokenMaxSupplyReached:
        return "TOKEN_MAX_SUPPLY_REACHED";
      case Status.SenderDoesNotOwnNftSerialNo:
        return "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO";
      case Status.CustomFeeNotFullySpecified:
        return "CUSTOM_FEE_NOT_FULLY_SPECIFIED";
      case Status.CustomFeeMustBePositive:
        return "CUSTOM_FEE_MUST_BE_POSITIVE";
      case Status.TokenHasNoFeeScheduleKey:
        return "TOKEN_HAS_NO_FEE_SCHEDULE_KEY";
      case Status.CustomFeeOutsideNumericRange:
        return "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE";
      case Status.RoyaltyFractionCannotExceedOne:
        return "ROYALTY_FRACTION_CANNOT_EXCEED_ONE";
      case Status.FractionalFeeMaxAmountLessThanMinAmount:
        return "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT";
      case Status.CustomScheduleAlreadyHasNoFees:
        return "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES";
      case Status.CustomFeeDenominationMustBeFungibleCommon:
        return "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON";
      case Status.CustomFractionalFeeOnlyAllowedForFungibleCommon:
        return "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
      case Status.InvalidCustomFeeScheduleKey:
        return "INVALID_CUSTOM_FEE_SCHEDULE_KEY";
      case Status.InvalidTokenMintMetadata:
        return "INVALID_TOKEN_MINT_METADATA";
      case Status.InvalidTokenBurnMetadata:
        return "INVALID_TOKEN_BURN_METADATA";
      case Status.CurrentTreasuryStillOwnsNfts:
        return "CURRENT_TREASURY_STILL_OWNS_NFTS";
      case Status.AccountStillOwnsNfts:
        return "ACCOUNT_STILL_OWNS_NFTS";
      case Status.TreasuryMustOwnBurnedNft:
        return "TREASURY_MUST_OWN_BURNED_NFT";
      case Status.AccountDoesNotOwnWipedNft:
        return "ACCOUNT_DOES_NOT_OWN_WIPED_NFT";
      case Status.AccountAmountTransfersOnlyAllowedForFungibleCommon:
        return "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
      case Status.MaxNftsInPriceRegimeHaveBeenMinted:
        return "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED";
      case Status.PayerAccountDeleted:
        return "PAYER_ACCOUNT_DELETED";
      case Status.CustomFeeChargingExceededMaxRecursionDepth:
        return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH";
      case Status.CustomFeeChargingExceededMaxAccountAmounts:
        return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS";
      case Status.InsufficientSenderAccountBalanceForCustomFee:
        return "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE";
      case Status.SerialNumberLimitReached:
        return "SERIAL_NUMBER_LIMIT_REACHED";
      case Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique:
        return "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE";
      case Status.NoRemainingAutomaticAssociations:
        return "NO_REMAINING_AUTOMATIC_ASSOCIATIONS";
      case Status.ExistingAutomaticAssociationsExceedGivenLimit:
        return "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT";
      case Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit:
        return "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT";
      case Status.TokenIsPaused:
        return "TOKEN_IS_PAUSED";
      case Status.TokenHasNoPauseKey:
        return "TOKEN_HAS_NO_PAUSE_KEY";
      case Status.InvalidPauseKey:
        return "INVALID_PAUSE_KEY";
      case Status.FreezeUpdateFileDoesNotExist:
        return "FREEZE_UPDATE_FILE_DOES_NOT_EXIST";
      case Status.FreezeUpdateFileHashDoesNotMatch:
        return "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH";
      case Status.NoUpgradeHasBeenPrepared:
        return "NO_UPGRADE_HAS_BEEN_PREPARED";
      case Status.NoFreezeIsScheduled:
        return "NO_FREEZE_IS_SCHEDULED";
      case Status.UpdateFileHashChangedSincePrepareUpgrade:
        return "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE";
      case Status.FreezeStartTimeMustBeFuture:
        return "FREEZE_START_TIME_MUST_BE_FUTURE";
      case Status.PreparedUpdateFileIsImmutable:
        return "PREPARED_UPDATE_FILE_IS_IMMUTABLE";
      case Status.FreezeAlreadyScheduled:
        return "FREEZE_ALREADY_SCHEDULED";
      case Status.FreezeUpgradeInProgress:
        return "FREEZE_UPGRADE_IN_PROGRESS";
      case Status.UpdateFileIdDoesNotMatchPrepared:
        return "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED";
      case Status.UpdateFileHashDoesNotMatchPrepared:
        return "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED";
      case Status.ConsensusGasExhausted:
        return "CONSENSUS_GAS_EXHAUSTED";
      case Status.RevertedSuccess:
        return "REVERTED_SUCCESS";
      case Status.MaxStorageInPriceRegimeHasBeenUsed:
        return "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED";
      case Status.InvalidAliasKey:
        return "INVALID_ALIAS_KEY";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  static _fromCode(code) {
    switch (code) {
      case 0:
        return Status.Ok;
      case 1:
        return Status.InvalidTransaction;
      case 2:
        return Status.PayerAccountNotFound;
      case 3:
        return Status.InvalidNodeAccount;
      case 4:
        return Status.TransactionExpired;
      case 5:
        return Status.InvalidTransactionStart;
      case 6:
        return Status.InvalidTransactionDuration;
      case 7:
        return Status.InvalidSignature;
      case 8:
        return Status.MemoTooLong;
      case 9:
        return Status.InsufficientTxFee;
      case 10:
        return Status.InsufficientPayerBalance;
      case 11:
        return Status.DuplicateTransaction;
      case 12:
        return Status.Busy;
      case 13:
        return Status.NotSupported;
      case 14:
        return Status.InvalidFileId;
      case 15:
        return Status.InvalidAccountId;
      case 16:
        return Status.InvalidContractId;
      case 17:
        return Status.InvalidTransactionId;
      case 18:
        return Status.ReceiptNotFound;
      case 19:
        return Status.RecordNotFound;
      case 20:
        return Status.InvalidSolidityId;
      case 21:
        return Status.Unknown;
      case 22:
        return Status.Success;
      case 23:
        return Status.FailInvalid;
      case 24:
        return Status.FailFee;
      case 25:
        return Status.FailBalance;
      case 26:
        return Status.KeyRequired;
      case 27:
        return Status.BadEncoding;
      case 28:
        return Status.InsufficientAccountBalance;
      case 29:
        return Status.InvalidSolidityAddress;
      case 30:
        return Status.InsufficientGas;
      case 31:
        return Status.ContractSizeLimitExceeded;
      case 32:
        return Status.LocalCallModificationException;
      case 33:
        return Status.ContractRevertExecuted;
      case 34:
        return Status.ContractExecutionException;
      case 35:
        return Status.InvalidReceivingNodeAccount;
      case 36:
        return Status.MissingQueryHeader;
      case 37:
        return Status.AccountUpdateFailed;
      case 38:
        return Status.InvalidKeyEncoding;
      case 39:
        return Status.NullSolidityAddress;
      case 40:
        return Status.ContractUpdateFailed;
      case 41:
        return Status.InvalidQueryHeader;
      case 42:
        return Status.InvalidFeeSubmitted;
      case 43:
        return Status.InvalidPayerSignature;
      case 44:
        return Status.KeyNotProvided;
      case 45:
        return Status.InvalidExpirationTime;
      case 46:
        return Status.NoWaclKey;
      case 47:
        return Status.FileContentEmpty;
      case 48:
        return Status.InvalidAccountAmounts;
      case 49:
        return Status.EmptyTransactionBody;
      case 50:
        return Status.InvalidTransactionBody;
      case 51:
        return Status.InvalidSignatureTypeMismatchingKey;
      case 52:
        return Status.InvalidSignatureCountMismatchingKey;
      case 53:
        return Status.EmptyLiveHashBody;
      case 54:
        return Status.EmptyLiveHash;
      case 55:
        return Status.EmptyLiveHashKeys;
      case 56:
        return Status.InvalidLiveHashSize;
      case 57:
        return Status.EmptyQueryBody;
      case 58:
        return Status.EmptyLiveHashQuery;
      case 59:
        return Status.LiveHashNotFound;
      case 60:
        return Status.AccountIdDoesNotExist;
      case 61:
        return Status.LiveHashAlreadyExists;
      case 62:
        return Status.InvalidFileWacl;
      case 63:
        return Status.SerializationFailed;
      case 64:
        return Status.TransactionOversize;
      case 65:
        return Status.TransactionTooManyLayers;
      case 66:
        return Status.ContractDeleted;
      case 67:
        return Status.PlatformNotActive;
      case 68:
        return Status.KeyPrefixMismatch;
      case 69:
        return Status.PlatformTransactionNotCreated;
      case 70:
        return Status.InvalidRenewalPeriod;
      case 71:
        return Status.InvalidPayerAccountId;
      case 72:
        return Status.AccountDeleted;
      case 73:
        return Status.FileDeleted;
      case 74:
        return Status.AccountRepeatedInAccountAmounts;
      case 75:
        return Status.SettingNegativeAccountBalance;
      case 76:
        return Status.ObtainerRequired;
      case 77:
        return Status.ObtainerSameContractId;
      case 78:
        return Status.ObtainerDoesNotExist;
      case 79:
        return Status.ModifyingImmutableContract;
      case 80:
        return Status.FileSystemException;
      case 81:
        return Status.AutorenewDurationNotInRange;
      case 82:
        return Status.ErrorDecodingBytestring;
      case 83:
        return Status.ContractFileEmpty;
      case 84:
        return Status.ContractBytecodeEmpty;
      case 85:
        return Status.InvalidInitialBalance;
      case 86:
        return Status.InvalidReceiveRecordThreshold;
      case 87:
        return Status.InvalidSendRecordThreshold;
      case 88:
        return Status.AccountIsNotGenesisAccount;
      case 89:
        return Status.PayerAccountUnauthorized;
      case 90:
        return Status.InvalidFreezeTransactionBody;
      case 91:
        return Status.FreezeTransactionBodyNotFound;
      case 92:
        return Status.TransferListSizeLimitExceeded;
      case 93:
        return Status.ResultSizeLimitExceeded;
      case 94:
        return Status.NotSpecialAccount;
      case 95:
        return Status.ContractNegativeGas;
      case 96:
        return Status.ContractNegativeValue;
      case 97:
        return Status.InvalidFeeFile;
      case 98:
        return Status.InvalidExchangeRateFile;
      case 99:
        return Status.InsufficientLocalCallGas;
      case 100:
        return Status.EntityNotAllowedToDelete;
      case 101:
        return Status.AuthorizationFailed;
      case 102:
        return Status.FileUploadedProtoInvalid;
      case 103:
        return Status.FileUploadedProtoNotSavedToDisk;
      case 104:
        return Status.FeeScheduleFilePartUploaded;
      case 105:
        return Status.ExchangeRateChangeLimitExceeded;
      case 106:
        return Status.MaxContractStorageExceeded;
      case 107:
        return Status.TransferAccountSameAsDeleteAccount;
      case 108:
        return Status.TotalLedgerBalanceInvalid;
      case 110:
        return Status.ExpirationReductionNotAllowed;
      case 111:
        return Status.MaxGasLimitExceeded;
      case 112:
        return Status.MaxFileSizeExceeded;
      case 113:
        return Status.ReceiverSigRequired;
      case 150:
        return Status.InvalidTopicId;
      case 155:
        return Status.InvalidAdminKey;
      case 156:
        return Status.InvalidSubmitKey;
      case 157:
        return Status.Unauthorized;
      case 158:
        return Status.InvalidTopicMessage;
      case 159:
        return Status.InvalidAutorenewAccount;
      case 160:
        return Status.AutorenewAccountNotAllowed;
      case 162:
        return Status.TopicExpired;
      case 163:
        return Status.InvalidChunkNumber;
      case 164:
        return Status.InvalidChunkTransactionId;
      case 165:
        return Status.AccountFrozenForToken;
      case 166:
        return Status.TokensPerAccountLimitExceeded;
      case 167:
        return Status.InvalidTokenId;
      case 168:
        return Status.InvalidTokenDecimals;
      case 169:
        return Status.InvalidTokenInitialSupply;
      case 170:
        return Status.InvalidTreasuryAccountForToken;
      case 171:
        return Status.InvalidTokenSymbol;
      case 172:
        return Status.TokenHasNoFreezeKey;
      case 173:
        return Status.TransfersNotZeroSumForToken;
      case 174:
        return Status.MissingTokenSymbol;
      case 175:
        return Status.TokenSymbolTooLong;
      case 176:
        return Status.AccountKycNotGrantedForToken;
      case 177:
        return Status.TokenHasNoKycKey;
      case 178:
        return Status.InsufficientTokenBalance;
      case 179:
        return Status.TokenWasDeleted;
      case 180:
        return Status.TokenHasNoSupplyKey;
      case 181:
        return Status.TokenHasNoWipeKey;
      case 182:
        return Status.InvalidTokenMintAmount;
      case 183:
        return Status.InvalidTokenBurnAmount;
      case 184:
        return Status.TokenNotAssociatedToAccount;
      case 185:
        return Status.CannotWipeTokenTreasuryAccount;
      case 186:
        return Status.InvalidKycKey;
      case 187:
        return Status.InvalidWipeKey;
      case 188:
        return Status.InvalidFreezeKey;
      case 189:
        return Status.InvalidSupplyKey;
      case 190:
        return Status.MissingTokenName;
      case 191:
        return Status.TokenNameTooLong;
      case 192:
        return Status.InvalidWipingAmount;
      case 193:
        return Status.TokenIsImmutable;
      case 194:
        return Status.TokenAlreadyAssociatedToAccount;
      case 195:
        return Status.TransactionRequiresZeroTokenBalances;
      case 196:
        return Status.AccountIsTreasury;
      case 197:
        return Status.TokenIdRepeatedInTokenList;
      case 198:
        return Status.TokenTransferListSizeLimitExceeded;
      case 199:
        return Status.EmptyTokenTransferBody;
      case 200:
        return Status.EmptyTokenTransferAccountAmounts;
      case 201:
        return Status.InvalidScheduleId;
      case 202:
        return Status.ScheduleIsImmutable;
      case 203:
        return Status.InvalidSchedulePayerId;
      case 204:
        return Status.InvalidScheduleAccountId;
      case 205:
        return Status.NoNewValidSignatures;
      case 206:
        return Status.UnresolvableRequiredSigners;
      case 207:
        return Status.ScheduledTransactionNotInWhitelist;
      case 208:
        return Status.SomeSignaturesWereInvalid;
      case 209:
        return Status.TransactionIdFieldNotAllowed;
      case 210:
        return Status.IdenticalScheduleAlreadyCreated;
      case 211:
        return Status.InvalidZeroByteInString;
      case 212:
        return Status.ScheduleAlreadyDeleted;
      case 213:
        return Status.ScheduleAlreadyExecuted;
      case 214:
        return Status.MessageSizeTooLarge;
      case 215:
        return Status.OperationRepeatedInBucketGroups;
      case 216:
        return Status.BucketCapacityOverflow;
      case 217:
        return Status.NodeCapacityNotSufficientForOperation;
      case 218:
        return Status.BucketHasNoThrottleGroups;
      case 219:
        return Status.ThrottleGroupHasZeroOpsPerSec;
      case 220:
        return Status.SuccessButMissingExpectedOperation;
      case 221:
        return Status.UnparseableThrottleDefinitions;
      case 222:
        return Status.InvalidThrottleDefinitions;
      case 223:
        return Status.AccountExpiredAndPendingRemoval;
      case 224:
        return Status.InvalidTokenMaxSupply;
      case 225:
        return Status.InvalidTokenNftSerialNumber;
      case 226:
        return Status.InvalidNftId;
      case 227:
        return Status.MetadataTooLong;
      case 228:
        return Status.BatchSizeLimitExceeded;
      case 229:
        return Status.InvalidQueryRange;
      case 230:
        return Status.FractionDividesByZero;
      case 231:
        return Status.InsufficientPayerBalanceForCustomFee;
      case 232:
        return Status.CustomFeesListTooLong;
      case 233:
        return Status.InvalidCustomFeeCollector;
      case 234:
        return Status.InvalidTokenIdInCustomFees;
      case 235:
        return Status.TokenNotAssociatedToFeeCollector;
      case 236:
        return Status.TokenMaxSupplyReached;
      case 237:
        return Status.SenderDoesNotOwnNftSerialNo;
      case 238:
        return Status.CustomFeeNotFullySpecified;
      case 239:
        return Status.CustomFeeMustBePositive;
      case 240:
        return Status.TokenHasNoFeeScheduleKey;
      case 241:
        return Status.CustomFeeOutsideNumericRange;
      case 242:
        return Status.RoyaltyFractionCannotExceedOne;
      case 243:
        return Status.FractionalFeeMaxAmountLessThanMinAmount;
      case 244:
        return Status.CustomScheduleAlreadyHasNoFees;
      case 245:
        return Status.CustomFeeDenominationMustBeFungibleCommon;
      case 246:
        return Status.CustomFractionalFeeOnlyAllowedForFungibleCommon;
      case 247:
        return Status.InvalidCustomFeeScheduleKey;
      case 248:
        return Status.InvalidTokenMintMetadata;
      case 249:
        return Status.InvalidTokenBurnMetadata;
      case 250:
        return Status.CurrentTreasuryStillOwnsNfts;
      case 251:
        return Status.AccountStillOwnsNfts;
      case 252:
        return Status.TreasuryMustOwnBurnedNft;
      case 253:
        return Status.AccountDoesNotOwnWipedNft;
      case 254:
        return Status.AccountAmountTransfersOnlyAllowedForFungibleCommon;
      case 255:
        return Status.MaxNftsInPriceRegimeHaveBeenMinted;
      case 256:
        return Status.PayerAccountDeleted;
      case 257:
        return Status.CustomFeeChargingExceededMaxRecursionDepth;
      case 258:
        return Status.CustomFeeChargingExceededMaxAccountAmounts;
      case 259:
        return Status.InsufficientSenderAccountBalanceForCustomFee;
      case 260:
        return Status.SerialNumberLimitReached;
      case 261:
        return Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique;
      case 262:
        return Status.NoRemainingAutomaticAssociations;
      case 263:
        return Status.ExistingAutomaticAssociationsExceedGivenLimit;
      case 264:
        return Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit;
      case 265:
        return Status.TokenIsPaused;
      case 266:
        return Status.TokenHasNoPauseKey;
      case 267:
        return Status.InvalidPauseKey;
      case 268:
        return Status.FreezeUpdateFileDoesNotExist;
      case 269:
        return Status.FreezeUpdateFileHashDoesNotMatch;
      case 270:
        return Status.NoUpgradeHasBeenPrepared;
      case 271:
        return Status.NoFreezeIsScheduled;
      case 272:
        return Status.UpdateFileHashChangedSincePrepareUpgrade;
      case 273:
        return Status.FreezeStartTimeMustBeFuture;
      case 274:
        return Status.PreparedUpdateFileIsImmutable;
      case 275:
        return Status.FreezeAlreadyScheduled;
      case 276:
        return Status.FreezeUpgradeInProgress;
      case 277:
        return Status.UpdateFileIdDoesNotMatchPrepared;
      case 278:
        return Status.UpdateFileHashDoesNotMatchPrepared;
      case 279:
        return Status.ConsensusGasExhausted;
      case 280:
        return Status.RevertedSuccess;
      case 281:
        return Status.MaxStorageInPriceRegimeHasBeenUsed;
      case 282:
        return Status.InvalidAliasKey;
      default:
        throw new Error(`(BUG) Status.fromCode() does not handle code: ${code}`);
    }
  }
  valueOf() {
    return this._code;
  }
};
Status.Ok = new Status(0);
Status.InvalidTransaction = new Status(1);
Status.PayerAccountNotFound = new Status(2);
Status.InvalidNodeAccount = new Status(3);
Status.TransactionExpired = new Status(4);
Status.InvalidTransactionStart = new Status(5);
Status.InvalidTransactionDuration = new Status(6);
Status.InvalidSignature = new Status(7);
Status.MemoTooLong = new Status(8);
Status.InsufficientTxFee = new Status(9);
Status.InsufficientPayerBalance = new Status(10);
Status.DuplicateTransaction = new Status(11);
Status.Busy = new Status(12);
Status.NotSupported = new Status(13);
Status.InvalidFileId = new Status(14);
Status.InvalidAccountId = new Status(15);
Status.InvalidContractId = new Status(16);
Status.InvalidTransactionId = new Status(17);
Status.ReceiptNotFound = new Status(18);
Status.RecordNotFound = new Status(19);
Status.InvalidSolidityId = new Status(20);
Status.Unknown = new Status(21);
Status.Success = new Status(22);
Status.FailInvalid = new Status(23);
Status.FailFee = new Status(24);
Status.FailBalance = new Status(25);
Status.KeyRequired = new Status(26);
Status.BadEncoding = new Status(27);
Status.InsufficientAccountBalance = new Status(28);
Status.InvalidSolidityAddress = new Status(29);
Status.InsufficientGas = new Status(30);
Status.ContractSizeLimitExceeded = new Status(31);
Status.LocalCallModificationException = new Status(32);
Status.ContractRevertExecuted = new Status(33);
Status.ContractExecutionException = new Status(34);
Status.InvalidReceivingNodeAccount = new Status(35);
Status.MissingQueryHeader = new Status(36);
Status.AccountUpdateFailed = new Status(37);
Status.InvalidKeyEncoding = new Status(38);
Status.NullSolidityAddress = new Status(39);
Status.ContractUpdateFailed = new Status(40);
Status.InvalidQueryHeader = new Status(41);
Status.InvalidFeeSubmitted = new Status(42);
Status.InvalidPayerSignature = new Status(43);
Status.KeyNotProvided = new Status(44);
Status.InvalidExpirationTime = new Status(45);
Status.NoWaclKey = new Status(46);
Status.FileContentEmpty = new Status(47);
Status.InvalidAccountAmounts = new Status(48);
Status.EmptyTransactionBody = new Status(49);
Status.InvalidTransactionBody = new Status(50);
Status.InvalidSignatureTypeMismatchingKey = new Status(51);
Status.InvalidSignatureCountMismatchingKey = new Status(52);
Status.EmptyLiveHashBody = new Status(53);
Status.EmptyLiveHash = new Status(54);
Status.EmptyLiveHashKeys = new Status(55);
Status.InvalidLiveHashSize = new Status(56);
Status.EmptyQueryBody = new Status(57);
Status.EmptyLiveHashQuery = new Status(58);
Status.LiveHashNotFound = new Status(59);
Status.AccountIdDoesNotExist = new Status(60);
Status.LiveHashAlreadyExists = new Status(61);
Status.InvalidFileWacl = new Status(62);
Status.SerializationFailed = new Status(63);
Status.TransactionOversize = new Status(64);
Status.TransactionTooManyLayers = new Status(65);
Status.ContractDeleted = new Status(66);
Status.PlatformNotActive = new Status(67);
Status.KeyPrefixMismatch = new Status(68);
Status.PlatformTransactionNotCreated = new Status(69);
Status.InvalidRenewalPeriod = new Status(70);
Status.InvalidPayerAccountId = new Status(71);
Status.AccountDeleted = new Status(72);
Status.FileDeleted = new Status(73);
Status.AccountRepeatedInAccountAmounts = new Status(74);
Status.SettingNegativeAccountBalance = new Status(75);
Status.ObtainerRequired = new Status(76);
Status.ObtainerSameContractId = new Status(77);
Status.ObtainerDoesNotExist = new Status(78);
Status.ModifyingImmutableContract = new Status(79);
Status.FileSystemException = new Status(80);
Status.AutorenewDurationNotInRange = new Status(81);
Status.ErrorDecodingBytestring = new Status(82);
Status.ContractFileEmpty = new Status(83);
Status.ContractBytecodeEmpty = new Status(84);
Status.InvalidInitialBalance = new Status(85);
Status.InvalidReceiveRecordThreshold = new Status(86);
Status.InvalidSendRecordThreshold = new Status(87);
Status.AccountIsNotGenesisAccount = new Status(88);
Status.PayerAccountUnauthorized = new Status(89);
Status.InvalidFreezeTransactionBody = new Status(90);
Status.FreezeTransactionBodyNotFound = new Status(91);
Status.TransferListSizeLimitExceeded = new Status(92);
Status.ResultSizeLimitExceeded = new Status(93);
Status.NotSpecialAccount = new Status(94);
Status.ContractNegativeGas = new Status(95);
Status.ContractNegativeValue = new Status(96);
Status.InvalidFeeFile = new Status(97);
Status.InvalidExchangeRateFile = new Status(98);
Status.InsufficientLocalCallGas = new Status(99);
Status.EntityNotAllowedToDelete = new Status(100);
Status.AuthorizationFailed = new Status(101);
Status.FileUploadedProtoInvalid = new Status(102);
Status.FileUploadedProtoNotSavedToDisk = new Status(103);
Status.FeeScheduleFilePartUploaded = new Status(104);
Status.ExchangeRateChangeLimitExceeded = new Status(105);
Status.MaxContractStorageExceeded = new Status(106);
Status.TransferAccountSameAsDeleteAccount = new Status(107);
Status.TotalLedgerBalanceInvalid = new Status(108);
Status.ExpirationReductionNotAllowed = new Status(110);
Status.MaxGasLimitExceeded = new Status(111);
Status.MaxFileSizeExceeded = new Status(112);
Status.ReceiverSigRequired = new Status(113);
Status.InvalidTopicId = new Status(150);
Status.InvalidAdminKey = new Status(155);
Status.InvalidSubmitKey = new Status(156);
Status.Unauthorized = new Status(157);
Status.InvalidTopicMessage = new Status(158);
Status.InvalidAutorenewAccount = new Status(159);
Status.AutorenewAccountNotAllowed = new Status(160);
Status.TopicExpired = new Status(162);
Status.InvalidChunkNumber = new Status(163);
Status.InvalidChunkTransactionId = new Status(164);
Status.AccountFrozenForToken = new Status(165);
Status.TokensPerAccountLimitExceeded = new Status(166);
Status.InvalidTokenId = new Status(167);
Status.InvalidTokenDecimals = new Status(168);
Status.InvalidTokenInitialSupply = new Status(169);
Status.InvalidTreasuryAccountForToken = new Status(170);
Status.InvalidTokenSymbol = new Status(171);
Status.TokenHasNoFreezeKey = new Status(172);
Status.TransfersNotZeroSumForToken = new Status(173);
Status.MissingTokenSymbol = new Status(174);
Status.TokenSymbolTooLong = new Status(175);
Status.AccountKycNotGrantedForToken = new Status(176);
Status.TokenHasNoKycKey = new Status(177);
Status.InsufficientTokenBalance = new Status(178);
Status.TokenWasDeleted = new Status(179);
Status.TokenHasNoSupplyKey = new Status(180);
Status.TokenHasNoWipeKey = new Status(181);
Status.InvalidTokenMintAmount = new Status(182);
Status.InvalidTokenBurnAmount = new Status(183);
Status.TokenNotAssociatedToAccount = new Status(184);
Status.CannotWipeTokenTreasuryAccount = new Status(185);
Status.InvalidKycKey = new Status(186);
Status.InvalidWipeKey = new Status(187);
Status.InvalidFreezeKey = new Status(188);
Status.InvalidSupplyKey = new Status(189);
Status.MissingTokenName = new Status(190);
Status.TokenNameTooLong = new Status(191);
Status.InvalidWipingAmount = new Status(192);
Status.TokenIsImmutable = new Status(193);
Status.TokenAlreadyAssociatedToAccount = new Status(194);
Status.TransactionRequiresZeroTokenBalances = new Status(195);
Status.AccountIsTreasury = new Status(196);
Status.TokenIdRepeatedInTokenList = new Status(197);
Status.TokenTransferListSizeLimitExceeded = new Status(198);
Status.EmptyTokenTransferBody = new Status(199);
Status.EmptyTokenTransferAccountAmounts = new Status(200);
Status.InvalidScheduleId = new Status(201);
Status.ScheduleIsImmutable = new Status(202);
Status.InvalidSchedulePayerId = new Status(203);
Status.InvalidScheduleAccountId = new Status(204);
Status.NoNewValidSignatures = new Status(205);
Status.UnresolvableRequiredSigners = new Status(206);
Status.ScheduledTransactionNotInWhitelist = new Status(207);
Status.SomeSignaturesWereInvalid = new Status(208);
Status.TransactionIdFieldNotAllowed = new Status(209);
Status.IdenticalScheduleAlreadyCreated = new Status(210);
Status.InvalidZeroByteInString = new Status(211);
Status.ScheduleAlreadyDeleted = new Status(212);
Status.ScheduleAlreadyExecuted = new Status(213);
Status.MessageSizeTooLarge = new Status(214);
Status.OperationRepeatedInBucketGroups = new Status(215);
Status.BucketCapacityOverflow = new Status(216);
Status.NodeCapacityNotSufficientForOperation = new Status(217);
Status.BucketHasNoThrottleGroups = new Status(218);
Status.ThrottleGroupHasZeroOpsPerSec = new Status(219);
Status.SuccessButMissingExpectedOperation = new Status(220);
Status.UnparseableThrottleDefinitions = new Status(221);
Status.InvalidThrottleDefinitions = new Status(222);
Status.AccountExpiredAndPendingRemoval = new Status(223);
Status.InvalidTokenMaxSupply = new Status(224);
Status.InvalidTokenNftSerialNumber = new Status(225);
Status.InvalidNftId = new Status(226);
Status.MetadataTooLong = new Status(227);
Status.BatchSizeLimitExceeded = new Status(228);
Status.InvalidQueryRange = new Status(229);
Status.FractionDividesByZero = new Status(230);
Status.InsufficientPayerBalanceForCustomFee = new Status(231);
Status.CustomFeesListTooLong = new Status(232);
Status.InvalidCustomFeeCollector = new Status(233);
Status.InvalidTokenIdInCustomFees = new Status(234);
Status.TokenNotAssociatedToFeeCollector = new Status(235);
Status.TokenMaxSupplyReached = new Status(236);
Status.SenderDoesNotOwnNftSerialNo = new Status(237);
Status.CustomFeeNotFullySpecified = new Status(238);
Status.CustomFeeMustBePositive = new Status(239);
Status.TokenHasNoFeeScheduleKey = new Status(240);
Status.CustomFeeOutsideNumericRange = new Status(241);
Status.RoyaltyFractionCannotExceedOne = new Status(242);
Status.FractionalFeeMaxAmountLessThanMinAmount = new Status(243);
Status.CustomScheduleAlreadyHasNoFees = new Status(244);
Status.CustomFeeDenominationMustBeFungibleCommon = new Status(245);
Status.CustomFractionalFeeOnlyAllowedForFungibleCommon = new Status(246);
Status.InvalidCustomFeeScheduleKey = new Status(247);
Status.InvalidTokenMintMetadata = new Status(248);
Status.InvalidTokenBurnMetadata = new Status(249);
Status.CurrentTreasuryStillOwnsNfts = new Status(250);
Status.AccountStillOwnsNfts = new Status(251);
Status.TreasuryMustOwnBurnedNft = new Status(252);
Status.AccountDoesNotOwnWipedNft = new Status(253);
Status.AccountAmountTransfersOnlyAllowedForFungibleCommon = new Status(254);
Status.MaxNftsInPriceRegimeHaveBeenMinted = new Status(255);
Status.PayerAccountDeleted = new Status(256);
Status.CustomFeeChargingExceededMaxRecursionDepth = new Status(257);
Status.CustomFeeChargingExceededMaxAccountAmounts = new Status(258);
Status.InsufficientSenderAccountBalanceForCustomFee = new Status(259);
Status.SerialNumberLimitReached = new Status(260);
Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique = new Status(261);
Status.NoRemainingAutomaticAssociations = new Status(262);
Status.ExistingAutomaticAssociationsExceedGivenLimit = new Status(263);
Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit = new Status(264);
Status.TokenIsPaused = new Status(265);
Status.TokenHasNoPauseKey = new Status(266);
Status.InvalidPauseKey = new Status(267);
Status.FreezeUpdateFileDoesNotExist = new Status(268);
Status.FreezeUpdateFileHashDoesNotMatch = new Status(269);
Status.NoUpgradeHasBeenPrepared = new Status(270);
Status.NoFreezeIsScheduled = new Status(271);
Status.UpdateFileHashChangedSincePrepareUpgrade = new Status(272);
Status.FreezeStartTimeMustBeFuture = new Status(273);
Status.PreparedUpdateFileIsImmutable = new Status(274);
Status.FreezeAlreadyScheduled = new Status(275);
Status.FreezeUpgradeInProgress = new Status(276);
Status.UpdateFileIdDoesNotMatchPrepared = new Status(277);
Status.UpdateFileHashDoesNotMatchPrepared = new Status(278);
Status.ConsensusGasExhausted = new Status(279);
Status.RevertedSuccess = new Status(280);
Status.MaxStorageInPriceRegimeHasBeenUsed = new Status(281);
Status.InvalidAliasKey = new Status(282);

// node_modules/@hashgraph/sdk/src/account/AccountId.js
var import_long3 = __toModule(require_long());

// node_modules/@hashgraph/sdk/src/EntityIdHelper.js
var import_long2 = __toModule(require_long());

// node_modules/@hashgraph/sdk/src/encoding/hex.browser.js
var byteToHex2 = [];
for (let n = 0; n <= 255; n += 1) {
  byteToHex2.push(n.toString(16).padStart(2, "0"));
}
function encode3(data) {
  let string = "";
  for (const byte of data) {
    string += byteToHex2[byte];
  }
  return string;
}
function decode5(text) {
  const str = text.startsWith("0x") ? text.substring(2) : text;
  const result = str.match(/.{1,2}/gu);
  return new Uint8Array((result == null ? [] : result).map((byte) => parseInt(byte, 16)));
}

// node_modules/@hashgraph/sdk/src/BadEntityIdError.js
var BadEntityIdException = class extends Error {
  constructor(shard, realm, num, presentChecksum, expectedChecksum) {
    super(`Entity ID ${shard.toString()}.${realm.toString()}.${num.toString()}-${presentChecksum} was incorrect.`);
    this.name = "BadEntityIdException";
    this.shard = shard;
    this.realm = realm;
    this.num = num;
    this.presentChecksum = presentChecksum;
    this.expectedChecksum = expectedChecksum;
  }
};

// node_modules/@hashgraph/sdk/src/util.js
var import_long = __toModule(require_long());
var REQUIRE_NON_NULL_ERROR = "This value cannot be null | undefined.";
var REQUIRE_STRING_OR_UINT8ARRAY_ERROR = "This value must be a string or Uint8Array.";
var REQUIRE_ARRAY_ERROR = "The provided variable must be an Array.";
var FUNCTION_CONVERT_TO_BIGNUMBER_ERROR = "This value must be a String, Number, or BigNumber to be converted.";
var FUNCTION_CONVERT_TO_NUMBER_ERROR = "This value must be a String, Number, or BigNumber to be converted.";
var FUNCTION_CONVERT_TO_NUMBER_PARSE_ERROR = "Unable to parse given variable. Returns NaN.";
function isNonNull(variable) {
  if (variable == null || variable == void 0) {
    return false;
  } else {
    return true;
  }
}
function isUint8Array(variable) {
  return isNonNull(variable) && variable instanceof Uint8Array;
}
function isNumber(variable) {
  return isNonNull(variable) && (typeof variable == "number" || variable instanceof Number);
}
function isBigNumber(variable) {
  return isNonNull(variable) && variable instanceof bignumber_default;
}
function isLong(variable) {
  return isNonNull(variable) && variable instanceof import_long.default;
}
function isString(variable) {
  return isNonNull(variable) && typeof variable == "string";
}
function isStringOrUint8Array(variable) {
  return isNonNull(variable) && (isString(variable) || isUint8Array(variable));
}
function requireNonNull(variable) {
  if (!isNonNull(variable)) {
    throw new Error(REQUIRE_NON_NULL_ERROR);
  } else {
    return variable;
  }
}
function requireStringOrUint8Array(variable) {
  if (isStringOrUint8Array(requireNonNull(variable))) {
    return variable;
  } else {
    throw new Error(REQUIRE_STRING_OR_UINT8ARRAY_ERROR);
  }
}
function convertToBigNumber(variable) {
  requireNonNull(variable);
  if (isBigNumber(variable) || isString(variable) || isNumber(variable) || isLong(variable)) {
    return new bignumber_default(variable);
  }
  throw new Error(FUNCTION_CONVERT_TO_BIGNUMBER_ERROR);
}
function convertToBigNumberArray(variable) {
  if (variable instanceof Array) {
    return variable.map(convertToBigNumber);
  } else {
    throw new Error(REQUIRE_ARRAY_ERROR);
  }
}
function convertToNumber(variable) {
  requireNonNull(variable);
  if (isBigNumber(variable) || isString(variable) || isNumber(variable) || isLong(variable)) {
    const num = parseInt(variable);
    if (isNaN(num)) {
      throw new Error(FUNCTION_CONVERT_TO_NUMBER_PARSE_ERROR);
    } else {
      return num;
    }
  } else {
    throw new Error(FUNCTION_CONVERT_TO_NUMBER_ERROR);
  }
}
function safeView(arr, offset = 0, length = arr.byteLength) {
  if (!(Number.isInteger(offset) && offset >= 0))
    throw new Error("Invalid offset!");
  if (!(Number.isInteger(length) && length >= 0))
    throw new Error("Invalid length!");
  return new DataView(arr.buffer, arr.byteOffset + offset, Math.min(length, arr.byteLength - offset));
}

// node_modules/@hashgraph/sdk/src/EntityIdHelper.js
var regex = RegExp("^(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))(?:-([a-z]{5}))?$");
function constructor(props, realm, numOrAliasKey) {
  let shard_ = import_long2.default.ZERO;
  let realm_ = import_long2.default.ZERO;
  let num_ = import_long2.default.ZERO;
  let aliasKey_;
  if (numOrAliasKey instanceof PublicKey2) {
    aliasKey_ = numOrAliasKey;
  }
  if (typeof props === "number" || import_long2.default.isLong(props)) {
    if (realm == null || typeof realm === "string") {
      num_ = import_long2.default.fromValue(props);
    } else {
      shard_ = import_long2.default.fromValue(props);
      realm_ = import_long2.default.fromValue(realm);
      num_ = numOrAliasKey != null && !(numOrAliasKey instanceof PublicKey2) ? import_long2.default.fromValue(numOrAliasKey) : import_long2.default.ZERO;
    }
  } else {
    shard_ = import_long2.default.fromValue(props.shard != null ? props.shard : 0);
    realm_ = import_long2.default.fromValue(props.realm != null ? props.realm : 0);
    num_ = import_long2.default.fromValue(props.num != null ? props.num : 0);
    aliasKey_ = props.aliasKey;
  }
  if (shard_.isNegative() || realm_.isNegative() || num_.isNegative()) {
    throw new Error("negative numbers are not allowed in IDs");
  }
  return {
    shard: shard_,
    realm: realm_,
    num: num_,
    aliasKey: aliasKey_
  };
}
function compare2(a, b) {
  let comparison = a[0].compare(b[0]);
  if (comparison != 0) {
    return comparison;
  }
  comparison = a[1].compare(b[1]);
  if (comparison != 0) {
    return comparison;
  }
  return a[2].compare(b[2]);
}
function fromString(text) {
  const [id, checksum] = text.split("-");
  const parts = id.split(".");
  for (const part of parts) {
    if (part === "") {
      throw new Error("invalid format for entity ID");
    }
  }
  const components = parts.map(Number);
  for (const component of components) {
    if (Number.isNaN(component)) {
      throw new Error("invalid format for entity ID");
    }
  }
  let shard = import_long2.default.ZERO;
  let realm = import_long2.default.ZERO;
  let num;
  if (components.length === 1) {
    num = import_long2.default.fromNumber(components[0]);
  } else if (components.length === 3) {
    shard = import_long2.default.fromNumber(components[0]);
    realm = import_long2.default.fromNumber(components[1]);
    num = import_long2.default.fromNumber(components[2]);
  } else {
    throw new Error("invalid format for entity ID");
  }
  return {
    shard,
    realm,
    num,
    checksum,
    aliasKey: null
  };
}
function fromSolidityAddress(address) {
  const addr = address.startsWith("0x") ? decode5(address.slice(2)) : decode5(address);
  if (addr.length !== 20) {
    throw new Error(`Invalid hex encoded solidity address length:
                expected length 40, got length ${address.length}`);
  }
  const shard = import_long2.default.fromBytesBE([0, 0, 0, 0, ...addr.slice(0, 4)]);
  const realm = import_long2.default.fromBytesBE(Array.from(addr.slice(4, 12)));
  const num = import_long2.default.fromBytesBE(Array.from(addr.slice(12, 20)));
  return [shard, realm, num];
}
function toSolidityAddress(address) {
  const buffer = new Uint8Array(20);
  const view = safeView(buffer);
  const [shard, realm, num] = address;
  view.setUint32(0, convertToNumber(shard));
  view.setUint32(8, convertToNumber(realm));
  view.setUint32(16, convertToNumber(num));
  return encode3(buffer);
}
function _checksum(ledgerId, addr) {
  let answer = "";
  let d = [];
  let s0 = 0;
  let s1 = 0;
  let s = 0;
  let sh = 0;
  let c = 0;
  const p3 = 26 * 26 * 26;
  const p5 = 26 * 26 * 26 * 26 * 26;
  const ascii_a = "a".charCodeAt(0);
  const m = 1000003;
  const w = 31;
  let id = ledgerId + "000000000000";
  let h = [];
  for (var i = 0; i < id.length; i += 2) {
    h.push(parseInt(id.substring(i, i + 2), 16));
  }
  for (let i2 = 0; i2 < addr.length; i2++) {
    d.push(addr[i2] === "." ? 10 : parseInt(addr[i2], 10));
  }
  for (let i2 = 0; i2 < d.length; i2++) {
    s = (w * s + d[i2]) % p3;
    if (i2 % 2 === 0) {
      s0 = (s0 + d[i2]) % 11;
    } else {
      s1 = (s1 + d[i2]) % 11;
    }
  }
  for (let i2 = 0; i2 < h.length; i2++) {
    sh = (w * sh + h[i2]) % p5;
  }
  c = (((addr.length % 5 * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;
  c = c * m % p5;
  for (let i2 = 0; i2 < 5; i2++) {
    answer = String.fromCharCode(ascii_a + c % 26) + answer;
    c /= 26;
  }
  return answer;
}
function validateChecksum(shard, realm, num, checksum, client) {
  if (client._network._ledgerId == null || checksum == null) {
    return;
  }
  const expectedChecksum = _checksum(client._network._ledgerId, `${shard.toString()}.${realm.toString()}.${num.toString()}`);
  if (checksum != expectedChecksum) {
    throw new BadEntityIdException(shard, realm, num, checksum, expectedChecksum);
  }
}
function toStringWithChecksum(string, client) {
  if (client._network._ledgerId == null) {
    throw new Error("cannot calculate checksum with a client that does not contain a recognzied ledger ID");
  }
  const checksum = _checksum(client._network._ledgerId, string);
  return `${string}-${checksum}`;
}

// node_modules/@hashgraph/sdk/src/account/AccountId.js
var proto = __toModule(require_lib());
var regex2 = new RegExp("^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.((?:[0-9a-fA-F][0-9a-fA-F])+)$");
var AccountId = class {
  constructor(props, realm, numOrAliasKey) {
    const result = constructor(props, realm, numOrAliasKey);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this.aliasKey = result.aliasKey;
    this._checksum = null;
  }
  static fromString(text) {
    try {
      const result = fromString(text);
      const id = new AccountId(result);
      id._checksum = result.checksum;
      return id;
    } catch {
      let match = regex2.exec(text);
      if (match == null) {
        throw new Error("invalid account ID");
      }
      return new AccountId(import_long3.default.fromString(match[1]), import_long3.default.fromString(match[2]), PublicKey2.fromString(match[3]));
    }
  }
  static _fromProtobuf(id) {
    let key = id.alias != null && id.alias.length > 0 ? Key2._fromProtobufKey(proto.Key.decode(id.alias)) : null;
    if (!(key instanceof PublicKey2)) {
      key = null;
    }
    const account = key != null ? key : id.accountNum;
    return new AccountId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, account);
  }
  get checksum() {
    return this._checksum;
  }
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  validateChecksum(client) {
    if (this.aliasKey != null) {
      throw new Error("cannot calculate checksum with an account ID that has a aliasKey");
    }
    validateChecksum(this.shard, this.realm, this.num, this._checksum, client);
  }
  static fromBytes(bytes2) {
    return AccountId._fromProtobuf(proto.AccountID.decode(bytes2));
  }
  static fromSolidityAddress(address) {
    return new AccountId(...fromSolidityAddress(address));
  }
  toSolidityAddress() {
    return toSolidityAddress([this.shard, this.realm, this.num]);
  }
  _toProtobuf() {
    return {
      alias: this.aliasKey != null ? proto.Key.encode(this.aliasKey._toProtobufKey()).finish() : null,
      accountNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  toBytes() {
    return proto.AccountID.encode(this._toProtobuf()).finish();
  }
  toString() {
    const account = this.aliasKey != null ? this.aliasKey.toString() : this.num.toString();
    return `${this.shard.toString()}.${this.realm.toString()}.${account}`;
  }
  toStringWithChecksum(client) {
    if (this.aliasKey != null) {
      throw new Error("cannot calculate checksum with an account ID that has a aliasKey");
    }
    return toStringWithChecksum(this.toString(), client);
  }
  equals(other) {
    let account = false;
    if (this.aliasKey != null && other.aliasKey != null) {
      account = this.aliasKey.equals(other.aliasKey);
    } else if (this.aliasKey == null && other.aliasKey == null) {
      account = this.num.eq(other.num);
    }
    return this.shard.eq(other.shard) && this.realm.eq(other.realm) && account;
  }
  clone() {
    const id = new AccountId(this);
    id._checksum = this._checksum;
    return id;
  }
  compare(other) {
    let comparison = this.shard.compare(other.shard);
    if (comparison != 0) {
      return comparison;
    }
    comparison = this.realm.compare(other.realm);
    if (comparison != 0) {
      return comparison;
    }
    if (this.aliasKey != null && other.aliasKey != null) {
      const t = this.aliasKey.toString();
      const o = other.aliasKey.toString();
      if (t > o) {
        return 1;
      } else if (t < o) {
        return -1;
      } else {
        return 0;
      }
    } else if (this.aliasKey == null && other.aliasKey == null) {
      return this.num.compare(other.num);
    } else {
      return 0;
    }
  }
};
Cache_default.accountIdConstructor = (shard, realm, key) => new AccountId(shard, realm, key);

// node_modules/@hashgraph/sdk/src/long.js
function valueToLong(value) {
  if (bignumber_default.isBigNumber(value)) {
    return value;
  } else {
    return new bignumber_default(value.toString());
  }
}

// node_modules/@hashgraph/sdk/src/HbarUnit.js
var HbarUnit = class {
  constructor(name, symbol, tinybar) {
    this._name = name;
    this._symbol = symbol;
    this._tinybar = tinybar;
    Object.freeze(this);
  }
  static fromString(unit) {
    switch (unit) {
      case HbarUnit.Hbar._symbol:
        return HbarUnit.Hbar;
      case HbarUnit.Tinybar._symbol:
        return HbarUnit.Tinybar;
      case HbarUnit.Microbar._symbol:
        return HbarUnit.Microbar;
      case HbarUnit.Millibar._symbol:
        return HbarUnit.Millibar;
      case HbarUnit.Kilobar._symbol:
        return HbarUnit.Kilobar;
      case HbarUnit.Megabar._symbol:
        return HbarUnit.Megabar;
      case HbarUnit.Gigabar._symbol:
        return HbarUnit.Gigabar;
      default:
        throw new Error("Unknown unit.");
    }
  }
};
HbarUnit.Tinybar = new HbarUnit("tinybar", "t\u210F", new bignumber_default(1));
HbarUnit.Microbar = new HbarUnit("microbar", "\u03BC\u210F", new bignumber_default(100));
HbarUnit.Millibar = new HbarUnit("millibar", "m\u210F", new bignumber_default(1e5));
HbarUnit.Hbar = new HbarUnit("hbar", "\u210F", new bignumber_default("100000000"));
HbarUnit.Kilobar = new HbarUnit("kilobar", "k\u210F", new bignumber_default(1e3).multipliedBy(new bignumber_default("100000000")));
HbarUnit.Megabar = new HbarUnit("megabar", "M\u210F", new bignumber_default(1e6).multipliedBy(new bignumber_default("100000000")));
HbarUnit.Gigabar = new HbarUnit("gigabar", "G\u210F", new bignumber_default("1000000000").multipliedBy(new bignumber_default("100000000")));

// node_modules/@hashgraph/sdk/src/Hbar.js
var import_long5 = __toModule(require_long());
var Hbar = class {
  constructor(amount, unit = HbarUnit.Hbar) {
    if (unit === HbarUnit.Tinybar) {
      this._valueInTinybar = valueToLong(amount);
    } else {
      let bigAmount;
      if (import_long5.default.isLong(amount)) {
        bigAmount = new bignumber_default(amount.toString(10));
      } else if (bignumber_default.isBigNumber(amount) || typeof amount === "string" || typeof amount === "number") {
        bigAmount = new bignumber_default(amount);
      } else {
        bigAmount = new bignumber_default(0);
      }
      this._valueInTinybar = bigAmount.multipliedBy(unit._tinybar);
    }
    if (!this._valueInTinybar.isInteger()) {
      throw new Error("Hbar in tinybars contains decimals");
    }
  }
  static from(amount, unit) {
    return new Hbar(amount, unit);
  }
  static fromTinybars(amount) {
    if (typeof amount === "string") {
      return this.fromString(amount, HbarUnit.Tinybar);
    }
    return new Hbar(amount, HbarUnit.Tinybar);
  }
  static fromString(str, unit = HbarUnit.Hbar) {
    const pattern = /^((?:\+|-)?\d+(?:\.\d+)?)(?: (tℏ|μℏ|mℏ|ℏ|kℏ|Mℏ|Gℏ))?$/;
    if (pattern.test(str)) {
      let [amount, symbol] = str.split(" ");
      if (symbol != null) {
        unit = HbarUnit.fromString(symbol);
      }
      return new Hbar(new bignumber_default(amount), unit);
    } else {
      throw new Error("invalid argument provided");
    }
  }
  to(unit) {
    return this._valueInTinybar.dividedBy(unit._tinybar);
  }
  toBigNumber() {
    return this.to(HbarUnit.Hbar);
  }
  toTinybars() {
    return import_long5.default.fromValue(this._valueInTinybar.toFixed());
  }
  negated() {
    return Hbar.fromTinybars(this._valueInTinybar.negated());
  }
  toString(unit) {
    if (unit != null) {
      return `${this._valueInTinybar.dividedBy(unit._tinybar).toString()} ${unit._symbol}`;
    }
    if (this._valueInTinybar.isLessThan(1e4) && this._valueInTinybar.isGreaterThan(-1e4)) {
      return `${this._valueInTinybar.toFixed()} ${HbarUnit.Tinybar._symbol}`;
    }
    return `${this.to(HbarUnit.Hbar).toString()} ${HbarUnit.Hbar._symbol}`;
  }
};

// node_modules/@hashgraph/sdk/src/grpc/GrpcStatus.js
var GrpcStatus = class {
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  static _fromValue(code) {
    switch (code) {
      case 0:
        return GrpcStatus.Ok;
      case 1:
        return GrpcStatus.Cancelled;
      case 2:
        return GrpcStatus.Unknown;
      case 3:
        return GrpcStatus.InvalidArgument;
      case 4:
        return GrpcStatus.DeadlineExceeded;
      case 5:
        return GrpcStatus.NotFound;
      case 6:
        return GrpcStatus.AlreadyExists;
      case 7:
        return GrpcStatus.PermissionDenied;
      case 16:
        return GrpcStatus.Unauthenticated;
      case 8:
        return GrpcStatus.ResourceExhausted;
      case 9:
        return GrpcStatus.FailedPrecondition;
      case 10:
        return GrpcStatus.Aborted;
      case 11:
        return GrpcStatus.OutOfRange;
      case 12:
        return GrpcStatus.Unimplemented;
      case 13:
        return GrpcStatus.Internal;
      case 14:
        return GrpcStatus.Unavailable;
      case 15:
        return GrpcStatus.DataLoss;
      default:
        throw new Error("(BUG) non-exhaustive GrpcStatus switch statement");
    }
  }
  toString() {
    switch (this) {
      case GrpcStatus.Ok:
        return "OK";
      case GrpcStatus.Cancelled:
        return "CANCELLED";
      case GrpcStatus.Unknown:
        return "UNKNOWN";
      case GrpcStatus.InvalidArgument:
        return "INVALID_ARGUMENT";
      case GrpcStatus.DeadlineExceeded:
        return "DEADLINE_EXCEEDED";
      case GrpcStatus.NotFound:
        return "NOT_FOUND";
      case GrpcStatus.AlreadyExists:
        return "ALREADY_EXISTS";
      case GrpcStatus.PermissionDenied:
        return "PERMISSION_DENIED";
      case GrpcStatus.Unauthenticated:
        return "UNAUTHENTICATED";
      case GrpcStatus.ResourceExhausted:
        return "RESOURCE_EXHAUSTED";
      case GrpcStatus.FailedPrecondition:
        return "FAILED_PRECONDITION";
      case GrpcStatus.Aborted:
        return "ABORTED";
      case GrpcStatus.OutOfRange:
        return "OUT_OF_RANGE";
      case GrpcStatus.Unimplemented:
        return "UNIMPLEMENTED";
      case GrpcStatus.Internal:
        return "INTERNAL";
      case GrpcStatus.Unavailable:
        return "UNAVAILABLE";
      case GrpcStatus.DataLoss:
        return "DATA_LOSS";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  valueOf() {
    return this._code;
  }
};
GrpcStatus.Ok = new GrpcStatus(0);
GrpcStatus.Cancelled = new GrpcStatus(1);
GrpcStatus.Unknown = new GrpcStatus(2);
GrpcStatus.InvalidArgument = new GrpcStatus(3);
GrpcStatus.DeadlineExceeded = new GrpcStatus(4);
GrpcStatus.NotFound = new GrpcStatus(5);
GrpcStatus.AlreadyExists = new GrpcStatus(6);
GrpcStatus.PermissionDenied = new GrpcStatus(7);
GrpcStatus.Unauthenticated = new GrpcStatus(16);
GrpcStatus.ResourceExhausted = new GrpcStatus(8);
GrpcStatus.FailedPrecondition = new GrpcStatus(9);
GrpcStatus.Aborted = new GrpcStatus(10);
GrpcStatus.OutOfRange = new GrpcStatus(11);
GrpcStatus.Unimplemented = new GrpcStatus(12);
GrpcStatus.Internal = new GrpcStatus(13);
GrpcStatus.Unavailable = new GrpcStatus(14);
GrpcStatus.DataLoss = new GrpcStatus(15);

// node_modules/@hashgraph/sdk/src/grpc/GrpcServiceError.js
var GrpcServiceError = class extends Error {
  constructor(status) {
    super(`gRPC service failed with status: ${status.toString()}`);
    this.status = status;
    this.name = "GrpcServiceError";
    if (typeof Error.captureStackTrace !== "undefined") {
      Error.captureStackTrace(this, GrpcServiceError);
    }
  }
  static _fromResponse(obj) {
    if (obj.code != null && obj.details != null) {
      const status = GrpcStatus._fromValue(obj.code);
      const err = new GrpcServiceError(status);
      err.message = obj.details;
      return err;
    } else {
      return obj;
    }
  }
};

// node_modules/@hashgraph/sdk/src/Executable.js
var ExecutionState = {
  Finished: "Finished",
  Retry: "Retry",
  Error: "Error"
};
var RST_STREAM = /\brst[^0-9a-zA-Z]stream\b/i;
var Executable = class {
  constructor() {
    this._maxAttempts = 10;
    this._nextNodeIndex = 0;
    this._nodeIds = [];
    this._minBackoff = null;
    this._maxBackoff = null;
  }
  get nodeAccountIds() {
    return this._nodeIds.length != 0 ? this._nodeIds : null;
  }
  setNodeAccountIds(nodeIds) {
    this._nodeIds = nodeIds;
    return this;
  }
  get maxRetries() {
    console.warn("Deprecated: use maxAttempts instead");
    return this.maxAttempts;
  }
  setMaxRetries(maxRetries) {
    console.warn("Deprecated: use setMaxAttempts() instead");
    return this.setMaxAttempts(maxRetries);
  }
  get maxAttempts() {
    return this._maxAttempts;
  }
  setMaxAttempts(maxAttempts) {
    this._maxAttempts = maxAttempts;
    return this;
  }
  setMinBackoff(minBackoff) {
    if (minBackoff == null) {
      throw new Error("minBackoff cannot be null.");
    } else if (this._maxBackoff != null && minBackoff > this._maxBackoff) {
      throw new Error("minBackoff cannot be larger than maxBackoff.");
    }
    this._minBackoff = minBackoff;
    return this;
  }
  get minBackoff() {
    return this._minBackoff;
  }
  setMaxBackoff(maxBackoff) {
    if (maxBackoff == null) {
      throw new Error("maxBackoff cannot be null.");
    } else if (this._minBackoff != null && maxBackoff < this._minBackoff) {
      throw new Error("maxBackoff cannot be smaller than minBackoff.");
    }
    this._maxBackoff = maxBackoff;
    return this;
  }
  get maxBackoff() {
    return this._maxBackoff;
  }
  _beforeExecute(client) {
    throw new Error("not implemented");
  }
  _makeRequestAsync() {
    throw new Error("not implemented");
  }
  _mapStatusError(request, response) {
    throw new Error("not implemented");
  }
  _mapResponse(response, nodeAccountId, request) {
    throw new Error("not implemented");
  }
  _execute(channel, request) {
    throw new Error("not implemented");
  }
  _getNodeAccountId() {
    throw new Error("not implemented");
  }
  _getTransactionId() {
    throw new Error("not implemented");
  }
  _advanceRequest() {
    this._nextNodeIndex = (this._nextNodeIndex + 1) % this._nodeIds.length;
  }
  _shouldRetry(request, response) {
    throw new Error("not implemented");
  }
  _shouldRetryExceptionally(error) {
    return error.status._code === GrpcStatus.Unavailable._code || error.status._code === GrpcStatus.ResourceExhausted._code || error.status._code === GrpcStatus.Internal._code && RST_STREAM.test(error.message);
  }
  async execute(client) {
    await this._beforeExecute(client);
    if (this._maxBackoff == null) {
      this._maxBackoff = client.maxBackoff;
    }
    if (this._minBackoff == null) {
      this._minBackoff = client.minBackoff;
    }
    const maxAttempts = client._maxAttempts != null ? client._maxAttempts : this._maxAttempts;
    for (let attempt = 1; ; attempt += 1) {
      const nodeAccountId = this._getNodeAccountId();
      const node = client._network.getNode(nodeAccountId);
      if (node == null) {
        throw new Error(`NodeAccountId not recognized: ${nodeAccountId.toString()}`);
      }
      const channel = node.getChannel();
      const request = await this._makeRequestAsync();
      this._advanceRequest();
      let response;
      if (!node.isHealthy()) {
        await node.wait();
      }
      try {
        response = await this._execute(channel, request);
      } catch (err) {
        const error = GrpcServiceError._fromResponse(err);
        if (error instanceof GrpcServiceError && this._shouldRetryExceptionally(error) && attempt <= maxAttempts) {
          node.increaseDelay();
          continue;
        }
        throw err;
      }
      node.decreaseDelay();
      switch (this._shouldRetry(request, response)) {
        case ExecutionState.Retry:
          await delayForAttempt(attempt, this._minBackoff, this._maxBackoff);
          continue;
        case ExecutionState.Finished:
          return this._mapResponse(response, nodeAccountId, request);
        case ExecutionState.Error:
          throw this._mapStatusError(request, response);
        default:
          throw new Error("(BUG) non-exhuastive switch statement for `ExecutionState`");
      }
    }
  }
};
function delayForAttempt(attempt, minBackoff, maxBackoff) {
  const ms = Math.min(Math.floor(minBackoff * Math.pow(2, attempt)), maxBackoff);
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// node_modules/@hashgraph/sdk/src/Timestamp.js
var import_long6 = __toModule(require_long());
var MAX_NS = import_long6.default.fromNumber(1e9);
var Timestamp = class {
  constructor(seconds, nanos) {
    this.seconds = seconds instanceof import_long6.default ? seconds : import_long6.default.fromNumber(seconds);
    this.nanos = nanos instanceof import_long6.default ? nanos : import_long6.default.fromNumber(nanos);
    Object.freeze(this);
  }
  static generate() {
    const jitter = Math.floor(Math.random() * 5e3) + 8e3;
    const now = Date.now() - jitter;
    const seconds = Math.floor(now / 1e3);
    const nanos = Math.floor(now % 1e3) * 1e6 + Math.floor(Math.random() * 1e6);
    return new Timestamp(seconds, nanos);
  }
  static fromDate(date) {
    let ms;
    if (typeof date === "number") {
      ms = date;
    } else if (typeof date === "string") {
      ms = Date.parse(date);
    } else if (date instanceof Date) {
      ms = date.getTime();
    } else {
      throw new TypeError(`invalid type '${typeof date}' for 'data', expected 'Date'`);
    }
    const seconds = Math.floor(ms / 1e3);
    const nanos = Math.floor(ms % 1e3) * 1e6;
    return new Timestamp(seconds, nanos);
  }
  toDate() {
    return new Date(this.seconds.toInt() * 1e3 + Math.floor(this.nanos.toInt() / 1e6));
  }
  plusNanos(nanos) {
    const ns = this.nanos.add(nanos);
    return new Timestamp(this.seconds.add(ns.div(MAX_NS)), ns.mod(MAX_NS));
  }
  _toProtobuf() {
    return {
      seconds: this.seconds,
      nanos: this.nanos.toInt()
    };
  }
  static _fromProtobuf(timestamp) {
    return new Timestamp(timestamp.seconds instanceof import_long6.default ? timestamp.seconds.toInt() : timestamp.seconds != null ? timestamp.seconds : 0, timestamp.nanos != null ? timestamp.nanos : 0);
  }
  toString() {
    return `${this.seconds.toString()}.${this.nanos.toString()}`;
  }
  compare(other) {
    const comparison = this.seconds.compare(other.seconds);
    if (comparison != 0) {
      return comparison;
    }
    return this.nanos.compare(other.nanos);
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionId.js
var proto2 = __toModule(require_lib());
var import_long7 = __toModule(require_long());
var TransactionId = class {
  constructor(accountId, validStart, scheduled = false, nonce = null) {
    this.accountId = accountId;
    this.validStart = validStart;
    this.scheduled = scheduled;
    this.nonce = null;
    if (nonce != null) {
      this.setNonce(nonce);
    }
    Object.freeze(this);
  }
  setNonce(nonce) {
    this.nonce = typeof nonce === "number" ? import_long7.default.fromNumber(nonce) : nonce;
    return this;
  }
  static withValidStart(accountId, validStart) {
    return new TransactionId(accountId, validStart, null);
  }
  static generate(id) {
    return new TransactionId(typeof id === "string" ? AccountId.fromString(id) : new AccountId(id), Timestamp.generate());
  }
  static fromString(wholeId) {
    let account, seconds, nanos, isScheduled, nonce;
    let rest;
    [account, rest] = wholeId.split("@");
    [seconds, rest] = rest.split(".");
    if (rest.includes("?")) {
      [nanos, rest] = rest.split("?scheduled");
      isScheduled = true;
      if (rest.includes("/")) {
        nonce = rest.replace("/", "");
      } else {
        nonce = null;
      }
    } else if (rest.includes("/")) {
      [nanos, nonce] = rest.split("/");
      isScheduled = false;
    } else {
      nanos = rest;
    }
    return new TransactionId(AccountId.fromString(account), new Timestamp(import_long7.default.fromValue(seconds), import_long7.default.fromValue(nanos)), isScheduled, nonce != null ? import_long7.default.fromString(nonce) : null);
  }
  setScheduled(scheduled) {
    this.scheduled = scheduled;
    return this;
  }
  toString() {
    if (this.accountId != null && this.validStart != null) {
      const nonce = this.nonce != null ? "/".concat(this.nonce.toString()) : "";
      const scheduled = this.scheduled ? "?scheduled" : "";
      return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${this.validStart.nanos.toString()}${scheduled}${nonce}`;
    } else {
      throw new Error("neither `accountId` nor `validStart` are set");
    }
  }
  static _fromProtobuf(id) {
    if (id.accountID != null && id.transactionValidStart != null) {
      return new TransactionId(AccountId._fromProtobuf(id.accountID), Timestamp._fromProtobuf(id.transactionValidStart), id.scheduled, id.nonce);
    } else {
      throw new Error("Neither `nonce` or `accountID` and `transactionValidStart` are set");
    }
  }
  _toProtobuf() {
    return {
      accountID: this.accountId != null ? this.accountId._toProtobuf() : null,
      transactionValidStart: this.validStart != null ? this.validStart._toProtobuf() : null,
      scheduled: this.scheduled,
      nonce: this.nonce != null ? this.nonce.toInt() : null
    };
  }
  static fromBytes(bytes2) {
    return TransactionId._fromProtobuf(proto2.TransactionID.decode(bytes2));
  }
  toBytes() {
    return proto2.TransactionID.encode(this._toProtobuf()).finish();
  }
  clone() {
    return new TransactionId(this.accountId, this.validStart, this.scheduled, this.nonce);
  }
  compare(other) {
    const comparison = this.accountId.compare(other.accountId);
    if (comparison != 0) {
      return comparison;
    }
    return this.validStart.compare(other.validStart);
  }
};

// node_modules/@hashgraph/sdk/src/query/Query.js
var import_proto = __toModule(require_lib());

// node_modules/@hashgraph/sdk/src/StatusError.js
var StatusError = class extends Error {
  constructor(props, message) {
    super(message);
    this.name = "StatusError";
    this.status = props.status;
    this.transactionId = props.transactionId;
    this.message = message;
    if (typeof Error.captureStackTrace !== "undefined") {
      Error.captureStackTrace(this, StatusError);
    }
  }
};

// node_modules/@hashgraph/sdk/src/PrecheckStatusError.js
var PrecheckStatusError = class extends StatusError {
  constructor(props) {
    super(props, `transaction ${props.transactionId.toString()} failed precheck with status ${props.status.toString()}`);
  }
};

// node_modules/@hashgraph/sdk/src/MaxQueryPaymentExceeded.js
var MaxQueryPaymentExceeded = class extends Error {
  constructor(queryCost, maxQueryPayment) {
    super();
    this.message = `query cost of ${queryCost.toString()} HBAR exceeds max set on client: ${maxQueryPayment.toString()} HBAR`;
    this.name = "MaxQueryPaymentExceededError";
    this.queryCost = queryCost;
    this.maxQueryPayment = maxQueryPayment;
  }
};

// node_modules/@hashgraph/sdk/src/query/Query.js
var import_long8 = __toModule(require_long());
var QUERY_REGISTRY = new Map();
var Query = class extends Executable {
  constructor() {
    super();
    this._paymentTransactionId = null;
    this._paymentTransactions = [];
    this._queryPayment = null;
    this._maxQueryPayment = null;
  }
  static fromBytes(bytes2) {
    const query = import_proto.Query.decode(bytes2);
    if (query.query == null) {
      throw new Error("(BUG) query.query was not set in the protobuf");
    }
    const fromProtobuf = QUERY_REGISTRY.get(query.query);
    if (fromProtobuf == null) {
      throw new Error(`(BUG) Query.fromBytes() not implemented for type ${query.query}`);
    }
    return fromProtobuf(query);
  }
  toBytes() {
    return import_proto.Query.encode(this._makeRequest()).finish();
  }
  setQueryPayment(queryPayment) {
    this._queryPayment = queryPayment;
    return this;
  }
  setMaxQueryPayment(maxQueryPayment) {
    this._maxQueryPayment = maxQueryPayment;
    return this;
  }
  getCost(client) {
    if (this._nodeIds.length == 0) {
      this._nodeIds = client._network.getNodeAccountIdsForExecute();
    }
    if (COST_QUERY.length != 1) {
      throw new Error("CostQuery has not been loaded yet");
    }
    return COST_QUERY[0](this).execute(client);
  }
  setPaymentTransactionId(paymentTransactionId) {
    this._paymentTransactionId = paymentTransactionId;
    return this;
  }
  get paymentTransactionId() {
    return this._paymentTransactionId;
  }
  _getTransactionId() {
    if (this._paymentTransactionId == null) {
      throw new Error("Query.PaymentTransactionId was not set duration execution");
    }
    return this._paymentTransactionId;
  }
  _isPaymentRequired() {
    return true;
  }
  _validateChecksums(client) {
  }
  async _beforeExecute(client) {
    if (this._paymentTransactions.length > 0) {
      return;
    }
    if (client.isAutoValidateChecksumsEnabled()) {
      this._validateChecksums(client);
    }
    if (this._nodeIds.length == 0) {
      this._nodeIds = client._network.getNodeAccountIdsForExecute();
    }
    const operator = client._operator;
    if (this._paymentTransactionId == null) {
      if (this._isPaymentRequired()) {
        if (operator != null) {
          this._paymentTransactionId = TransactionId.generate(operator.accountId);
        } else {
          throw new Error("`client` must have an `operator` or an explicit payment transaction must be provided");
        }
      } else {
        this._paymentTransactionId = TransactionId.generate(new AccountId(0));
      }
    }
    let cost = this._queryPayment != null ? this._queryPayment : client.maxQueryPayment;
    if (this._paymentTransactions.length !== 0 || !this._isPaymentRequired()) {
      cost = new Hbar(0);
    } else {
      if (this._queryPayment == null) {
        const actualCost = await this.getCost(client);
        if (cost.toTinybars().toInt() < actualCost.toTinybars().toInt()) {
          throw new MaxQueryPaymentExceeded(cost, actualCost);
        }
        cost = actualCost;
      }
    }
    for (const node of this._nodeIds) {
      this._paymentTransactions.push(await _makePaymentTransaction(this._paymentTransactionId, node, this._isPaymentRequired() ? operator : null, cost));
    }
  }
  _mapResponseHeader(response) {
    throw new Error("not implemented");
  }
  _makeRequestHeader() {
    let header = {};
    if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {
      header = {
        responseType: import_proto.ResponseType.ANSWER_ONLY,
        payment: this._paymentTransactions[this._nextNodeIndex]
      };
    }
    return header;
  }
  _onMakeRequest(header) {
    throw new Error("not implemented");
  }
  _makeRequest() {
    let header = {};
    if (this._isPaymentRequired() && this._paymentTransactions != null) {
      header = {
        payment: this._paymentTransactions[this._nextNodeIndex],
        responseType: import_proto.ResponseType.ANSWER_ONLY
      };
    }
    return this._onMakeRequest(header);
  }
  _makeRequestAsync() {
    return Promise.resolve(this._makeRequest());
  }
  _shouldRetry(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : import_proto.ResponseCodeEnum.OK);
    switch (status) {
      case Status.Busy:
      case Status.Unknown:
      case Status.PlatformTransactionNotCreated:
        return ExecutionState.Retry;
      case Status.Ok:
        return ExecutionState.Finished;
      default:
        return ExecutionState.Error;
    }
  }
  _mapStatusError(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : import_proto.ResponseCodeEnum.OK);
    return new PrecheckStatusError({
      status,
      transactionId: this._getTransactionId()
    });
  }
  _getNodeAccountId() {
    if (this._nodeIds.length > 0) {
      return this._nodeIds[this._nextNodeIndex];
    } else {
      throw new Error("(BUG) nodeAccountIds were not set for query before executing");
    }
  }
  _advanceRequest() {
    if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {
      super._nextNodeIndex = (this._nextNodeIndex + 1) % this._paymentTransactions.length;
    } else {
      super._advanceRequest();
    }
  }
};
async function _makePaymentTransaction(paymentTransactionId, nodeId, operator, paymentAmount) {
  const accountAmounts = [];
  if (operator != null) {
    accountAmounts.push({
      accountID: operator.accountId._toProtobuf(),
      amount: paymentAmount.negated().toTinybars()
    });
    accountAmounts.push({
      accountID: nodeId._toProtobuf(),
      amount: paymentAmount.toTinybars()
    });
  } else {
    accountAmounts.push({
      accountID: new AccountId(0)._toProtobuf(),
      amount: paymentAmount.negated().toTinybars()
    });
    accountAmounts.push({
      accountID: nodeId._toProtobuf(),
      amount: paymentAmount.toTinybars()
    });
  }
  const body = {
    transactionID: paymentTransactionId._toProtobuf(),
    nodeAccountID: nodeId._toProtobuf(),
    transactionFee: new Hbar(1).toTinybars(),
    transactionValidDuration: {
      seconds: import_long8.default.fromNumber(120)
    },
    cryptoTransfer: {
      transfers: {
        accountAmounts
      }
    }
  };
  const signedTransaction = {
    bodyBytes: import_proto.TransactionBody.encode(body).finish()
  };
  if (operator != null) {
    const signature = await operator.transactionSigner(signedTransaction.bodyBytes);
    signedTransaction.sigMap = {
      sigPair: [operator.publicKey._toProtobufSignature(signature)]
    };
  }
  return {
    signedTransactionBytes: import_proto.SignedTransaction.encode(signedTransaction).finish()
  };
}
var COST_QUERY = [];

// node_modules/@hashgraph/sdk/src/contract/ContractId.js
var proto3 = __toModule(require_lib());
var ContractId = class extends Key {
  constructor(props, realm, num) {
    super();
    const result = constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this._checksum = null;
  }
  static fromString(text) {
    const result = fromString(text);
    const id = new ContractId(result);
    id._checksum = result.checksum;
    return id;
  }
  static _fromProtobuf(id) {
    const contractId = new ContractId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.contractNum != null ? id.contractNum : 0);
    return contractId;
  }
  get checksum() {
    return this._checksum;
  }
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  validateChecksum(client) {
    validateChecksum(this.shard, this.realm, this.num, this._checksum, client);
  }
  static fromBytes(bytes2) {
    return ContractId._fromProtobuf(proto3.ContractID.decode(bytes2));
  }
  static fromSolidityAddress(address) {
    const [shard, realm, contract] = fromSolidityAddress(address);
    return new ContractId(shard, realm, contract);
  }
  toSolidityAddress() {
    return toSolidityAddress([this.shard, this.realm, this.num]);
  }
  _toProtobuf() {
    return {
      contractNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  toStringWithChecksum(client) {
    return toStringWithChecksum(this.toString(), client);
  }
  toBytes() {
    return proto3.ContractID.encode(this._toProtobuf()).finish();
  }
  clone() {
    const id = new ContractId(this);
    id._checksum = this._checksum;
    return id;
  }
  compare(other) {
    return compare2([this.shard, this.realm, this.num], [other.shard, other.realm, other.num]);
  }
  _toProtobufKey() {
    return {
      contractID: this._toProtobuf()
    };
  }
  static __fromProtobufKey(key) {
    return ContractId._fromProtobuf(key);
  }
};
Cache_default.contractId = (key) => ContractId.__fromProtobufKey(key);

// node_modules/@hashgraph/sdk/src/account/AccountBalance.js
var import_long9 = __toModule(require_long());

// node_modules/@hashgraph/sdk/src/token/TokenId.js
var proto4 = __toModule(require_lib());
var TokenId = class {
  constructor(props, realm, num) {
    const result = constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this._checksum = null;
  }
  static fromString(text) {
    const result = fromString(text);
    const id = new TokenId(result);
    id._checksum = result.checksum;
    return id;
  }
  static _fromProtobuf(id) {
    const tokenId = new TokenId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.tokenNum != null ? id.tokenNum : 0);
    return tokenId;
  }
  get checksum() {
    return this._checksum;
  }
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  validateChecksum(client) {
    validateChecksum(this.shard, this.realm, this.num, this._checksum, client);
  }
  static fromBytes(bytes2) {
    return TokenId._fromProtobuf(proto4.TokenID.decode(bytes2));
  }
  static fromSolidityAddress(address) {
    return new TokenId(...fromSolidityAddress(address));
  }
  toSolidityAddress() {
    return toSolidityAddress([this.shard, this.realm, this.num]);
  }
  _toProtobuf() {
    return {
      tokenNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  toStringWithChecksum(client) {
    return toStringWithChecksum(this.toString(), client);
  }
  toBytes() {
    return proto4.TokenID.encode(this._toProtobuf()).finish();
  }
  clone() {
    const id = new TokenId(this);
    id._checksum = this._checksum;
    return id;
  }
  compare(other) {
    return compare2([this.shard, this.realm, this.num], [other.shard, other.realm, other.num]);
  }
};

// node_modules/@hashgraph/sdk/src/ObjectMap.js
var ObjectMap = class {
  constructor(fromString2) {
    this._map = new Map();
    this.__map = new Map();
    this._fromString = fromString2;
  }
  get(key) {
    const k = typeof key === "string" ? key : key.toString();
    const value = this._map.get(k);
    return value != null ? value : null;
  }
  _set(key, value) {
    const k = typeof key === "string" ? key : key.toString();
    this._map.set(k, value);
    this.__map.set(key, value);
  }
  values() {
    return this._map.values();
  }
  get size() {
    return this._map.size;
  }
  keys() {
    return this.__map.keys();
  }
  [Symbol.iterator]() {
    return this.__map[Symbol.iterator]();
  }
  toString() {
    const map = {};
    for (const [key, value] of this._map) {
      map[key] = value.toString();
    }
    return JSON.stringify(map);
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenBalanceMap.js
var TokenBalanceMap = class extends ObjectMap {
  constructor() {
    super((s) => TokenId.fromString(s));
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenDecimalMap.js
var TokenDecimalMap = class extends ObjectMap {
  constructor() {
    super((s) => TokenId.fromString(s));
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountBalance.js
var AccountBalance = class {
  constructor(props) {
    this.hbars = props.hbars;
    this.tokens = props.tokens;
    this.tokenDecimals = props.tokenDecimals;
    Object.freeze(this);
  }
  static _fromProtobuf(accountBalance) {
    const tokenBalances = new TokenBalanceMap();
    const tokenDecimals = new TokenDecimalMap();
    if (accountBalance.tokenBalances != null) {
      for (const balance of accountBalance.tokenBalances) {
        const tokenId = TokenId._fromProtobuf(balance.tokenId);
        tokenDecimals._set(tokenId, balance.decimals != null ? balance.decimals : 0);
        tokenBalances._set(tokenId, import_long9.default.fromValue(balance.balance));
      }
    }
    return new AccountBalance({
      hbars: Hbar.fromTinybars(accountBalance.balance),
      tokens: tokenBalances,
      tokenDecimals
    });
  }
  _toProtobuf() {
    const list = [];
    for (const [key, value] of this.tokens != null ? this.tokens : []) {
      list.push({
        tokenId: key._toProtobuf(),
        balance: value,
        decimals: this.tokenDecimals != null ? this.tokenDecimals.get(key) : null
      });
    }
    return {
      balance: this.hbars.toTinybars(),
      tokenBalances: list
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    const tokens = [];
    for (const [key, value] of this.tokens != null ? this.tokens : []) {
      const decimals = this.tokenDecimals != null ? this.tokenDecimals.get(key) : null;
      tokens.push({
        tokenId: key.toString(),
        balance: value.toString(),
        decimals: decimals != null ? decimals : 0
      });
    }
    return {
      hbars: this.hbars.toString(),
      tokens
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountBalanceQuery.js
var AccountBalanceQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._accountId = null;
    this._contractId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  static _fromProtobuf(query) {
    const balance = query.cryptogetAccountBalance;
    return new AccountBalanceQuery({
      accountId: balance.accountID != null ? AccountId._fromProtobuf(balance.accountID) : void 0,
      contractId: balance.contractID != null ? ContractId._fromProtobuf(balance.contractID) : void 0
    });
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  _isPaymentRequired() {
    return false;
  }
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.cryptoGetBalance(request);
  }
  _mapResponseHeader(response) {
    const cryptogetAccountBalance = response.cryptogetAccountBalance;
    return cryptogetAccountBalance.header;
  }
  _mapResponse(response, nodeAccountId, request) {
    const cryptogetAccountBalance = response.cryptogetAccountBalance;
    return Promise.resolve(AccountBalance._fromProtobuf(cryptogetAccountBalance));
  }
  _onMakeRequest(header) {
    return {
      cryptogetAccountBalance: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("cryptogetAccountBalance", AccountBalanceQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/ReceiptStatusError.js
var ReceiptStatusError = class extends StatusError {
  constructor(props) {
    super(props, `receipt for transaction ${props.transactionId.toString()} contained error status ${props.status.toString()}`);
    this.transactionReceipt = props.transactionReceipt;
  }
};

// node_modules/@hashgraph/sdk/src/file/FileId.js
var proto5 = __toModule(require_lib());
var FileId = class {
  constructor(props, realm, num) {
    const result = constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this._checksum = null;
  }
  static fromString(text) {
    const result = fromString(text);
    const id = new FileId(result);
    id._checksum = result.checksum;
    return id;
  }
  static _fromProtobuf(id) {
    const fileId = new FileId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.fileNum != null ? id.fileNum : 0);
    return fileId;
  }
  get checksum() {
    return this._checksum;
  }
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  validateChecksum(client) {
    validateChecksum(this.shard, this.realm, this.num, this._checksum, client);
  }
  static fromBytes(bytes2) {
    return FileId._fromProtobuf(proto5.FileID.decode(bytes2));
  }
  _toProtobuf() {
    return {
      fileNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  toStringWithChecksum(client) {
    return toStringWithChecksum(this.toString(), client);
  }
  toBytes() {
    return proto5.FileID.encode(this._toProtobuf()).finish();
  }
  clone() {
    const id = new FileId(this);
    id._checksum = this._checksum;
    return id;
  }
  compare(other) {
    return compare2([this.shard, this.realm, this.num], [other.shard, other.realm, other.num]);
  }
};

// node_modules/@hashgraph/sdk/src/topic/TopicId.js
var import_proto2 = __toModule(require_lib());
var TopicId = class {
  constructor(props, realm, num) {
    const result = constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this._checksum = null;
  }
  static fromString(text) {
    const result = fromString(text);
    const id = new TopicId(result);
    id._checksum = result.checksum;
    return id;
  }
  static _fromProtobuf(id) {
    const topicId = new TopicId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.topicNum != null ? id.topicNum : 0);
    return topicId;
  }
  get checksum() {
    return this._checksum;
  }
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  validateChecksum(client) {
    validateChecksum(this.shard, this.realm, this.num, this._checksum, client);
  }
  static fromBytes(bytes2) {
    return TopicId._fromProtobuf(import_proto2.TopicID.decode(bytes2));
  }
  _toProtobuf() {
    return {
      topicNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  toStringWithChecksum(client) {
    return toStringWithChecksum(this.toString(), client);
  }
  toBytes() {
    return import_proto2.TopicID.encode(this._toProtobuf()).finish();
  }
  clone() {
    const id = new TopicId(this);
    id._checksum = this._checksum;
    return id;
  }
  compare(other) {
    return compare2([this.shard, this.realm, this.num], [other.shard, other.realm, other.num]);
  }
};

// node_modules/@hashgraph/sdk/src/schedule/ScheduleId.js
var proto6 = __toModule(require_lib());
var ScheduleId = class {
  constructor(props, realm, num) {
    const result = constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    this._checksum = null;
  }
  static fromString(text) {
    const result = fromString(text);
    const id = new ScheduleId(result);
    id._checksum = result.checksum;
    return id;
  }
  static _fromProtobuf(id) {
    const scheduleId = new ScheduleId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.scheduleNum != null ? id.scheduleNum : 0);
    return scheduleId;
  }
  get checksum() {
    return this._checksum;
  }
  validate(client) {
    console.warn("Deprecated: Use `validateChecksum` instead");
    this.validateChecksum(client);
  }
  validateChecksum(client) {
    validateChecksum(this.shard, this.realm, this.num, this._checksum, client);
  }
  static fromBytes(bytes2) {
    return ScheduleId._fromProtobuf(proto6.ScheduleID.decode(bytes2));
  }
  static fromSolidityAddress(address) {
    return new ScheduleId(...fromSolidityAddress(address));
  }
  toSolidityAddress() {
    return toSolidityAddress([this.shard, this.realm, this.num]);
  }
  _toProtobuf() {
    return {
      scheduleNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  toStringWithChecksum(client) {
    return toStringWithChecksum(this.toString(), client);
  }
  toBytes() {
    return proto6.ScheduleID.encode(this._toProtobuf()).finish();
  }
  clone() {
    const id = new ScheduleId(this);
    id._checksum = this._checksum;
    return id;
  }
  compare(other) {
    return compare2([this.shard, this.realm, this.num], [other.shard, other.realm, other.num]);
  }
};

// node_modules/@hashgraph/sdk/src/ExchangeRate.js
var import_long10 = __toModule(require_long());
var ExchangeRate = class {
  constructor(props) {
    this.hbars = props.hbars;
    this.cents = props.cents;
    this.expirationTime = props.expirationTime;
    Object.freeze(this);
  }
  static _fromProtobuf(rate) {
    return new ExchangeRate({
      hbars: rate.hbarEquiv,
      cents: rate.centEquiv,
      expirationTime: new Date(rate.expirationTime != null ? rate.expirationTime.seconds != null ? rate.expirationTime.seconds instanceof import_long10.default ? rate.expirationTime.seconds.toInt() : rate.expirationTime.seconds : 0 * 1e3 : 0 * 1e3)
    });
  }
  _toProtobuf() {
    return {
      hbarEquiv: this.hbars,
      centEquiv: this.cents,
      expirationTime: {
        seconds: import_long10.default.fromNumber(this.expirationTime.getSeconds())
      }
    };
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionReceipt.js
var import_long11 = __toModule(require_long());
var proto7 = __toModule(require_lib());
var TransactionReceipt = class {
  constructor(props) {
    this.status = props.status;
    this.accountId = props.accountId;
    this.fileId = props.fileId;
    this.contractId = props.contractId;
    this.topicId = props.topicId;
    this.tokenId = props.tokenId;
    this.scheduleId = props.scheduleId;
    this.exchangeRate = props.exchangeRate;
    this.topicSequenceNumber = props.topicSequenceNumber;
    this.topicRunningHash = props.topicRunningHash;
    this.totalSupply = props.totalSupply;
    this.scheduledTransactionId = props.scheduledTransactionId;
    this.serials = props.serials;
    this.duplicates = props.duplicates;
    this.children = props.children;
    Object.freeze(this);
  }
  _toProtobuf() {
    const duplicates = this.duplicates.map((receipt) => receipt._toProtobuf().receipt);
    const children = this.children.map((receipt) => receipt._toProtobuf().receipt);
    return {
      duplicateTransactionReceipts: duplicates,
      childTransactionReceipts: children,
      receipt: {
        status: this.status.valueOf(),
        accountID: this.accountId != null ? this.accountId._toProtobuf() : null,
        fileID: this.fileId != null ? this.fileId._toProtobuf() : null,
        contractID: this.contractId != null ? this.contractId._toProtobuf() : null,
        topicID: this.topicId != null ? this.topicId._toProtobuf() : null,
        tokenID: this.topicId != null ? this.topicId._toProtobuf() : null,
        scheduleID: this.topicId != null ? this.topicId._toProtobuf() : null,
        topicRunningHash: this.topicRunningHash == null ? null : this.topicRunningHash,
        topicSequenceNumber: this.topicSequenceNumber,
        exchangeRate: {
          nextRate: null,
          currentRate: this.exchangeRate != null ? this.exchangeRate._toProtobuf() : null
        },
        scheduledTransactionID: this.scheduledTransactionId != null ? this.scheduledTransactionId._toProtobuf() : null,
        serialNumbers: this.serials
      }
    };
  }
  static _fromProtobuf(response) {
    const receipt = response.receipt;
    const exchangeRateSet = receipt.exchangeRate;
    const children = response.childTransactionReceipts != null ? response.childTransactionReceipts.map((child) => TransactionReceipt._fromProtobuf({ receipt: child })) : [];
    const duplicates = response.duplicateTransactionReceipts != null ? response.duplicateTransactionReceipts.map((duplicate) => TransactionReceipt._fromProtobuf({ receipt: duplicate })) : [];
    return new TransactionReceipt({
      status: Status._fromCode(receipt.status != null ? receipt.status : 0),
      accountId: receipt.accountID != null ? AccountId._fromProtobuf(receipt.accountID) : null,
      fileId: receipt.fileID != null ? FileId._fromProtobuf(receipt.fileID) : null,
      contractId: receipt.contractID != null ? ContractId._fromProtobuf(receipt.contractID) : null,
      topicId: receipt.topicID != null ? TopicId._fromProtobuf(receipt.topicID) : null,
      tokenId: receipt.tokenID != null ? TokenId._fromProtobuf(receipt.tokenID) : null,
      scheduleId: receipt.scheduleID != null ? ScheduleId._fromProtobuf(receipt.scheduleID) : null,
      exchangeRate: receipt.exchangeRate != null ? ExchangeRate._fromProtobuf(exchangeRateSet.currentRate) : null,
      topicSequenceNumber: receipt.topicSequenceNumber == null ? null : import_long11.default.fromValue(receipt.topicSequenceNumber),
      topicRunningHash: receipt.topicRunningHash != null ? receipt.topicRunningHash : null,
      totalSupply: receipt.newTotalSupply != null ? receipt.newTotalSupply : null,
      scheduledTransactionId: receipt.scheduledTransactionID != null ? TransactionId._fromProtobuf(receipt.scheduledTransactionID) : null,
      serials: receipt.serialNumbers != null ? receipt.serialNumbers : [],
      children,
      duplicates
    });
  }
  static fromBytes(bytes2) {
    return TransactionReceipt._fromProtobuf(proto7.TransactionGetReceiptResponse.decode(bytes2));
  }
  toBytes() {
    return proto7.TransactionGetReceiptResponse.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionReceiptQuery.js
var import_proto3 = __toModule(require_lib());
var TransactionReceiptQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._transactionId = null;
    this._includeChildren = null;
    this._includeDuplicates = null;
    if (props.transactionId != null) {
      this.setTransactionId(props.transactionId);
    }
    if (props.includeChildren != null) {
      this.setIncludeChildren(props.includeChildren);
    }
    if (props.includeDuplicates != null) {
      this.setIncludeDuplicates(props.includeDuplicates);
    }
  }
  static _fromProtobuf(query) {
    const receipt = query.transactionGetReceipt;
    return new TransactionReceiptQuery({
      transactionId: receipt.transactionID ? TransactionId._fromProtobuf(receipt.transactionID) : void 0,
      includeDuplicates: receipt.includeDuplicates != null ? receipt.includeDuplicates : void 0,
      includeChildren: receipt.includeChildReceipts != null ? receipt.includeChildReceipts : void 0
    });
  }
  get transactionId() {
    return this._transactionId;
  }
  setTransactionId(transactionId) {
    this._transactionId = typeof transactionId === "string" ? TransactionId.fromString(transactionId) : transactionId.clone();
    return this;
  }
  setIncludeDuplicates(includeDuplicates) {
    this._includeDuplicates = includeDuplicates;
    return this;
  }
  get includeDuplicates() {
    return this._includeDuplicates != null ? this._includeDuplicates : false;
  }
  setIncludeChildren(includeChildren) {
    this._includeChildren = includeChildren;
    return this;
  }
  get includeChildren() {
    return this._includeChildren != null ? this._includeChildren : false;
  }
  _isPaymentRequired() {
    return false;
  }
  _shouldRetry(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    let status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : import_proto3.ResponseCodeEnum.OK);
    switch (status) {
      case Status.Busy:
      case Status.Unknown:
      case Status.ReceiptNotFound:
        return ExecutionState.Retry;
      case Status.Ok:
        break;
      default:
        return ExecutionState.Error;
    }
    const transactionGetReceipt = response.transactionGetReceipt;
    const receipt = transactionGetReceipt.receipt;
    const receiptStatusCode = receipt.status;
    status = Status._fromCode(receiptStatusCode);
    switch (status) {
      case Status.Busy:
      case Status.Unknown:
      case Status.ReceiptNotFound:
        return ExecutionState.Retry;
      case Status.Success:
        return ExecutionState.Finished;
      default:
        return ExecutionState.Error;
    }
  }
  _mapStatusError(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    let status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : import_proto3.ResponseCodeEnum.OK);
    switch (status) {
      case Status.Ok:
        break;
      default:
        return new PrecheckStatusError({
          status,
          transactionId: this._getTransactionId()
        });
    }
    const transactionGetReceipt = response.transactionGetReceipt;
    const receipt = transactionGetReceipt.receipt;
    const receiptStatusCode = receipt.status;
    status = Status._fromCode(receiptStatusCode);
    return new ReceiptStatusError({
      status,
      transactionId: this._getTransactionId(),
      transactionReceipt: TransactionReceipt._fromProtobuf(transactionGetReceipt)
    });
  }
  _validateChecksums(client) {
    if (this._transactionId != null && this._transactionId.accountId != null) {
      this._transactionId.accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.getTransactionReceipts(request);
  }
  _mapResponseHeader(response) {
    const transactionGetReceipt = response.transactionGetReceipt;
    return transactionGetReceipt.header;
  }
  _mapResponse(response, nodeAccountId, request) {
    const transactionGetReceipt = response.transactionGetReceipt;
    return Promise.resolve(TransactionReceipt._fromProtobuf(transactionGetReceipt));
  }
  _onMakeRequest(header) {
    return {
      transactionGetReceipt: {
        header,
        transactionID: this._transactionId != null ? this._transactionId._toProtobuf() : null,
        includeDuplicates: this._includeDuplicates,
        includeChildReceipts: this._includeChildren
      }
    };
  }
};
QUERY_REGISTRY.set("transactionGetReceipt", TransactionReceiptQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/Transfer.js
var Transfer = class {
  constructor(props) {
    this.accountId = props.accountId instanceof AccountId ? props.accountId : AccountId.fromString(props.accountId);
    this.amount = props.amount instanceof Hbar ? props.amount : new Hbar(props.amount);
    Object.freeze(this);
  }
  static _fromProtobuf(transfer) {
    return new Transfer({
      accountId: AccountId._fromProtobuf(transfer.accountID),
      amount: Hbar.fromTinybars(transfer.amount != null ? transfer.amount : 0)
    });
  }
  _toProtobuf() {
    return {
      accountID: this.accountId._toProtobuf(),
      amount: this.amount.toTinybars()
    };
  }
};

// node_modules/@hashgraph/sdk/src/contract/ContractLogInfo.js
var ContractLogInfo = class {
  constructor(props) {
    this.contractId = props.contractId;
    this.bloom = props.bloom;
    this.topics = props.topics;
    this.data = props.data;
    Object.freeze(this);
  }
  static _fromProtobuf(info) {
    return new ContractLogInfo({
      contractId: ContractId._fromProtobuf(info.contractID),
      bloom: info.bloom != null ? info.bloom : new Uint8Array(),
      topics: info.topic != null ? info.topic : [],
      data: info.data != null ? info.data : new Uint8Array()
    });
  }
  _toProtobuf() {
    return {
      contractID: this.contractId._toProtobuf(),
      bloom: this.bloom,
      topic: this.topics,
      data: this.data
    };
  }
};

// node_modules/@hashgraph/sdk/src/encoding/utf8.browser.js
function decode6(data) {
  return new TextDecoder().decode(data);
}
function encode4(text) {
  return new TextEncoder().encode(text);
}

// node_modules/@hashgraph/sdk/src/contract/ContractFunctionResult.js
var import_long12 = __toModule(require_long());
var ContractFunctionResult = class {
  constructor(result) {
    this.contractId = result.contractId;
    this.bytes = result.bytes;
    this.errorMessage = result.errorMessage;
    this.bloom = result.bloom;
    this.gasUsed = result.gasUsed;
    this.logs = result.logs;
    this.createdContractIds = result.createdContractIds;
  }
  static _fromProtobuf(result) {
    const contractId = result.contractID;
    const gas = result.gasUsed;
    return new ContractFunctionResult({
      bytes: result.contractCallResult,
      contractId: contractId != null ? ContractId._fromProtobuf(contractId) : null,
      errorMessage: result.errorMessage != null ? result.errorMessage : null,
      bloom: result.bloom,
      gasUsed: gas instanceof import_long12.default ? gas : import_long12.default.fromValue(gas),
      logs: (result.logInfo != null ? result.logInfo : []).map((info) => ContractLogInfo._fromProtobuf(info)),
      createdContractIds: (result.createdContractIDs != null ? result.createdContractIDs : []).map((contractId2) => ContractId._fromProtobuf(contractId2))
    });
  }
  asBytes() {
    return this.bytes;
  }
  getString(index) {
    return decode6(this.getBytes(index));
  }
  getBytes(index) {
    const offset = this.getInt32(index);
    const len = safeView(this.bytes).getInt32(offset + 28);
    return this.bytes.subarray(offset + 32, offset + 32 + len);
  }
  getBytes32(index) {
    return this.bytes.subarray((index != null ? index : 0) * 32, (index != null ? index : 0) * 32 + 32);
  }
  getBool(index) {
    return this.bytes[(index != null ? index : 0) * 32 + 31] !== 0;
  }
  getInt8(index) {
    return this.bytes[(index != null ? index : 0) * 32 + 31];
  }
  getInt32(index) {
    const position = (index != null ? index : 0) * 32 + 28;
    return safeView(this.bytes).getInt32(position);
  }
  getInt64(index) {
    return new bignumber_default(encode3(this._getBytes32(index != null ? index : 0).subarray(24, 32)), 16);
  }
  getInt256(index) {
    return new bignumber_default(encode3(this._getBytes32(index != null ? index : 0)), 16);
  }
  getUint8(index) {
    return this.bytes[(index != null ? index : 0) * 32 + 31];
  }
  getUint32(index) {
    const position = (index != null ? index : 0) * 32 + 28;
    return safeView(this.bytes).getUint32(position);
  }
  getUint64(index) {
    return new bignumber_default(encode3(this._getBytes32(index).subarray(24, 32)), 16);
  }
  getUint256(index) {
    return new bignumber_default(encode3(this._getBytes32(index)), 16);
  }
  getAddress(index) {
    return encode3(this.bytes.subarray((index != null ? index : 0) * 32 + 12, (index != null ? index : 0) * 32 + 32));
  }
  _getBytes32(index) {
    return this.bytes.subarray((index != null ? index : 0) * 32, (index != null ? index : 0) * 32 + 32);
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenTransferAccountMap.js
var TokenTransferAccountMap = class extends ObjectMap {
  constructor() {
    super((s) => AccountId.fromString(s));
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenTransferMap.js
var TokenTransferMap = class extends ObjectMap {
  constructor() {
    super((s) => TokenId.fromString(s));
  }
  __set(tokenId, accountId, amount) {
    const token = tokenId.toString();
    let _map = this._map.get(token);
    if (_map == null) {
      _map = new TokenTransferAccountMap();
      this._map.set(token, _map);
      this.__map.set(tokenId, _map);
    }
    _map._set(accountId, amount);
  }
  static _fromProtobuf(transfers) {
    const tokenTransfersMap = new TokenTransferMap();
    for (const transfer of transfers) {
      const token = TokenId._fromProtobuf(transfer.token);
      for (const aa of transfer.transfers != null ? transfer.transfers : []) {
        const account = AccountId._fromProtobuf(aa.accountID);
        tokenTransfersMap.__set(token, account, aa.amount);
      }
    }
    return tokenTransfersMap;
  }
  _toProtobuf() {
    const tokenTransferList = [];
    for (const [tokenId, value] of this) {
      const transfers = [];
      for (const [accountId, amount] of value) {
        transfers.push({
          accountID: accountId._toProtobuf(),
          amount
        });
      }
      tokenTransferList.push({
        token: tokenId._toProtobuf(),
        transfers
      });
    }
    return tokenTransferList;
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenNftTransferMap.js
var TokenNftTransferMap = class extends ObjectMap {
  constructor() {
    super((s) => TokenId.fromString(s));
  }
  __set(tokenId, nftTransfer) {
    const token = tokenId.toString();
    let _map = this._map.get(token);
    if (_map == null) {
      _map = [];
      this._map.set(token, _map);
      this.__map.set(tokenId, _map);
    }
    _map.push(nftTransfer);
  }
  static _fromProtobuf(transfers) {
    const tokenTransfersMap = new TokenNftTransferMap();
    for (const transfer of transfers) {
      const token = TokenId._fromProtobuf(transfer.token);
      for (const aa of transfer.nftTransfers != null ? transfer.nftTransfers : []) {
        const sender = AccountId._fromProtobuf(aa.senderAccountID);
        const recipient = AccountId._fromProtobuf(aa.receiverAccountID);
        tokenTransfersMap.__set(token, {
          sender,
          recipient,
          serial: aa.serialNumber
        });
      }
    }
    return tokenTransfersMap;
  }
  _toProtobuf() {
    const tokenTransferList = [];
    for (const [tokenId, value] of this) {
      const transfers = [];
      for (const transfer of value) {
        transfers.push({
          senderAccountID: transfer.sender._toProtobuf(),
          receiverAccountID: transfer.recipient._toProtobuf(),
          serialNumber: transfer.serial
        });
      }
      tokenTransferList.push({
        token: tokenId._toProtobuf(),
        nftTransfers: transfers
      });
    }
    return tokenTransferList;
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionRecord.js
var proto8 = __toModule(require_lib());

// node_modules/@hashgraph/sdk/src/token/AssessedCustomFee.js
var import_long13 = __toModule(require_long());
var AssessedCustomFee = class {
  constructor(props = {}) {
    this._feeCollectorAccountId;
    if (props.feeCollectorAccountId != null) {
      this.setFeeCollectorAccountId(props.feeCollectorAccountId);
    }
    this._tokenId;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    this._amount;
    if (props.amount != null) {
      this.setAmount(props.amount);
    }
    this._payerAccountIds;
    if (props.payerAccountIds != null) {
      this.setPayerAccountIds(props.payerAccountIds);
    }
  }
  get feeCollectorAccountId() {
    return this._feeCollectorAccountId;
  }
  setFeeCollectorAccountId(feeCollectorAccountId) {
    this._feeCollectorAccountId = typeof feeCollectorAccountId === "string" ? AccountId.fromString(feeCollectorAccountId) : feeCollectorAccountId;
    return this;
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
    return this;
  }
  get amount() {
    return this._amount;
  }
  setAmount(amount) {
    this._amount = typeof amount === "number" ? import_long13.default.fromNumber(amount) : amount;
    return this;
  }
  get payerAccountIds() {
    return this._payerAccountIds;
  }
  setPayerAccountIds(payerAccountIds) {
    this._payerAccountIds = payerAccountIds;
    return this;
  }
  static _fromProtobuf(fee) {
    return new AssessedCustomFee({
      feeCollectorAccountId: fee.feeCollectorAccountId != null ? AccountId._fromProtobuf(fee.feeCollectorAccountId) : void 0,
      tokenId: fee.tokenId != null ? TokenId._fromProtobuf(fee.tokenId) : void 0,
      amount: fee.amount != null ? fee.amount : void 0,
      payerAccountIds: fee.effectivePayerAccountId != null ? fee.effectivePayerAccountId.map((id) => AccountId._fromProtobuf(id)) : void 0
    });
  }
  _toProtobuf() {
    return {
      feeCollectorAccountId: this.feeCollectorAccountId != null ? this.feeCollectorAccountId._toProtobuf() : null,
      tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      amount: this._amount,
      effectivePayerAccountId: this._payerAccountIds != null ? this._payerAccountIds.map((id) => id._toProtobuf()) : null
    };
  }
};

// node_modules/@hashgraph/sdk/src/token/TokenAssociation.js
var TokenAssociation = class {
  constructor(props = {}) {
    this._accountId;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    this._tokenId;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId;
    return this;
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
    return this;
  }
  static _fromProtobuf(association) {
    return new TokenAssociation({
      accountId: association.accountId != null ? AccountId._fromProtobuf(association.accountId) : void 0,
      tokenId: association.tokenId != null ? TokenId._fromProtobuf(association.tokenId) : void 0
    });
  }
  _toProtobuf() {
    return {
      accountId: this._accountId != null ? this._accountId._toProtobuf() : void 0,
      tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : void 0
    };
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionRecord.js
var TransactionRecord = class {
  constructor(props) {
    this.receipt = props.receipt;
    this.transactionHash = props.transactionHash;
    this.consensusTimestamp = props.consensusTimestamp;
    this.transactionId = props.transactionId;
    this.transactionMemo = props.transactionMemo;
    this.transactionFee = props.transactionFee;
    this.transfers = props.transfers;
    this.contractFunctionResult = props.contractFunctionResult != null ? props.contractFunctionResult : null;
    this.tokenTransfers = props.tokenTransfers;
    this.scheduleRef = props.scheduleRef;
    this.assessedCustomFees = props.assessedCustomFees;
    this.nftTransfers = props.nftTransfers;
    this.automaticTokenAssociations = props.automaticTokenAssociations;
    this.parentConsensusTimestamp = props.parentConsensusTimestamp;
    this.aliasKey = props.aliasKey;
    this.duplicates = props.duplicates;
    this.children = props.children;
    Object.freeze(this);
  }
  _toProtobuf() {
    const tokenTransfers = this.tokenTransfers._toProtobuf();
    const nftTransfers = this.nftTransfers._toProtobuf();
    const tokenTransferLists = [];
    for (const tokenTransfer of tokenTransfers) {
      for (const nftTransfer of nftTransfers) {
        if (tokenTransfer.token != null && nftTransfer.token != null && tokenTransfer.token.shardNum === nftTransfer.token.shardNum && tokenTransfer.token.realmNum === nftTransfer.token.realmNum && tokenTransfer.token.tokenNum === nftTransfer.token.tokenNum) {
          tokenTransferLists.push({
            token: tokenTransfer.token,
            transfers: tokenTransfer.transfers,
            nftTransfers: tokenTransfer.nftTransfers
          });
        } else {
          tokenTransferLists.push(tokenTransfer);
          tokenTransferLists.push(nftTransfer);
        }
      }
    }
    const duplicates = this.duplicates.map((record) => record._toProtobuf().transactionRecord);
    const children = this.children.map((record) => record._toProtobuf().transactionRecord);
    return {
      duplicateTransactionRecords: duplicates,
      childTransactionRecords: children,
      transactionRecord: {
        receipt: this.receipt._toProtobuf().receipt,
        transactionHash: this.transactionHash != null ? this.transactionHash : null,
        consensusTimestamp: this.consensusTimestamp != null ? this.consensusTimestamp._toProtobuf() : null,
        transactionID: this.transactionId != null ? this.transactionId._toProtobuf() : null,
        memo: this.transactionMemo != null ? this.transactionMemo : null,
        transactionFee: this.transactionFee != null ? this.transactionFee.toTinybars() : null,
        contractCallResult: this.contractFunctionResult != null ? this.contractFunctionResult : null,
        contractCreateResult: this.contractFunctionResult != null ? this.contractFunctionResult : null,
        transferList: this.transfers != null ? {
          accountAmounts: this.transfers.map((transfer) => transfer._toProtobuf())
        } : null,
        tokenTransferLists,
        scheduleRef: this.scheduleRef != null ? this.scheduleRef._toProtobuf() : null,
        assessedCustomFees: this.assessedCustomFees.map((fee) => fee._toProtobuf()),
        automaticTokenAssociations: this.automaticTokenAssociations.map((association) => association._toProtobuf()),
        parentConsensusTimestamp: this.parentConsensusTimestamp != null ? this.parentConsensusTimestamp._toProtobuf() : null,
        alias: this.aliasKey != null ? proto8.Key.encode(this.aliasKey._toProtobufKey()).finish() : null
      }
    };
  }
  static _fromProtobuf(response) {
    const record = response.transactionRecord;
    let aliasKey = record.alias != null && record.alias.length > 0 ? Key2._fromProtobufKey(proto8.Key.decode(record.alias)) : null;
    if (!(aliasKey instanceof PublicKey2)) {
      aliasKey = null;
    }
    const children = response.childTransactionRecords != null ? response.childTransactionRecords.map((child) => TransactionRecord._fromProtobuf({
      transactionRecord: child
    })) : [];
    const duplicates = response.duplicateTransactionRecords != null ? response.duplicateTransactionRecords.map((duplicate) => TransactionRecord._fromProtobuf({
      transactionRecord: duplicate
    })) : [];
    const contractFunctionResult = record.contractCallResult != null ? ContractFunctionResult._fromProtobuf(record.contractCallResult) : record.contractCreateResult != null ? ContractFunctionResult._fromProtobuf(record.contractCreateResult) : void 0;
    return new TransactionRecord({
      receipt: TransactionReceipt._fromProtobuf({
        receipt: record.receipt
      }),
      transactionHash: record.transactionHash != null ? record.transactionHash : new Uint8Array(),
      consensusTimestamp: Timestamp._fromProtobuf(record.consensusTimestamp),
      transactionId: TransactionId._fromProtobuf(record.transactionID),
      transactionMemo: record.memo != null ? record.memo : "",
      transactionFee: Hbar.fromTinybars(record.transactionFee != null ? record.transactionFee : 0),
      transfers: (record.transferList != null ? record.transferList.accountAmounts != null ? record.transferList.accountAmounts : [] : []).map((aa) => Transfer._fromProtobuf(aa)),
      contractFunctionResult,
      tokenTransfers: TokenTransferMap._fromProtobuf(record.tokenTransferLists != null ? record.tokenTransferLists : []),
      scheduleRef: record.scheduleRef != null ? ScheduleId._fromProtobuf(record.scheduleRef) : null,
      assessedCustomFees: record.assessedCustomFees != null ? record.assessedCustomFees.map((fee) => AssessedCustomFee._fromProtobuf(fee)) : [],
      nftTransfers: TokenNftTransferMap._fromProtobuf(record.tokenTransferLists != null ? record.tokenTransferLists : []),
      automaticTokenAssociations: record.automaticTokenAssociations != null ? record.automaticTokenAssociations.map((association) => TokenAssociation._fromProtobuf(association)) : [],
      parentConsensusTimestamp: record.parentConsensusTimestamp != null ? Timestamp._fromProtobuf(record.parentConsensusTimestamp) : null,
      aliasKey,
      duplicates,
      children
    });
  }
  static fromBytes(bytes2) {
    return TransactionRecord._fromProtobuf(proto8.TransactionGetRecordResponse.decode(bytes2));
  }
  toBytes() {
    return proto8.TransactionGetRecordResponse.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/src/transaction/TransactionRecordQuery.js
var import_proto4 = __toModule(require_lib());
var TransactionRecordQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._transactionId = null;
    this._includeChildren = null;
    this._includeDuplicates = null;
    if (props.transactionId != null) {
      this.setTransactionId(props.transactionId);
    }
    if (props.includeChildren != null) {
      this.setIncludeChildren(props.includeChildren);
    }
    if (props.includeDuplicates != null) {
      this.setIncludeDuplicates(props.includeDuplicates);
    }
  }
  get transactionId() {
    return this._transactionId;
  }
  static _fromProtobuf(query) {
    const record = query.transactionGetRecord;
    return new TransactionRecordQuery({
      transactionId: record.transactionID ? TransactionId._fromProtobuf(record.transactionID) : void 0,
      includeChildren: record.includeChildRecords != null ? record.includeChildRecords : void 0,
      includeDuplicates: record.includeDuplicates != null ? record.includeDuplicates : void 0
    });
  }
  setTransactionId(transactionId) {
    this._transactionId = typeof transactionId === "string" ? TransactionId.fromString(transactionId) : transactionId.clone();
    return this;
  }
  setIncludeChildren(includeChildren) {
    this._includeChildren = includeChildren;
    return this;
  }
  get includeChildren() {
    return this._includeChildren != null ? this._includeChildren : false;
  }
  setIncludeDuplicates(includeDuplicates) {
    this._duplicates = includeDuplicates;
    return this;
  }
  get includeDuplicates() {
    return this._duplicates != null ? this._duplicates : false;
  }
  _shouldRetry(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    let status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : import_proto4.ResponseCodeEnum.OK);
    switch (status) {
      case Status.Busy:
      case Status.Unknown:
      case Status.ReceiptNotFound:
      case Status.RecordNotFound:
        return ExecutionState.Retry;
      case Status.Ok:
        break;
      default:
        return ExecutionState.Error;
    }
    const transactionGetRecord = response.transactionGetRecord;
    const header = transactionGetRecord.header;
    if (header.responseType === import_proto4.ResponseType.COST_ANSWER) {
      return ExecutionState.Finished;
    }
    const record = transactionGetRecord.transactionRecord;
    const receipt = record.receipt;
    const receiptStatusCode = receipt.status;
    status = Status._fromCode(receiptStatusCode);
    switch (status) {
      case Status.Ok:
      case Status.Busy:
      case Status.Unknown:
      case Status.ReceiptNotFound:
      case Status.RecordNotFound:
        return ExecutionState.Retry;
      case Status.Success:
        return ExecutionState.Finished;
      default:
        return ExecutionState.Error;
    }
  }
  _mapStatusError(request, response) {
    const { nodeTransactionPrecheckCode } = this._mapResponseHeader(response);
    let status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : import_proto4.ResponseCodeEnum.OK);
    switch (status) {
      case Status.Ok:
        break;
      default:
        return new PrecheckStatusError({
          status,
          transactionId: this._getTransactionId()
        });
    }
    const transactionGetRecord = response.transactionGetRecord;
    const record = transactionGetRecord.transactionRecord;
    const receipt = record.receipt;
    const receiptStatusError = receipt.status;
    status = Status._fromCode(receiptStatusError);
    return new ReceiptStatusError({
      status,
      transactionId: this._getTransactionId(),
      transactionReceipt: TransactionReceipt._fromProtobuf({ receipt })
    });
  }
  _validateChecksums(client) {
    if (this._transactionId != null && this._transactionId.accountId != null) {
      this._transactionId.accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.getTxRecordByTxID(request);
  }
  _mapResponseHeader(response) {
    const transactionGetRecord = response.transactionGetRecord;
    return transactionGetRecord.header;
  }
  _mapResponse(response, nodeAccountId, request) {
    const record = response.transactionGetRecord;
    return Promise.resolve(TransactionRecord._fromProtobuf(record));
  }
  _onMakeRequest(header) {
    return {
      transactionGetRecord: {
        header,
        transactionID: this._transactionId != null ? this._transactionId._toProtobuf() : null,
        includeChildRecords: this._includeChildren,
        includeDuplicates: this._includeDuplicates
      }
    };
  }
};
QUERY_REGISTRY.set("transactionGetRecord", TransactionRecordQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/transaction/TransactionResponse.js
var TransactionResponse = class {
  constructor(props) {
    this.nodeId = props.nodeId;
    this.transactionHash = props.transactionHash;
    this.transactionId = props.transactionId;
    Object.freeze(this);
  }
  async getReceipt(client) {
    const receipt = await new TransactionReceiptQuery().setTransactionId(this.transactionId).setNodeAccountIds([this.nodeId]).execute(client);
    if (receipt.status !== Status.Success) {
      throw new ReceiptStatusError({
        transactionReceipt: receipt,
        status: receipt.status,
        transactionId: this.transactionId
      });
    }
    return receipt;
  }
  async getRecord(client) {
    await this.getReceipt(client);
    return new TransactionRecordQuery().setTransactionId(this.transactionId).setNodeAccountIds([this.nodeId]).execute(client);
  }
};

// node_modules/@hashgraph/sdk/src/cryptography/sha384.browser.js
async function digest2(data) {
  return new Uint8Array(await crypto.subtle.digest("SHA-384", data));
}

// node_modules/@hashgraph/sdk/src/transaction/TransactionHashMap.js
var TransactionHashMap = class extends ObjectMap {
  constructor() {
    super((s) => AccountId.fromString(s));
  }
  static async _fromTransaction(transaction) {
    const hashes = new TransactionHashMap();
    for (let i = 0; i < transaction._nodeIds.length; i++) {
      const nodeAccountId = transaction._nodeIds[i];
      const tx = transaction._transactions[i];
      const hash2 = await digest2(tx.signedTransactionBytes);
      hashes._set(nodeAccountId, hash2);
    }
    return hashes;
  }
};

// node_modules/@hashgraph/sdk/src/transaction/NodeAccountIdSignatureMap.js
var NodeAccountIdSignatureMap = class extends ObjectMap {
  constructor() {
    super((s) => PublicKey.fromString(s));
  }
  static _fromTransactionSigMap(sigMap) {
    const signatures = new NodeAccountIdSignatureMap();
    const sigPairs = sigMap.sigPair != null ? sigMap.sigPair : [];
    for (const sigPair of sigPairs) {
      if (sigPair.pubKeyPrefix != null && sigPair.ed25519 != null) {
        signatures._set(PublicKey.fromBytes(sigPair.pubKeyPrefix), sigPair.ed25519);
      }
    }
    return signatures;
  }
};

// node_modules/@hashgraph/sdk/src/transaction/SignatureMap.js
var SignatureMap = class extends ObjectMap {
  constructor() {
    super((s) => AccountId.fromString(s));
  }
  static _fromTransaction(transaction) {
    const signatures = new SignatureMap();
    for (let i = 0; i < transaction._nodeIds.length; i++) {
      const sigMap = transaction._signedTransactions[i].sigMap;
      if (sigMap != null) {
        signatures._set(transaction._nodeIds[i], NodeAccountIdSignatureMap._fromTransactionSigMap(sigMap));
      }
    }
    return signatures;
  }
};

// node_modules/@hashgraph/sdk/src/transaction/Transaction.js
var import_long14 = __toModule(require_long());
var import_proto5 = __toModule(require_lib());
var DEFAULT_AUTO_RENEW_PERIOD = import_long14.default.fromValue(7776e3);
var DEFAULT_RECORD_THRESHOLD = Hbar.fromTinybars(import_long14.default.fromString("9223372036854775807"));
var DEFAULT_TRANSACTION_VALID_DURATION = 120;
var CHUNK_SIZE = 1024;
var TRANSACTION_REGISTRY = new Map();
var Transaction = class extends Executable {
  constructor() {
    super();
    this._transactions = [];
    this._signedTransactions = [];
    this._signerPublicKeys = new Set();
    this._nextTransactionIndex = 0;
    this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;
    this._maxTransactionFee = new Hbar(2);
    this._transactionMemo = "";
    this._transactionIds = [];
    this._signOnDemand = false;
    this._publicKeys = [];
    this._transactionSigners = [];
  }
  static fromBytes(bytes2) {
    const signedTransactions = [];
    const transactionIds = [];
    const nodeIds = [];
    const transactionIdStrings = [];
    const nodeIdStrings = [];
    const bodies = [];
    const list = import_proto5.TransactionList.decode(bytes2).transactionList;
    if (list.length == 0) {
      const transaction = import_proto5.Transaction.decode(bytes2);
      if (transaction.signedTransactionBytes.length != 0) {
        list.push(transaction);
      } else {
        list.push({
          signedTransactionBytes: import_proto5.SignedTransaction.encode({
            bodyBytes: transaction.bodyBytes,
            sigMap: transaction.sigMap
          }).finish()
        });
      }
    }
    for (const transaction of list) {
      if (transaction.signedTransactionBytes == null) {
        throw new Error("Transaction.signedTransactionBytes are null");
      }
      const signedTransaction = import_proto5.SignedTransaction.decode(transaction.signedTransactionBytes);
      signedTransactions.push(signedTransaction);
      const body2 = import_proto5.TransactionBody.decode(signedTransaction.bodyBytes);
      if (body2.data == null) {
        throw new Error("(BUG) body.data was not set in the protobuf");
      }
      bodies.push(body2);
      if (body2.transactionID != null) {
        const transactionId = TransactionId._fromProtobuf(body2.transactionID);
        if (!transactionIdStrings.includes(transactionId.toString())) {
          transactionIds.push(transactionId);
          transactionIdStrings.push(transactionId.toString());
        }
      }
      if (body2.nodeAccountID != null) {
        const nodeAccountId = AccountId._fromProtobuf(body2.nodeAccountID);
        if (!nodeIdStrings.includes(nodeAccountId.toString())) {
          nodeIds.push(nodeAccountId);
          nodeIdStrings.push(nodeAccountId.toString());
        }
      }
    }
    const body = bodies[0];
    if (body == null || body.data == null) {
      throw new Error("No transaction found in bytes or failed to decode TransactionBody");
    }
    const fromProtobuf = TRANSACTION_REGISTRY.get(body.data);
    if (fromProtobuf == null) {
      throw new Error(`(BUG) Transaction.fromBytes() not implemented for type ${body.data}`);
    }
    return fromProtobuf(list, signedTransactions, transactionIds, nodeIds, bodies);
  }
  schedule() {
    this._requireNotFrozen();
    if (SCHEDULE_CREATE_TRANSACTION.length != 1) {
      throw new Error("ScheduleCreateTransaction has not been loaded yet");
    }
    return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);
  }
  static _fromProtobufTransactions(transaction, transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const zero = new AccountId(0);
    for (let i = 0; i < nodeIds.length; i++) {
      if (nodeIds[i].equals(zero)) {
        nodeIds.splice(i--, 1);
      }
    }
    transaction._transactions = transactions;
    transaction._signedTransactions = signedTransactions;
    transaction._transactionIds = transactionIds;
    transaction._nodeIds = nodeIds;
    transaction._nextNodeIndex = 0;
    transaction._nextTransactionIndex = 0;
    transaction._transactionValidDuration = body.transactionValidDuration != null && body.transactionValidDuration.seconds != null ? import_long14.default.fromValue(body.transactionValidDuration.seconds).toInt() : DEFAULT_TRANSACTION_VALID_DURATION;
    transaction._maxTransactionFee = body.transactionFee != null ? Hbar.fromTinybars(body.transactionFee) : new Hbar(0);
    transaction._transactionMemo = body.memo != null ? body.memo : "";
    for (let i = 0; i < nodeIds.length; i++) {
      const signedTransaction = signedTransactions[i];
      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {
        for (const sigPair of signedTransaction.sigMap.sigPair) {
          transaction._signerPublicKeys.add(encode3(sigPair.pubKeyPrefix));
          transaction._publicKeys.push(PublicKey2.fromBytes(sigPair.pubKeyPrefix));
          transaction._transactionSigners.push(null);
        }
      }
    }
    return transaction;
  }
  setNodeAccountIds(nodeIds) {
    this._requireNotFrozen();
    super.setNodeAccountIds(nodeIds);
    return this;
  }
  get transactionValidDuration() {
    return this._transactionValidDuration;
  }
  setTransactionValidDuration(validDuration) {
    this._requireNotFrozen();
    this._transactionValidDuration = validDuration;
    return this;
  }
  get maxTransactionFee() {
    return this._maxTransactionFee;
  }
  setMaxTransactionFee(maxTransactionFee) {
    this._requireNotFrozen();
    this._maxTransactionFee = maxTransactionFee instanceof Hbar ? maxTransactionFee : new Hbar(maxTransactionFee);
    return this;
  }
  get transactionMemo() {
    return this._transactionMemo;
  }
  setTransactionMemo(transactionMemo) {
    this._requireNotFrozen();
    this._transactionMemo = transactionMemo;
    return this;
  }
  get transactionId() {
    if (this._transactionIds.length === 0) {
      throw new Error("transaction must have been frozen before getting the transaction ID, try calling `freeze`");
    }
    return this._transactionIds[this._nextTransactionIndex];
  }
  setTransactionId(transactionId) {
    this._requireNotFrozen();
    this._transactionIds = [transactionId];
    return this;
  }
  sign(privateKey) {
    return this.signWith(privateKey.publicKey, (message) => Promise.resolve(privateKey.sign(message)));
  }
  async signWith(publicKey, transactionSigner) {
    this._requireFrozen();
    const publicKeyData = publicKey.toBytesRaw();
    const publicKeyHex = encode3(publicKeyData);
    if (this._signerPublicKeys.has(publicKeyHex)) {
      return this;
    }
    this._transactions = [];
    this._signerPublicKeys.add(publicKeyHex);
    if (this._signOnDemand) {
      this._publicKeys.push(publicKey);
      this._transactionSigners.push(transactionSigner);
      return this;
    }
    for (const signedTransaction of this._signedTransactions) {
      const bodyBytes = signedTransaction.bodyBytes;
      const signature = await transactionSigner(bodyBytes);
      if (signedTransaction.sigMap == null) {
        signedTransaction.sigMap = {};
      }
      if (signedTransaction.sigMap.sigPair == null) {
        signedTransaction.sigMap.sigPair = [];
      }
      signedTransaction.sigMap.sigPair.push(publicKey._toProtobufSignature(signature));
    }
    return this;
  }
  signWithOperator(client) {
    const operator = client._operator;
    if (operator == null) {
      throw new Error("`client` must have an operator to sign with the operator");
    }
    if (!this._isFrozen()) {
      this.freezeWith(client);
    }
    return this.signWith(operator.publicKey, operator.transactionSigner);
  }
  _requireOneNodeAccountId() {
    if (this._nodeIds.length != 1) {
      throw "transaction did not have exactly one node ID set";
    }
  }
  addSignature(publicKey, signature) {
    this._requireOneNodeAccountId();
    if (!this.isFrozen()) {
      this.freeze();
    }
    const publicKeyData = publicKey.toBytesRaw();
    const publicKeyHex = encode3(publicKeyData);
    if (this._signerPublicKeys.has(publicKeyHex)) {
      return this;
    }
    this._transactions = [];
    for (const transaction of this._signedTransactions) {
      if (transaction.sigMap == null) {
        transaction.sigMap = {};
      }
      if (transaction.sigMap.sigPair == null) {
        transaction.sigMap.sigPair = [];
      }
      transaction.sigMap.sigPair.push(publicKey._toProtobufSignature(signature));
    }
    this._signerPublicKeys.add(publicKeyHex);
    this._publicKeys.push(publicKey);
    this._transactionSigners.push(null);
    return this;
  }
  getSignatures() {
    if (this._signOnDemand) {
      throw new Error("Please use `getSignaturesAsync()` if `signOnDemand` is enabled");
    }
    this._buildAllTransactions();
    return SignatureMap._fromTransaction(this);
  }
  async getSignaturesAsync() {
    await this._buildAllTransactionsAsync();
    return SignatureMap._fromTransaction(this);
  }
  freeze() {
    return this.freezeWith(null);
  }
  freezeWith(client) {
    if (client != null) {
      this._signOnDemand = client._signOnDemand;
    }
    if (client != null && this._maxTransactionFee == null) {
      this._maxTransactionFee = client.maxTransactionFee;
    }
    if (client != null && this._transactionIds.length === 0) {
      const operator = client._operator;
      if (operator == null) {
        throw new Error("`client` must have an `operator` or `transactionId` must be set");
      }
      this.setTransactionId(TransactionId.generate(operator.accountId));
    }
    if (this._transactionIds.length === 0) {
      throw new Error("`transactionId` must be set or `client` must be provided with `freezeWith`");
    }
    if (client != null && this._transactionIds[0].accountId != null) {
      this._transactionIds[0].accountId.validateChecksum(client);
    }
    if (this._nodeIds.length > 0) {
    } else if (client != null) {
      this._nodeIds = client._network.getNodeAccountIdsForExecute();
    } else {
      throw new Error("`nodeAccountId` must be set or `client` must be provided with `freezeWith`");
    }
    this._signedTransactions = this._nodeIds.map((nodeId) => this._makeSignedTransaction(nodeId));
    return this;
  }
  toBytes() {
    this._requireFrozen();
    if (this._signOnDemand) {
      throw new Error("Please use `toBytesAsync()` if `signOnDemand` is enabled");
    }
    this._buildAllTransactions();
    return import_proto5.TransactionList.encode({
      transactionList: this._transactions
    }).finish();
  }
  async toBytesAsync() {
    this._requireFrozen();
    await this._buildAllTransactionsAsync();
    return import_proto5.TransactionList.encode({
      transactionList: this._transactions
    }).finish();
  }
  async getTransactionHash() {
    this._requireFrozen();
    await this._buildAllTransactionsAsync();
    return digest2(this._transactions[0].signedTransactionBytes);
  }
  async getTransactionHashPerNode() {
    this._requireFrozen();
    await this._buildAllTransactionsAsync();
    return await TransactionHashMap._fromTransaction(this);
  }
  isFrozen() {
    return this._signedTransactions.length > 0;
  }
  _getTransactionId() {
    return this.transactionId;
  }
  _validateChecksums(client) {
  }
  async _beforeExecute(client) {
    if (!this._isFrozen()) {
      this.freezeWith(client);
    }
    if (client.isAutoValidateChecksumsEnabled()) {
      this._validateChecksums(client);
    }
    const transactionId = this.transactionId;
    const operatorAccountId = client.operatorAccountId;
    if (operatorAccountId != null && transactionId.accountId != null && operatorAccountId.equals(transactionId.accountId)) {
      await this.signWithOperator(client);
    }
  }
  async _makeRequestAsync() {
    const index = this._nextTransactionIndex * this._nodeIds.length + this._nextNodeIndex;
    await this._buildTransactionAsync(index);
    return this._transactions[index];
  }
  async _signTranscation(index) {
    const signedTransaction = this._signedTransactions[index];
    const bodyBytes = signedTransaction.bodyBytes;
    if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null && signedTransaction.sigMap.sigPair.length > 0) {
      for (let i = 0; i < this._publicKeys.length; i++) {
        const publicKey = this._publicKeys[i];
        const signer = this._transactionSigners[i];
        if (signedTransaction.sigMap.sigPair[0].pubKeyPrefix != null && signer != null && arrayEqual2(signedTransaction.sigMap.sigPair[0].pubKeyPrefix, publicKey.toBytesRaw())) {
          return;
        }
      }
    }
    for (let j = 0; j < this._publicKeys.length; j++) {
      const publicKey = this._publicKeys[j];
      const transactionSigner = this._transactionSigners[j];
      if (transactionSigner == null) {
        continue;
      }
      const signature = await transactionSigner(bodyBytes);
      if (signedTransaction.sigMap == null) {
        signedTransaction.sigMap = {};
      }
      if (signedTransaction.sigMap.sigPair == null) {
        signedTransaction.sigMap.sigPair = [];
      }
      signedTransaction.sigMap.sigPair.push(publicKey._toProtobufSignature(signature));
    }
  }
  _buildAllTransactions() {
    for (let i = 0; i < this._signedTransactions.length; i++) {
      this._buildTransaction(i);
    }
  }
  async _buildAllTransactionsAsync() {
    for (let i = 0; i < this._signedTransactions.length; i++) {
      await this._buildTransactionAsync(i);
    }
  }
  _buildTransaction(index) {
    if (this._transactions.length < index) {
      for (let i = this._transactions.length; i < index; i++) {
        this._transactions.push(null);
      }
    }
    this._transactions[index] = {
      signedTransactionBytes: import_proto5.SignedTransaction.encode(this._signedTransactions[index]).finish()
    };
  }
  async _buildTransactionAsync(index) {
    if (this._transactions.length < index) {
      for (let i = this._transactions.length; i < index; i++) {
        this._transactions.push(null);
      }
    } else if (this._transactions.length > index && this._transactions[index] != null && this._transactions[index].signedTransactionBytes != null) {
      return;
    }
    await this._signTranscation(index);
    this._transactions.push({
      signedTransactionBytes: import_proto5.SignedTransaction.encode(this._signedTransactions[index]).finish()
    });
  }
  _shouldRetry(request, response) {
    const { nodeTransactionPrecheckCode } = response;
    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : import_proto5.ResponseCodeEnum.OK);
    switch (status) {
      case Status.Busy:
      case Status.Unknown:
      case Status.PlatformTransactionNotCreated:
        return ExecutionState.Retry;
      case Status.Ok:
        return ExecutionState.Finished;
      default:
        return ExecutionState.Error;
    }
  }
  _mapStatusError(request, response) {
    const { nodeTransactionPrecheckCode } = response;
    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : import_proto5.ResponseCodeEnum.OK);
    return new PrecheckStatusError({
      status,
      transactionId: this._getTransactionId()
    });
  }
  async _mapResponse(response, nodeId, request) {
    const transactionHash = await digest2(request.signedTransactionBytes);
    const transactionId = this.transactionId;
    this._nextTransactionIndex = (this._nextTransactionIndex + 1) % this._transactionIds.length;
    return new TransactionResponse({
      nodeId,
      transactionHash,
      transactionId
    });
  }
  _getNodeAccountId() {
    if (this._nodeIds.length === 0) {
      throw new Error("(BUG) Transaction::_getNodeAccountId called before transaction has been frozen");
    }
    return this._nodeIds[this._nextNodeIndex % this._nodeIds.length];
  }
  _makeSignedTransaction(nodeId) {
    const body = this._makeTransactionBody(nodeId);
    const bodyBytes = import_proto5.TransactionBody.encode(body).finish();
    return {
      bodyBytes,
      sigMap: {
        sigPair: []
      }
    };
  }
  _makeTransactionBody(nodeId) {
    return {
      [this._getTransactionDataCase()]: this._makeTransactionData(),
      transactionFee: this._maxTransactionFee != null ? this._maxTransactionFee.toTinybars() : null,
      memo: this._transactionMemo,
      transactionID: this._transactionIds[this._nextTransactionIndex] != null ? this._transactionIds[this._nextTransactionIndex]._toProtobuf() : null,
      nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,
      transactionValidDuration: {
        seconds: import_long14.default.fromNumber(this._transactionValidDuration)
      }
    };
  }
  _getTransactionDataCase() {
    throw new Error("not implemented");
  }
  _getScheduledTransactionBody() {
    return {
      memo: this.transactionMemo,
      transactionFee: this.maxTransactionFee != null ? this.maxTransactionFee.toTinybars() : null,
      [this._getTransactionDataCase()]: this._makeTransactionData()
    };
  }
  _makeTransactionData() {
    throw new Error("not implemented");
  }
  _isFrozen() {
    return this._signedTransactions.length > 0;
  }
  _requireNotFrozen() {
    if (this._isFrozen()) {
      throw new Error("transaction is immutable; it has at least one signature or has been explicitly frozen");
    }
  }
  _requireFrozen() {
    if (!this._isFrozen()) {
      throw new Error("transaction must have been frozen before calculating the hash will be stable, try calling `freeze`");
    }
  }
};
var SCHEDULE_CREATE_TRANSACTION = [];

// node_modules/@hashgraph/sdk/src/Duration.js
var import_long15 = __toModule(require_long());
var Duration = class {
  constructor(seconds) {
    this.seconds = seconds instanceof import_long15.default ? seconds : import_long15.default.fromNumber(seconds);
    Object.freeze(this);
  }
  _toProtobuf() {
    return {
      seconds: this.seconds
    };
  }
  static _fromProtobuf(duration) {
    return new Duration(duration.seconds);
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountCreateTransaction.js
var import_long16 = __toModule(require_long());
var AccountCreateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._key = null;
    this._initialBalance = null;
    this._sendRecordThreshold = DEFAULT_RECORD_THRESHOLD;
    this._receiveRecordThreshold = DEFAULT_RECORD_THRESHOLD;
    this._receiverSignatureRequired = false;
    this._proxyAccountId = null;
    this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);
    this._accountMemo = null;
    this._maxAutomaticTokenAssociations = null;
    if (props.key != null) {
      this.setKey(props.key);
    }
    if (props.receiverSignatureRequired != null) {
      this.setReceiverSignatureRequired(props.receiverSignatureRequired);
    }
    if (props.initialBalance != null) {
      this.setInitialBalance(props.initialBalance);
    }
    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.accountMemo != null) {
      this.setAccountMemo(props.accountMemo);
    }
    if (props.maxAutomaticTokenAssociations != null) {
      this.setMaxAutomaticTokenAssociations(props.maxAutomaticTokenAssociations);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = body.cryptoCreateAccount;
    return Transaction._fromProtobufTransactions(new AccountCreateTransaction({
      key: create.key != null ? Key2._fromProtobufKey(create.key) : void 0,
      initialBalance: create.initialBalance != null ? create.initialBalance : void 0,
      receiverSignatureRequired: create.receiverSigRequired != null ? create.receiverSigRequired : void 0,
      proxyAccountId: create.proxyAccountID != null ? AccountId._fromProtobuf(create.proxyAccountID) : void 0,
      autoRenewPeriod: create.autoRenewPeriod != null ? create.autoRenewPeriod.seconds != null ? create.autoRenewPeriod.seconds : void 0 : void 0,
      accountMemo: create.memo != null ? create.memo : void 0,
      maxAutomaticTokenAssociations: create.maxAutomaticTokenAssociations != null ? create.maxAutomaticTokenAssociations : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get key() {
    return this._key;
  }
  setKey(key) {
    this._requireNotFrozen();
    this._key = key;
    return this;
  }
  get initialBalance() {
    return this._initialBalance;
  }
  setInitialBalance(initialBalance) {
    this._requireNotFrozen();
    this._initialBalance = initialBalance instanceof Hbar ? initialBalance : new Hbar(initialBalance);
    return this;
  }
  get receiverSignatureRequired() {
    return this._receiverSignatureRequired;
  }
  setReceiverSignatureRequired(receiverSignatureRequired) {
    this._requireNotFrozen();
    this._receiverSignatureRequired = receiverSignatureRequired;
    return this;
  }
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();
    this._proxyAccountId = proxyAccountId;
    return this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration ? autoRenewPeriod : new Duration(autoRenewPeriod);
    return this;
  }
  get accountMemo() {
    return this._accountMemo;
  }
  setAccountMemo(memo) {
    this._requireNotFrozen();
    this._accountMemo = memo;
    return this;
  }
  get maxAutomaticTokenAssociations() {
    return this._maxAutomaticTokenAssociations;
  }
  setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
    this._requireNotFrozen();
    this._maxAutomaticTokenAssociations = typeof maxAutomaticTokenAssociations === "number" ? import_long16.default.fromNumber(maxAutomaticTokenAssociations) : maxAutomaticTokenAssociations;
    return this;
  }
  _validateChecksums(client) {
    if (this._proxyAccountId != null) {
      this._proxyAccountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.createAccount(request);
  }
  _getTransactionDataCase() {
    return "cryptoCreateAccount";
  }
  _makeTransactionData() {
    return {
      key: this._key != null ? this._key._toProtobufKey() : null,
      initialBalance: this._initialBalance != null ? this._initialBalance.toTinybars() : null,
      autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      receiveRecordThreshold: this._receiveRecordThreshold.toTinybars(),
      sendRecordThreshold: this._sendRecordThreshold.toTinybars(),
      receiverSigRequired: this._receiverSignatureRequired,
      memo: this._accountMemo,
      maxAutomaticTokenAssociations: this._maxAutomaticTokenAssociations != null ? this._maxAutomaticTokenAssociations.toInt() : null
    };
  }
};
TRANSACTION_REGISTRY.set("cryptoCreateAccount", AccountCreateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/AccountDeleteTransaction.js
var AccountDeleteTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._accountId = null;
    this._transferAccountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    if (props.transferAccountId != null) {
      this.setTransferAccountId(props.transferAccountId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const accountDelete = body.cryptoDelete;
    return Transaction._fromProtobufTransactions(new AccountDeleteTransaction({
      accountId: accountDelete.deleteAccountID != null ? AccountId._fromProtobuf(accountDelete.deleteAccountID) : void 0,
      transferAccountId: accountDelete.transferAccountID != null ? AccountId._fromProtobuf(accountDelete.transferAccountID) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  get transferAccountId() {
    return this._transferAccountId;
  }
  setTransferAccountId(transferAccountId) {
    this._requireNotFrozen();
    this._transferAccountId = typeof transferAccountId === "string" ? AccountId.fromString(transferAccountId) : transferAccountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
    if (this._transferAccountId != null) {
      this._transferAccountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.cryptoDelete(request);
  }
  _getTransactionDataCase() {
    return "cryptoDelete";
  }
  _makeTransactionData() {
    return {
      deleteAccountID: this._accountId != null ? this._accountId._toProtobuf() : null,
      transferAccountID: this._transferAccountId != null ? this._transferAccountId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("cryptoDelete", AccountDeleteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/LiveHash.js
var LiveHash = class {
  constructor(props) {
    this.accountId = props.accountId;
    this.hash = props.hash;
    this.keys = props.keys;
    this.duration = props.duration;
    Object.freeze(this);
  }
  static _fromProtobuf(liveHash) {
    const liveHash_ = liveHash;
    return new LiveHash({
      accountId: AccountId._fromProtobuf(liveHash_.accountId),
      hash: liveHash_.hash != null ? liveHash_.hash : new Uint8Array(),
      keys: liveHash_.keys != null ? KeyList2.__fromProtobufKeyList(liveHash_.keys) : new KeyList2(),
      duration: Duration._fromProtobuf(liveHash_.duration)
    });
  }
  _toProtobuf() {
    return {
      accountId: this.accountId._toProtobuf(),
      hash: this.hash,
      keys: this.keys._toProtobufKey().keyList,
      duration: this.duration._toProtobuf()
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountInfo.js
var import_long18 = __toModule(require_long());

// node_modules/@hashgraph/sdk/src/account/TokenRelationship.js
var import_long17 = __toModule(require_long());
var TokenRelationship = class {
  constructor(props) {
    this.tokenId = props.tokenId;
    this.symbol = props.symbol;
    this.balance = props.balance;
    this.isKycGranted = props.isKycGranted;
    this.isFrozen = props.isFrozen;
    this.automaticAssociation = props.automaticAssociation;
    Object.freeze(this);
  }
  static _fromProtobuf(relationship) {
    const tokenId = TokenId._fromProtobuf(relationship.tokenId);
    const isKycGranted = relationship.kycStatus == null || relationship.kycStatus === 0 ? null : relationship.kycStatus === 1;
    const isFrozen = relationship.freezeStatus == null || relationship.freezeStatus === 0 ? null : relationship.freezeStatus === 1;
    return new TokenRelationship({
      tokenId,
      symbol: relationship.symbol,
      balance: relationship.balance != null ? relationship.balance instanceof import_long17.default ? relationship.balance : import_long17.default.fromValue(relationship.balance) : import_long17.default.ZERO,
      isKycGranted,
      isFrozen,
      automaticAssociation: relationship.automaticAssociation != null ? relationship.automaticAssociation : null
    });
  }
  _toProtobuf() {
    return {
      tokenId: this.tokenId._toProtobuf(),
      symbol: this.symbol,
      balance: this.balance,
      kycStatus: this.isKycGranted == null ? 0 : this.isKycGranted ? 1 : 2,
      freezeStatus: this.isFrozen == null ? 0 : this.isFrozen ? 1 : 2,
      automaticAssociation: this.automaticAssociation
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/TokenRelationshipMap.js
var TokenRelationshipMap = class extends ObjectMap {
  constructor() {
    super((s) => TokenId.fromString(s));
  }
  static _fromProtobuf(relationships) {
    const tokenRelationships = new TokenRelationshipMap();
    for (const relationship of relationships) {
      const tokenId = TokenId._fromProtobuf(relationship.tokenId);
      tokenRelationships._set(tokenId, TokenRelationship._fromProtobuf(relationship));
    }
    return tokenRelationships;
  }
  _toProtobuf() {
    const list = [];
    for (const [_, relationship] of this) {
      list.push(relationship._toProtobuf());
    }
    return list;
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountInfo.js
var proto9 = __toModule(require_lib());
var AccountInfo = class {
  constructor(props) {
    this.accountId = props.accountId;
    this.contractAccountId = props.contractAccountId;
    this.isDeleted = props.isDeleted;
    this.proxyAccountId = props.proxyAccountId;
    this.proxyReceived = props.proxyReceived;
    this.key = props.key;
    this.balance = props.balance;
    this.sendRecordThreshold = props.sendRecordThreshold;
    this.receiveRecordThreshold = props.receiveRecordThreshold;
    this.isReceiverSignatureRequired = props.isReceiverSignatureRequired;
    this.expirationTime = props.expirationTime;
    this.autoRenewPeriod = props.autoRenewPeriod;
    this.liveHashes = props.liveHashes;
    this.tokenRelationships = props.tokenRelationships;
    this.accountMemo = props.accountMemo;
    this.ownedNfts = props.ownedNfts;
    this.maxAutomaticTokenAssociations = props.maxAutomaticTokenAssociations;
    this.aliasKey = props.aliasKey;
    Object.freeze(this);
  }
  static _fromProtobuf(info) {
    let aliasKey = info.alias != null && info.alias.length > 0 ? Key2._fromProtobufKey(proto9.Key.decode(info.alias)) : null;
    if (!(aliasKey instanceof PublicKey2)) {
      aliasKey = null;
    }
    return new AccountInfo({
      accountId: AccountId._fromProtobuf(info.accountID),
      contractAccountId: info.contractAccountID != null ? info.contractAccountID : null,
      isDeleted: info.deleted != null ? info.deleted : false,
      key: Key2._fromProtobufKey(info.key),
      balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),
      sendRecordThreshold: Hbar.fromTinybars(info.generateSendRecordThreshold != null ? info.generateSendRecordThreshold : 0),
      receiveRecordThreshold: Hbar.fromTinybars(info.generateReceiveRecordThreshold != null ? info.generateReceiveRecordThreshold : 0),
      isReceiverSignatureRequired: info.receiverSigRequired != null ? info.receiverSigRequired : false,
      expirationTime: Timestamp._fromProtobuf(info.expirationTime),
      autoRenewPeriod: info.autoRenewPeriod != null ? new Duration(info.autoRenewPeriod.seconds) : new Duration(0),
      proxyAccountId: info.proxyAccountID != null && import_long18.default.fromValue(info.proxyAccountID.shardNum).toInt() !== 0 && import_long18.default.fromValue(info.proxyAccountID.realmNum).toInt() !== 0 && import_long18.default.fromValue(info.proxyAccountID.accountNum).toInt() !== 0 ? AccountId._fromProtobuf(info.proxyAccountID) : null,
      proxyReceived: Hbar.fromTinybars(info.proxyReceived != null ? info.proxyReceived : 0),
      liveHashes: (info.liveHashes != null ? info.liveHashes : []).map((hash2) => LiveHash._fromProtobuf(hash2)),
      tokenRelationships: TokenRelationshipMap._fromProtobuf(info.tokenRelationships != null ? info.tokenRelationships : []),
      accountMemo: info.memo != null ? info.memo : "",
      ownedNfts: info.ownedNfts ? info.ownedNfts : import_long18.default.ZERO,
      maxAutomaticTokenAssociations: info.maxAutomaticTokenAssociations ? import_long18.default.fromNumber(info.maxAutomaticTokenAssociations) : import_long18.default.ZERO,
      aliasKey
    });
  }
  _toProtobuf() {
    return {
      accountID: this.accountId._toProtobuf(),
      contractAccountID: this.contractAccountId,
      deleted: this.isDeleted,
      proxyAccountID: this.proxyAccountId != null ? this.proxyAccountId._toProtobuf() : null,
      proxyReceived: this.proxyReceived.toTinybars(),
      key: this.key._toProtobufKey(),
      balance: this.balance.toTinybars(),
      generateSendRecordThreshold: this.sendRecordThreshold.toTinybars(),
      generateReceiveRecordThreshold: this.receiveRecordThreshold.toTinybars(),
      receiverSigRequired: this.isReceiverSignatureRequired,
      expirationTime: this.expirationTime._toProtobuf(),
      autoRenewPeriod: this.autoRenewPeriod._toProtobuf(),
      liveHashes: this.liveHashes.map((hash2) => hash2._toProtobuf()),
      tokenRelationships: this.tokenRelationships != null ? this.tokenRelationships._toProtobuf() : null,
      memo: this.accountMemo,
      ownedNfts: this.ownedNfts,
      maxAutomaticTokenAssociations: this.maxAutomaticTokenAssociations.toInt(),
      alias: this.aliasKey != null ? proto9.Key.encode(this.aliasKey._toProtobufKey()).finish() : null
    };
  }
  static fromBytes(bytes2) {
    return AccountInfo._fromProtobuf(proto9.CryptoGetInfoResponse.AccountInfo.decode(bytes2));
  }
  toBytes() {
    return proto9.CryptoGetInfoResponse.AccountInfo.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountInfoQuery.js
var AccountInfoQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._accountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  static _fromProtobuf(query) {
    const info = query.cryptoGetInfo;
    return new AccountInfoQuery({
      accountId: info.accountID != null ? AccountId._fromProtobuf(info.accountID) : void 0
    });
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.getAccountInfo(request);
  }
  async getCost(client) {
    let cost = await super.getCost(client);
    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return Hbar.fromTinybars(25);
    }
  }
  _mapResponseHeader(response) {
    const cryptoGetInfo = response.cryptoGetInfo;
    return cryptoGetInfo.header;
  }
  _mapResponse(response, nodeAccountId, request) {
    const info = response.cryptoGetInfo;
    return Promise.resolve(AccountInfo._fromProtobuf(info.accountInfo));
  }
  _onMakeRequest(header) {
    return {
      cryptoGetInfo: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("cryptoGetInfo", AccountInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/AccountRecordsQuery.js
var AccountRecordsQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._accountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  static _fromProtobuf(query) {
    const records = query.cryptoGetAccountRecords;
    return new AccountRecordsQuery({
      accountId: records.accountID != null ? AccountId._fromProtobuf(records.accountID) : void 0
    });
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.getAccountRecords(request);
  }
  _mapResponseHeader(response) {
    const cryptoGetAccountRecords = response.cryptoGetAccountRecords;
    return cryptoGetAccountRecords.header;
  }
  _mapResponse(response, nodeAccountId, request) {
    const cryptoGetAccountRecords = response.cryptoGetAccountRecords;
    const records = cryptoGetAccountRecords.records;
    return Promise.resolve(records.map((record) => TransactionRecord._fromProtobuf({ transactionRecord: record })));
  }
  _onMakeRequest(header) {
    return {
      cryptoGetAccountRecords: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("cryptoGetAccountRecords", AccountRecordsQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/ProxyStaker.js
var ProxyStaker = class {
  constructor(props) {
    this.accountId = props.accountId;
    this.amount = props.amount instanceof Hbar ? props.amount : new Hbar(props.amount);
    Object.freeze(this);
  }
  static _fromProtobuf(transfer) {
    return new ProxyStaker({
      accountId: AccountId._fromProtobuf(transfer.accountID),
      amount: Hbar.fromTinybars(transfer.amount != null ? transfer.amount : 0)
    });
  }
  _toProtobuf() {
    return {
      accountID: this.accountId._toProtobuf(),
      amount: this.amount.toTinybars()
    };
  }
};

// node_modules/@hashgraph/sdk/src/account/AccountStakersQuery.js
var AccountStakersQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._accountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  static _fromProtobuf(query) {
    const stakers = query.cryptoGetProxyStakers;
    return new AccountStakersQuery({
      accountId: stakers.accountID != null ? AccountId._fromProtobuf(stakers.accountID) : void 0
    });
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.getStakersByAccountID(request);
  }
  _mapResponseHeader(response) {
    const cryptoGetProxyStakers = response.cryptoGetProxyStakers;
    return cryptoGetProxyStakers.header;
  }
  _mapResponse(response) {
    const cryptoGetProxyStakers = response.cryptoGetProxyStakers;
    const stakers = cryptoGetProxyStakers.stakers;
    return Promise.resolve((stakers.proxyStaker != null ? stakers.proxyStaker : []).map((staker) => ProxyStaker._fromProtobuf(staker)));
  }
  _onMakeRequest(header) {
    return {
      cryptoGetProxyStakers: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("cryptoGetProxyStakers", AccountStakersQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/AccountUpdateTransaction.js
var import_long19 = __toModule(require_long());
var AccountUpdateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._accountId = null;
    this._key = null;
    this._receiverSignatureRequired = false;
    this._proxyAccountId = null;
    this._autoRenewPeriod = null;
    this._expirationTime = null;
    this._accountMemo = null;
    this._maxAutomaticTokenAssociations = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    if (props.key != null) {
      this.setKey(props.key);
    }
    if (props.receiverSignatureRequired != null) {
      this.setReceiverSignatureRequired(props.receiverSignatureRequired);
    }
    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.accountMemo != null) {
      this.setAccountMemo(props.accountMemo);
    }
    if (props.maxAutomaticTokenAssociations != null) {
      this.setMaxAutomaticTokenAssociations(props.maxAutomaticTokenAssociations);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update3 = body.cryptoUpdateAccount;
    return Transaction._fromProtobufTransactions(new AccountUpdateTransaction({
      accountId: update3.accountIDToUpdate != null ? AccountId._fromProtobuf(update3.accountIDToUpdate) : void 0,
      key: update3.key != null ? Key2._fromProtobufKey(update3.key) : void 0,
      receiverSignatureRequired: update3.receiverSigRequired != null ? update3.receiverSigRequired : void 0,
      proxyAccountId: update3.proxyAccountID != null ? AccountId._fromProtobuf(update3.proxyAccountID) : void 0,
      autoRenewPeriod: update3.autoRenewPeriod != null ? update3.autoRenewPeriod.seconds != null ? update3.autoRenewPeriod.seconds : void 0 : void 0,
      expirationTime: update3.expirationTime != null ? Timestamp._fromProtobuf(update3.expirationTime) : void 0,
      accountMemo: update3.memo != null ? update3.memo.value != null ? update3.memo.value : void 0 : void 0,
      maxAutomaticTokenAssociations: update3.maxAutomaticTokenAssociations != null && update3.maxAutomaticTokenAssociations.value != null ? import_long19.default.fromNumber(update3.maxAutomaticTokenAssociations.value) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  get key() {
    return this._key;
  }
  setKey(key) {
    this._requireNotFrozen();
    this._key = key;
    return this;
  }
  get receiverSignatureRequired() {
    return this._receiverSignatureRequired;
  }
  setReceiverSignatureRequired(receiverSignatureRequired) {
    this._requireNotFrozen();
    this._receiverSignatureRequired = receiverSignatureRequired;
    return this;
  }
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();
    this._proxyAccountId = proxyAccountId;
    return this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration ? autoRenewPeriod : new Duration(autoRenewPeriod);
    return this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(expirationTime) {
    this._requireNotFrozen();
    this._expirationTime = expirationTime instanceof Date ? Timestamp.fromDate(expirationTime) : expirationTime;
    return this;
  }
  get accountMemo() {
    return this._accountMemo;
  }
  setAccountMemo(memo) {
    this._requireNotFrozen();
    this._accountMemo = memo;
    return this;
  }
  clearAccountMemo() {
    this._requireNotFrozen();
    this._accountMemo = null;
    return this;
  }
  get maxAutomaticTokenAssociations() {
    return this._maxAutomaticTokenAssociations;
  }
  setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
    this._requireNotFrozen();
    this._maxAutomaticTokenAssociations = typeof maxAutomaticTokenAssociations === "number" ? import_long19.default.fromNumber(maxAutomaticTokenAssociations) : maxAutomaticTokenAssociations;
    return this;
  }
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
    if (this._proxyAccountId != null) {
      this._proxyAccountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.updateAccount(request);
  }
  _getTransactionDataCase() {
    return "cryptoUpdateAccount";
  }
  _makeTransactionData() {
    return {
      accountIDToUpdate: this._accountId != null ? this._accountId._toProtobuf() : null,
      key: this._key != null ? this._key._toProtobufKey() : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      receiverSigRequiredWrapper: this._receiverSignatureRequired == null ? null : {
        value: this._receiverSignatureRequired
      },
      memo: this._accountMemo != null ? {
        value: this._accountMemo
      } : null,
      maxAutomaticTokenAssociations: this._maxAutomaticTokenAssociations != null ? { value: this._maxAutomaticTokenAssociations.toInt() } : null
    };
  }
};
TRANSACTION_REGISTRY.set("cryptoUpdateAccount", AccountUpdateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/contract/ContractByteCodeQuery.js
var ContractByteCodeQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._contractId = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  static _fromProtobuf(query) {
    const bytecode = query.contractGetBytecode;
    return new ContractByteCodeQuery({
      contractId: bytecode.contractID != null ? ContractId._fromProtobuf(bytecode.contractID) : void 0
    });
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.smartContract.contractGetBytecode(request);
  }
  _mapResponseHeader(response) {
    const contractGetBytecodeResponse = response.contractGetBytecodeResponse;
    return contractGetBytecodeResponse.header;
  }
  _mapResponse(response) {
    const contractGetBytecodeResponse = response.contractGetBytecodeResponse;
    return Promise.resolve(contractGetBytecodeResponse.bytecode != null ? contractGetBytecodeResponse.bytecode : new Uint8Array());
  }
  _onMakeRequest(header) {
    return {
      contractGetBytecode: {
        header,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("contractGetBytecode", ContractByteCodeQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/cryptography/keccak.js
var KECCAK_PADDING2 = [1, 256, 65536, 16777216];
var SHIFT2 = [0, 8, 16, 24];
var RC2 = [
  1,
  0,
  32898,
  0,
  32906,
  2147483648,
  2147516416,
  2147483648,
  32907,
  0,
  2147483649,
  0,
  2147516545,
  2147483648,
  32777,
  2147483648,
  138,
  0,
  136,
  0,
  2147516425,
  0,
  2147483658,
  0,
  2147516555,
  0,
  139,
  2147483648,
  32905,
  2147483648,
  32771,
  2147483648,
  32770,
  2147483648,
  128,
  2147483648,
  32778,
  0,
  2147483658,
  2147483648,
  2147516545,
  2147483648,
  32896,
  2147483648,
  2147483649,
  0,
  2147516424,
  2147483648
];
function createKeccakState2(bits) {
  return {
    blocks: [],
    reset: true,
    block: 0,
    start: 0,
    lastByteIndex: null,
    blockCount: 1600 - (bits << 1) >> 5,
    outputBlocks: bits >> 5,
    s: zeroFill2(50)
  };
}
function zeroFill2(n) {
  let arr = Array(n);
  for (let i = 0; i < n; ++i)
    arr[i] = 0;
  return arr;
}
function update2(state, message) {
  var length = message.length, blocks = state.blocks, byteCount = state.blockCount << 2, blockCount = state.blockCount, outputBlocks = state.outputBlocks, s = state.s, index = 0, i = 0, code;
  while (index < length) {
    if (state.reset) {
      state.reset = false;
      blocks[0] = state.block;
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    for (i = state.start; index < length && i < byteCount; ++index) {
      code = typeof message === "string" ? message.charCodeAt(index) : message[index];
      if (code < 128) {
        blocks[i >> 2] |= code << SHIFT2[i++ & 3];
      } else if (code < 2048) {
        blocks[i >> 2] |= (192 | code >> 6) << SHIFT2[i++ & 3];
        blocks[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
      } else if (code < 55296 || code >= 57344) {
        blocks[i >> 2] |= (224 | code >> 12) << SHIFT2[i++ & 3];
        blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i++ & 3];
        blocks[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
      } else {
        code = 65536 + ((code & 1023) << 10 | (typeof message === "string" ? message.charCodeAt(++index) : message[++index]) & 1023);
        blocks[i >> 2] |= (240 | code >> 18) << SHIFT2[i++ & 3];
        blocks[i >> 2] |= (128 | code >> 12 & 63) << SHIFT2[i++ & 3];
        blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i++ & 3];
        blocks[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
      }
    }
    state.lastByteIndex = i;
    if (i >= byteCount) {
      state.start = i - byteCount;
      state.block = blocks[blockCount];
      for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
      }
      f2(s);
      state.reset = true;
    } else {
      state.start = i;
    }
  }
  i = state.lastByteIndex;
  blocks[i >> 2] |= KECCAK_PADDING2[i & 3];
  if (state.lastByteIndex === byteCount) {
    blocks[0] = blocks[blockCount];
    for (i = 1; i < blockCount + 1; ++i) {
      blocks[i] = 0;
    }
  }
  blocks[blockCount - 1] |= 2147483648;
  for (i = 0; i < blockCount; ++i) {
    s[i] ^= blocks[i];
  }
  f2(s);
  const buffer = new ArrayBuffer(outputBlocks * 4);
  const view = new DataView(buffer);
  i = 0;
  var j = 0;
  while (j < outputBlocks) {
    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
      view.setInt32(i * 4, s[i], true);
    }
    if (j % blockCount === 0) {
      f2(s);
      i = 0;
    }
  }
  return new Uint8Array(buffer);
}
function f2(s) {
  var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
  for (n = 0; n < 48; n += 2) {
    c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
    c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
    c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
    c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
    c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
    c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
    c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
    c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
    c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
    c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
    h = c8 ^ (c2 << 1 | c3 >>> 31);
    l = c9 ^ (c3 << 1 | c2 >>> 31);
    s[0] ^= h;
    s[1] ^= l;
    s[10] ^= h;
    s[11] ^= l;
    s[20] ^= h;
    s[21] ^= l;
    s[30] ^= h;
    s[31] ^= l;
    s[40] ^= h;
    s[41] ^= l;
    h = c0 ^ (c4 << 1 | c5 >>> 31);
    l = c1 ^ (c5 << 1 | c4 >>> 31);
    s[2] ^= h;
    s[3] ^= l;
    s[12] ^= h;
    s[13] ^= l;
    s[22] ^= h;
    s[23] ^= l;
    s[32] ^= h;
    s[33] ^= l;
    s[42] ^= h;
    s[43] ^= l;
    h = c2 ^ (c6 << 1 | c7 >>> 31);
    l = c3 ^ (c7 << 1 | c6 >>> 31);
    s[4] ^= h;
    s[5] ^= l;
    s[14] ^= h;
    s[15] ^= l;
    s[24] ^= h;
    s[25] ^= l;
    s[34] ^= h;
    s[35] ^= l;
    s[44] ^= h;
    s[45] ^= l;
    h = c4 ^ (c8 << 1 | c9 >>> 31);
    l = c5 ^ (c9 << 1 | c8 >>> 31);
    s[6] ^= h;
    s[7] ^= l;
    s[16] ^= h;
    s[17] ^= l;
    s[26] ^= h;
    s[27] ^= l;
    s[36] ^= h;
    s[37] ^= l;
    s[46] ^= h;
    s[47] ^= l;
    h = c6 ^ (c0 << 1 | c1 >>> 31);
    l = c7 ^ (c1 << 1 | c0 >>> 31);
    s[8] ^= h;
    s[9] ^= l;
    s[18] ^= h;
    s[19] ^= l;
    s[28] ^= h;
    s[29] ^= l;
    s[38] ^= h;
    s[39] ^= l;
    s[48] ^= h;
    s[49] ^= l;
    b0 = s[0];
    b1 = s[1];
    b32 = s[11] << 4 | s[10] >>> 28;
    b33 = s[10] << 4 | s[11] >>> 28;
    b14 = s[20] << 3 | s[21] >>> 29;
    b15 = s[21] << 3 | s[20] >>> 29;
    b46 = s[31] << 9 | s[30] >>> 23;
    b47 = s[30] << 9 | s[31] >>> 23;
    b28 = s[40] << 18 | s[41] >>> 14;
    b29 = s[41] << 18 | s[40] >>> 14;
    b20 = s[2] << 1 | s[3] >>> 31;
    b21 = s[3] << 1 | s[2] >>> 31;
    b2 = s[13] << 12 | s[12] >>> 20;
    b3 = s[12] << 12 | s[13] >>> 20;
    b34 = s[22] << 10 | s[23] >>> 22;
    b35 = s[23] << 10 | s[22] >>> 22;
    b16 = s[33] << 13 | s[32] >>> 19;
    b17 = s[32] << 13 | s[33] >>> 19;
    b48 = s[42] << 2 | s[43] >>> 30;
    b49 = s[43] << 2 | s[42] >>> 30;
    b40 = s[5] << 30 | s[4] >>> 2;
    b41 = s[4] << 30 | s[5] >>> 2;
    b22 = s[14] << 6 | s[15] >>> 26;
    b23 = s[15] << 6 | s[14] >>> 26;
    b4 = s[25] << 11 | s[24] >>> 21;
    b5 = s[24] << 11 | s[25] >>> 21;
    b36 = s[34] << 15 | s[35] >>> 17;
    b37 = s[35] << 15 | s[34] >>> 17;
    b18 = s[45] << 29 | s[44] >>> 3;
    b19 = s[44] << 29 | s[45] >>> 3;
    b10 = s[6] << 28 | s[7] >>> 4;
    b11 = s[7] << 28 | s[6] >>> 4;
    b42 = s[17] << 23 | s[16] >>> 9;
    b43 = s[16] << 23 | s[17] >>> 9;
    b24 = s[26] << 25 | s[27] >>> 7;
    b25 = s[27] << 25 | s[26] >>> 7;
    b6 = s[36] << 21 | s[37] >>> 11;
    b7 = s[37] << 21 | s[36] >>> 11;
    b38 = s[47] << 24 | s[46] >>> 8;
    b39 = s[46] << 24 | s[47] >>> 8;
    b30 = s[8] << 27 | s[9] >>> 5;
    b31 = s[9] << 27 | s[8] >>> 5;
    b12 = s[18] << 20 | s[19] >>> 12;
    b13 = s[19] << 20 | s[18] >>> 12;
    b44 = s[29] << 7 | s[28] >>> 25;
    b45 = s[28] << 7 | s[29] >>> 25;
    b26 = s[38] << 8 | s[39] >>> 24;
    b27 = s[39] << 8 | s[38] >>> 24;
    b8 = s[48] << 14 | s[49] >>> 18;
    b9 = s[49] << 14 | s[48] >>> 18;
    s[0] = b0 ^ ~b2 & b4;
    s[1] = b1 ^ ~b3 & b5;
    s[10] = b10 ^ ~b12 & b14;
    s[11] = b11 ^ ~b13 & b15;
    s[20] = b20 ^ ~b22 & b24;
    s[21] = b21 ^ ~b23 & b25;
    s[30] = b30 ^ ~b32 & b34;
    s[31] = b31 ^ ~b33 & b35;
    s[40] = b40 ^ ~b42 & b44;
    s[41] = b41 ^ ~b43 & b45;
    s[2] = b2 ^ ~b4 & b6;
    s[3] = b3 ^ ~b5 & b7;
    s[12] = b12 ^ ~b14 & b16;
    s[13] = b13 ^ ~b15 & b17;
    s[22] = b22 ^ ~b24 & b26;
    s[23] = b23 ^ ~b25 & b27;
    s[32] = b32 ^ ~b34 & b36;
    s[33] = b33 ^ ~b35 & b37;
    s[42] = b42 ^ ~b44 & b46;
    s[43] = b43 ^ ~b45 & b47;
    s[4] = b4 ^ ~b6 & b8;
    s[5] = b5 ^ ~b7 & b9;
    s[14] = b14 ^ ~b16 & b18;
    s[15] = b15 ^ ~b17 & b19;
    s[24] = b24 ^ ~b26 & b28;
    s[25] = b25 ^ ~b27 & b29;
    s[34] = b34 ^ ~b36 & b38;
    s[35] = b35 ^ ~b37 & b39;
    s[44] = b44 ^ ~b46 & b48;
    s[45] = b45 ^ ~b47 & b49;
    s[6] = b6 ^ ~b8 & b0;
    s[7] = b7 ^ ~b9 & b1;
    s[16] = b16 ^ ~b18 & b10;
    s[17] = b17 ^ ~b19 & b11;
    s[26] = b26 ^ ~b28 & b20;
    s[27] = b27 ^ ~b29 & b21;
    s[36] = b36 ^ ~b38 & b30;
    s[37] = b37 ^ ~b39 & b31;
    s[46] = b46 ^ ~b48 & b40;
    s[47] = b47 ^ ~b49 & b41;
    s[8] = b8 ^ ~b0 & b2;
    s[9] = b9 ^ ~b1 & b3;
    s[18] = b18 ^ ~b10 & b12;
    s[19] = b19 ^ ~b11 & b13;
    s[28] = b28 ^ ~b20 & b22;
    s[29] = b29 ^ ~b21 & b23;
    s[38] = b38 ^ ~b30 & b32;
    s[39] = b39 ^ ~b31 & b33;
    s[48] = b48 ^ ~b40 & b42;
    s[49] = b49 ^ ~b41 & b43;
    s[0] ^= RC2[n];
    s[1] ^= RC2[n + 1];
  }
}
function createKeccak2(bits) {
  return function(message) {
    return update2(createKeccakState2(bits), message);
  };
}
var keccak2562 = createKeccak2(256);

// node_modules/@hashgraph/sdk/src/contract/ContractFunctionSelector.js
var ArgumentType = {
  uint8: 0,
  int8: 1,
  uint16: 2,
  int16: 3,
  uint32: 4,
  int32: 5,
  uint64: 6,
  int64: 7,
  uint256: 8,
  int256: 9,
  string: 10,
  bool: 11,
  bytes: 12,
  bytes32: 13,
  address: 14,
  func: 15
};
var ContractFunctionSelector = class {
  constructor(name) {
    this.name = null;
    this._params = "";
    this._paramTypes = [];
    if (name != null) {
      this._name = name;
    }
  }
  addString() {
    return this._addParam({ ty: ArgumentType.string, array: false });
  }
  addStringArray() {
    return this._addParam({ ty: ArgumentType.string, array: true });
  }
  addBytes() {
    return this._addParam({ ty: ArgumentType.bytes, array: false });
  }
  addBytes32() {
    return this._addParam({ ty: ArgumentType.bytes32, array: false });
  }
  addBytesArray() {
    return this._addParam({ ty: ArgumentType.bytes, array: true });
  }
  addBytes32Array() {
    return this._addParam({ ty: ArgumentType.bytes32, array: true });
  }
  addInt8() {
    return this._addParam({ ty: ArgumentType.int8, array: false });
  }
  addInt32() {
    return this._addParam({ ty: ArgumentType.int32, array: false });
  }
  addInt64() {
    return this._addParam({ ty: ArgumentType.int64, array: false });
  }
  addInt256() {
    return this._addParam({ ty: ArgumentType.int256, array: false });
  }
  addInt8Array() {
    return this._addParam({ ty: ArgumentType.int8, array: true });
  }
  addInt32Array() {
    return this._addParam({ ty: ArgumentType.int32, array: true });
  }
  addInt64Array() {
    return this._addParam({ ty: ArgumentType.int64, array: true });
  }
  addInt256Array() {
    return this._addParam({ ty: ArgumentType.int256, array: true });
  }
  addUint8() {
    return this._addParam({ ty: ArgumentType.uint8, array: false });
  }
  addUint32() {
    return this._addParam({ ty: ArgumentType.uint32, array: false });
  }
  addUint64() {
    return this._addParam({ ty: ArgumentType.uint64, array: false });
  }
  addUint256() {
    return this._addParam({ ty: ArgumentType.uint256, array: false });
  }
  addUint8Array() {
    return this._addParam({ ty: ArgumentType.uint8, array: true });
  }
  addUint32Array() {
    return this._addParam({ ty: ArgumentType.uint32, array: true });
  }
  addUint64Array() {
    return this._addParam({ ty: ArgumentType.uint64, array: true });
  }
  addUint256Array() {
    return this._addParam({ ty: ArgumentType.uint256, array: true });
  }
  addBool() {
    return this._addParam({ ty: ArgumentType.bool, array: false });
  }
  addAddress() {
    return this._addParam({ ty: ArgumentType.address, array: false });
  }
  addAddressArray() {
    return this._addParam({ ty: ArgumentType.address, array: true });
  }
  addFunction() {
    return this._addParam({ ty: ArgumentType.func, array: false });
  }
  _addParam(ty) {
    if (this._paramTypes.length > 0) {
      this._params += ",";
    }
    this._params += solidityTypeToString(ty);
    this._paramTypes.push(ty);
    return this;
  }
  _build(name) {
    if (name != null) {
      this._name = name;
    } else if (this._name == null) {
      throw new Error("`name` required for ContractFunctionSelector");
    }
    return new Uint8Array(keccak2562(this.toString()).slice(0, 4));
  }
  toString() {
    return `${this._name != null ? this._name.toString() : ""}(${this._params})`;
  }
};
function solidityTypeToString(ty) {
  let s = "";
  switch (ty.ty) {
    case ArgumentType.uint8:
      s = "uint8";
      break;
    case ArgumentType.int8:
      s = "int8";
      break;
    case ArgumentType.uint16:
      s = "uint16";
      break;
    case ArgumentType.int16:
      s = "int16";
      break;
    case ArgumentType.uint32:
      s = "uint32";
      break;
    case ArgumentType.int32:
      s = "int32";
      break;
    case ArgumentType.uint64:
      s = "uint64";
      break;
    case ArgumentType.int64:
      s = "int64";
      break;
    case ArgumentType.uint256:
      s = "uint256";
      break;
    case ArgumentType.int256:
      s = "int256";
      break;
    case ArgumentType.string:
      s = "string";
      break;
    case ArgumentType.bool:
      s = "bool";
      break;
    case ArgumentType.bytes:
      s = "bytes";
      break;
    case ArgumentType.bytes32:
      s = "bytes32";
      break;
    case ArgumentType.address:
      s = "address";
      break;
    case ArgumentType.func:
      s = "function";
      break;
    default:
      s = "";
      break;
  }
  if (ty.array) {
    s += "[]";
  }
  return s;
}

// node_modules/@hashgraph/sdk/src/contract/ContractFunctionParameters.js
var ContractFunctionParameters = class {
  constructor() {
    this._selector = new ContractFunctionSelector();
    this._arguments = [];
  }
  addString(value) {
    this._selector.addString();
    return this._addParam(value, true);
  }
  addStringArray(value) {
    this._selector.addStringArray();
    return this._addParam(value, true);
  }
  addBytes(value) {
    this._selector.addBytes();
    return this._addParam(value, true);
  }
  addBytes32(value) {
    if (value.length !== 32) {
      throw new Error(`addBytes32 expected array to be of length 32, but received ${value.length}`);
    }
    this._selector.addBytes32();
    return this._addParam(value, false);
  }
  addBytesArray(value) {
    this._selector.addBytesArray();
    return this._addParam(value, true);
  }
  addBytes32Array(value) {
    for (const [_, entry] of value.entries()) {
      if (entry.length !== 32) {
        throw new Error(`addBytes32 expected array to be of length 32, but received ${entry.length}`);
      }
    }
    this._selector.addBytes32Array();
    return this._addParam(value, true);
  }
  addBool(value) {
    this._selector.addBool();
    return this._addParam(value, false);
  }
  addInt8(value) {
    this._selector.addInt8();
    return this._addParam(convertToBigNumber(value), false);
  }
  addInt32(value) {
    this._selector.addInt32();
    return this._addParam(convertToBigNumber(value), false);
  }
  addInt64(value) {
    this._selector.addInt64();
    return this._addParam(convertToBigNumber(value), false);
  }
  addInt256(value) {
    this._selector.addInt256();
    return this._addParam(convertToBigNumber(value), false);
  }
  addInt8Array(value) {
    this._selector.addInt8Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  addInt32Array(value) {
    this._selector.addInt32Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  addInt64Array(value) {
    this._selector.addInt64Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  addInt256Array(value) {
    this._selector.addInt256Array();
    console.log("asdf");
    return this._addParam(convertToBigNumberArray(value), true);
  }
  addUint8(value) {
    this._selector.addUint8();
    return this._addParam(convertToBigNumber(value), false);
  }
  addUint32(value) {
    this._selector.addUint32();
    return this._addParam(convertToBigNumber(value), false);
  }
  addUint64(value) {
    this._selector.addUint64();
    return this._addParam(convertToBigNumber(value), false);
  }
  addUint256(value) {
    this._selector.addUint256();
    return this._addParam(convertToBigNumber(value), false);
  }
  addUint8Array(value) {
    this._selector.addUint8Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  addUint32Array(value) {
    this._selector.addUint32Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  addUint64Array(value) {
    this._selector.addUint64Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  addUint256Array(value) {
    this._selector.addUint256Array();
    return this._addParam(convertToBigNumberArray(value), true);
  }
  addAddress(value) {
    if (value.length !== 40 && value.length !== 42) {
      throw new Error("`address` type requires parameter to be 40 or 42 characters");
    }
    const par = value.length === 40 ? decode5(value) : decode5(value.substring(2));
    this._selector.addAddress();
    return this._addParam(par, false);
  }
  addAddressArray(value) {
    const par = [];
    for (const [_, entry] of value.entries()) {
      if (entry.length !== 40 && entry.length !== 42) {
        throw new Error("`address` type requires parameter to be 40 or 42 characters");
      }
      const buf = entry.length === 40 ? decode5(entry) : decode5(entry.substring(2));
      par.push(buf);
    }
    this._selector.addAddressArray();
    return this._addParam(par, true);
  }
  addFunction(address, selector) {
    const addressParam = decode5(address);
    const functionSelector = selector._build();
    if (addressParam.length !== 20) {
      throw new Error("`function` type requires parameter `address` to be exactly 20 bytes");
    }
    this._selector.addFunction();
    const proto19 = new Uint8Array(24);
    proto19.set(addressParam, 0);
    proto19.set(functionSelector, 20);
    return this._addParam(proto19, false);
  }
  _addParam(param, dynamic) {
    const index = this._selector._paramTypes.length - 1;
    const value = argumentToBytes(param, this._selector._paramTypes[index]);
    this._arguments.push({ dynamic, value });
    return this;
  }
  _build(name) {
    const includeId = name != null;
    const nameOffset = includeId ? 4 : 0;
    const length = this._arguments.length === 0 ? nameOffset : this._arguments.length * 32 + this._arguments.map((arg) => arg.dynamic ? arg.value.length : 0).reduce((sum, value) => sum + value) + nameOffset;
    const func = new Uint8Array(length);
    if (includeId) {
      func.set(this._selector._build(name), 0);
    }
    let offset = 32 * this._arguments.length;
    for (const [i, { dynamic, value }] of this._arguments.entries()) {
      if (dynamic) {
        const view = safeView(func, nameOffset + i * 32 + 28);
        view.setUint32(0, offset);
        func.set(value, view.getUint32(0) + nameOffset);
        offset += value.length;
      } else {
        func.set(value, nameOffset + i * 32);
      }
    }
    return func;
  }
};
function argumentToBytes(param, ty) {
  let value = new Uint8Array(32);
  let valueView = safeView(value);
  let par;
  if (ty.array) {
    if (!Array.isArray(param)) {
      throw new TypeError("SolidityType indicates type is array, but parameter is not an array");
    }
    const values = [];
    for (const [_, p] of param.entries()) {
      const arg = argumentToBytes(p, { ty: ty.ty, array: false });
      values.push(arg);
    }
    const totalLengthOfValues = values.map((a) => a.length).reduce((total, current) => total + current);
    switch (ty.ty) {
      case ArgumentType.uint8:
      case ArgumentType.int8:
      case ArgumentType.uint16:
      case ArgumentType.int16:
      case ArgumentType.uint32:
      case ArgumentType.int32:
      case ArgumentType.uint64:
      case ArgumentType.int64:
      case ArgumentType.uint256:
      case ArgumentType.int256:
      case ArgumentType.bool:
      case ArgumentType.bytes32:
      case ArgumentType.address:
      case ArgumentType.func:
        value = new Uint8Array(totalLengthOfValues + 32);
        break;
      case ArgumentType.bytes:
      case ArgumentType.string:
        value = new Uint8Array(values.length * 32 + totalLengthOfValues + 32);
        break;
      default:
        throw new TypeError(`Expected param type to be ArgumentType, but received ${ty.ty}`);
    }
    valueView = safeView(value, 28);
    valueView.setUint32(0, values.length);
    let offset = 32 * values.length;
    for (const [i, e] of values.entries()) {
      switch (ty.ty) {
        case ArgumentType.uint8:
        case ArgumentType.int8:
        case ArgumentType.uint16:
        case ArgumentType.int16:
        case ArgumentType.uint32:
        case ArgumentType.int32:
        case ArgumentType.uint64:
        case ArgumentType.int64:
        case ArgumentType.uint256:
        case ArgumentType.int256:
        case ArgumentType.bool:
        case ArgumentType.bytes32:
        case ArgumentType.address:
        case ArgumentType.func:
          value.set(e, i * 32 + 32);
          break;
        case ArgumentType.bytes:
        case ArgumentType.string:
          const view = safeView(value, (i + 1) * 32 + 28);
          view.setUint32(0, offset);
          value.set(e, view.getUint32(0) + 32);
          offset += e.length;
          break;
        default:
          throw new TypeError(`Expected param type to be ArgumentType, but received ${ty.ty}`);
      }
    }
    return value;
  }
  switch (ty.ty) {
    case ArgumentType.uint8:
      numberToBytes(param, 31, valueView.setUint8.bind(valueView));
      return value;
    case ArgumentType.int8:
      numberToBytes(param, 31, valueView.setInt8.bind(valueView));
      return value;
    case ArgumentType.uint16:
      numberToBytes(param, 30, valueView.setUint16.bind(valueView));
      return value;
    case ArgumentType.int16:
      numberToBytes(param, 30, valueView.setInt16.bind(valueView));
      return value;
    case ArgumentType.uint32:
      numberToBytes(param, 28, valueView.setUint32.bind(valueView));
      return value;
    case ArgumentType.int32:
      numberToBytes(param, 28, valueView.setInt32.bind(valueView));
      return value;
    case ArgumentType.uint64:
    case ArgumentType.int64:
      if (bignumber_default.isBigNumber(param)) {
        let par2 = param.toString(16);
        if (par2.length > 16) {
          throw new TypeError("uint64/int64 requires BigNumber to be less than or equal to 8 bytes");
        } else if (!param.isInteger()) {
          throw new TypeError("uint64/int64 requires BigNumber to be an integer");
        }
        if (par2.length % 2 === 1) {
          par2 = `0${par2}`;
        }
        const buf = decode5(par2);
        value.set(buf, 32 - buf.length);
      }
      return value;
    case ArgumentType.int256:
    case ArgumentType.uint256:
      if (bignumber_default.isBigNumber(param)) {
        let par2 = param.toString(16);
        if (par2.length % 2 === 1) {
          par2 = `0${par2}`;
        }
        const buf = decode5(par2);
        value.set(buf, 32 - buf.length);
      }
      return value;
    case ArgumentType.address:
      value.set(param, 32 - 20);
      return value;
    case ArgumentType.bool:
      value[31] = param ? 1 : 0;
      return value;
    case ArgumentType.func:
      value.set(param, 32 - 24);
      return value;
    case ArgumentType.bytes32:
      value.set(param, 0);
      return value;
    case ArgumentType.bytes:
    case ArgumentType.string:
      par = param instanceof Uint8Array ? param : encode4(param);
      if (Math.floor(par.length / 32) >= 0 && Math.floor(par.length % 32) !== 0) {
        value = new Uint8Array((Math.floor(par.length / 32) + 1) * 32 + 32);
      } else {
        value = new Uint8Array(64);
      }
      value.set(par, 32);
      valueView = safeView(value, 28);
      valueView.setUint32(0, par.length);
      return value;
    default:
      throw new Error(`Unsupported argument type: ${ty.toString()}`);
  }
}
function numberToBytes(param, byteoffset, func) {
  const value = bignumber_default.isBigNumber(param) ? param.toNumber() : param;
  func(byteoffset, value);
}

// node_modules/@hashgraph/sdk/src/contract/ContractCallQuery.js
var import_long20 = __toModule(require_long());
var ContractCallQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._contractId = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
    this._gas = null;
    if (props.gas != null) {
      this.setGas(props.gas);
    }
    this._functionParameters = null;
    if (props.functionParameters != null) {
      if (props.functionParameters instanceof Uint8Array) {
        this.setFunctionParameters(props.functionParameters);
      } else {
        this.setFunction(props.functionParameters.name, props.functionParameters.parameters);
      }
    }
    this._maxResultSize = null;
    if (props.maxResultSize != null) {
      this.setMaxResultSize(props.maxResultSize);
    }
  }
  static _fromProtobuf(query) {
    const call = query.contractCallLocal;
    return new ContractCallQuery({
      contractId: call.contractID != null ? ContractId._fromProtobuf(call.contractID) : void 0,
      gas: call.gas != null ? call.gas : void 0,
      functionParameters: call.functionParameters != null ? call.functionParameters : void 0,
      maxResultSize: call.maxResultSize != null ? call.maxResultSize : void 0
    });
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  get gas() {
    return this._gas;
  }
  setGas(gas) {
    this._gas = gas instanceof import_long20.default ? gas : import_long20.default.fromValue(gas);
    return this;
  }
  get functionParameters() {
    return this._functionParameters;
  }
  setFunctionParameters(params) {
    this._functionParameters = params;
    return this;
  }
  setFunction(name, params) {
    this._functionParameters = (params != null ? params : new ContractFunctionParameters())._build(name);
    return this;
  }
  setMaxResultSize(size) {
    this._maxResultSize = size instanceof import_long20.default ? size : import_long20.default.fromValue(size);
    return this;
  }
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.smartContract.contractCallLocalMethod(request);
  }
  _mapResponseHeader(response) {
    const contractCallLocal = response.contractCallLocal;
    return contractCallLocal.header;
  }
  _mapResponse(response) {
    const call = response.contractCallLocal;
    return Promise.resolve(ContractFunctionResult._fromProtobuf(call.functionResult));
  }
  _onMakeRequest(header) {
    return {
      contractCallLocal: {
        header,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
        gas: this._gas,
        maxResultSize: this._maxResultSize,
        functionParameters: this._functionParameters
      }
    };
  }
};
QUERY_REGISTRY.set("contractCallLocal", ContractCallQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/contract/ContractCreateTransaction.js
var import_long21 = __toModule(require_long());
var ContractCreateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._bytecodeFileId = null;
    this._adminKey = null;
    this._gas = null;
    this._initialBalance = null;
    this._proxyAccountId = null;
    this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);
    this._constructorParameters = null;
    this._contractMemo = null;
    this.setMaxTransactionFee(new Hbar(20));
    if (props.bytecodeFileId != null) {
      this.setBytecodeFileId(props.bytecodeFileId);
    }
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.gas != null) {
      this.setGas(props.gas);
    }
    if (props.initialBalance != null) {
      this.setInitialBalance(props.initialBalance);
    }
    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.constructorParameters != null) {
      this.setConstructorParameters(props.constructorParameters);
    }
    if (props.contractMemo != null) {
      this.setContractMemo(props.contractMemo);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = body.contractCreateInstance;
    return Transaction._fromProtobufTransactions(new ContractCreateTransaction({
      bytecodeFileId: create.fileID != null ? FileId._fromProtobuf(create.fileID) : void 0,
      adminKey: create.adminKey != null ? Key2._fromProtobufKey(create.adminKey) : void 0,
      gas: create.gas != null ? create.gas : void 0,
      initialBalance: create.initialBalance != null ? create.initialBalance : void 0,
      proxyAccountId: create.proxyAccountID != null ? AccountId._fromProtobuf(create.proxyAccountID) : void 0,
      autoRenewPeriod: create.autoRenewPeriod != null ? create.autoRenewPeriod.seconds != null ? create.autoRenewPeriod.seconds : void 0 : void 0,
      constructorParameters: create.constructorParameters != null ? create.constructorParameters : void 0,
      contractMemo: create.memo != null ? create.memo : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get bytecodeFileId() {
    return this._bytecodeFileId;
  }
  setBytecodeFileId(bytecodeFileId) {
    this._requireNotFrozen();
    this._bytecodeFileId = typeof bytecodeFileId === "string" ? FileId.fromString(bytecodeFileId) : bytecodeFileId.clone();
    return this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(adminKey) {
    this._requireNotFrozen();
    this._adminKey = adminKey;
    return this;
  }
  get gas() {
    return this._gas;
  }
  setGas(gas) {
    this._requireNotFrozen();
    this._gas = gas instanceof import_long21.default ? gas : import_long21.default.fromValue(gas);
    return this;
  }
  get initialBalance() {
    return this._initialBalance;
  }
  setInitialBalance(initialBalance) {
    this._requireNotFrozen();
    this._initialBalance = initialBalance instanceof Hbar ? initialBalance : new Hbar(initialBalance);
    return this;
  }
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();
    this._proxyAccountId = proxyAccountId instanceof AccountId ? proxyAccountId : AccountId.fromString(proxyAccountId);
    return this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration ? autoRenewPeriod : new Duration(autoRenewPeriod);
    return this;
  }
  get constructorParameters() {
    return this._constructorParameters;
  }
  setConstructorParameters(constructorParameters) {
    this._requireNotFrozen();
    this._constructorParameters = constructorParameters instanceof ContractFunctionParameters ? constructorParameters._build() : constructorParameters;
    return this;
  }
  get contractMemo() {
    return this._contractMemo;
  }
  setContractMemo(contractMemo) {
    this._requireNotFrozen();
    this._contractMemo = contractMemo;
    return this;
  }
  _validateChecksums(client) {
    if (this._bytecodeFileId != null) {
      this._bytecodeFileId.validateChecksum(client);
    }
    if (this._proxyAccountId != null) {
      this._proxyAccountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.smartContract.createContract(request);
  }
  _getTransactionDataCase() {
    return "contractCreateInstance";
  }
  _makeTransactionData() {
    return {
      fileID: this._bytecodeFileId != null ? this._bytecodeFileId._toProtobuf() : null,
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      gas: this._gas,
      initialBalance: this._initialBalance != null ? this._initialBalance.toTinybars() : null,
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
      constructorParameters: this._constructorParameters,
      memo: this._contractMemo
    };
  }
};
TRANSACTION_REGISTRY.set("contractCreateInstance", ContractCreateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/contract/ContractDeleteTransaction.js
var ContractDeleteTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._contractId = null;
    this._transferAccountId = null;
    this._transferContractId = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
    if (props.transferAccountId != null) {
      this.setTransferAccountId(props.transferAccountId);
    }
    if (props.transferContractId != null) {
      this.setTransferContractId(props.transferContractId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const contractDelete = body.contractDeleteInstance;
    return Transaction._fromProtobufTransactions(new ContractDeleteTransaction({
      contractId: contractDelete.contractID != null ? ContractId._fromProtobuf(contractDelete.contractID) : void 0,
      transferAccountId: contractDelete.transferAccountID != null ? AccountId._fromProtobuf(contractDelete.transferAccountID) : void 0,
      transferContractId: contractDelete.transferContractID != null ? ContractId._fromProtobuf(contractDelete.transferContractID) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(contractId) {
    this._requireNotFrozen();
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  get transferContractId() {
    return this._transferContractId;
  }
  setTransferContractId(transferContractId) {
    this._requireNotFrozen();
    this._transferContractId = transferContractId instanceof ContractId ? transferContractId : ContractId.fromString(transferContractId);
    return this;
  }
  get transferAccountId() {
    return this._transferAccountId;
  }
  setTransferAccountId(transferAccountId) {
    this._requireNotFrozen();
    this._transferAccountId = transferAccountId instanceof AccountId ? transferAccountId : AccountId.fromString(transferAccountId);
    return this;
  }
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
    if (this._transferAccountId != null) {
      this._transferAccountId.validateChecksum(client);
    }
    if (this._transferContractId != null) {
      this._transferContractId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.smartContract.deleteContract(request);
  }
  _getTransactionDataCase() {
    return "contractDeleteInstance";
  }
  _makeTransactionData() {
    return {
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      transferAccountID: this._transferAccountId ? this._transferAccountId._toProtobuf() : null,
      transferContractID: this._transferContractId != null ? this._transferContractId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("contractDeleteInstance", ContractDeleteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/contract/ContractExecuteTransaction.js
var import_long22 = __toModule(require_long());
var ContractExecuteTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._contractId = null;
    this._gas = null;
    this._amount = null;
    this._functionParameters = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
    if (props.gas != null) {
      this.setGas(props.gas);
    }
    if (props.amount != null) {
      this.setPayableAmount(props.amount);
    }
    if (props.functionParameters != null) {
      this.setFunctionParameters(props.functionParameters);
    } else if (props.function != null) {
      this.setFunction(props.function.name, props.function.parameters);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const call = body.contractCall;
    return Transaction._fromProtobufTransactions(new ContractExecuteTransaction({
      contractId: call.contractID != null ? ContractId._fromProtobuf(call.contractID) : void 0,
      gas: call.gas != null ? call.gas : void 0,
      amount: call.amount ? call.amount : void 0,
      functionParameters: call.functionParameters != null ? call.functionParameters : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(contractId) {
    this._requireNotFrozen();
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  get gas() {
    return this._gas;
  }
  setGas(gas) {
    this._requireNotFrozen();
    this._gas = gas instanceof import_long22.default ? gas : import_long22.default.fromValue(gas);
    return this;
  }
  get payableAmount() {
    return this._amount;
  }
  setPayableAmount(amount) {
    this._requireNotFrozen();
    this._amount = amount instanceof Hbar ? amount : new Hbar(amount);
    return this;
  }
  get functionParameters() {
    return this._functionParameters;
  }
  setFunctionParameters(functionParameters) {
    this._requireNotFrozen();
    this._functionParameters = functionParameters;
    return this;
  }
  setFunction(name, functionParameters) {
    this._requireNotFrozen();
    this._functionParameters = functionParameters != null ? functionParameters._build(name) : new ContractFunctionParameters()._build(name);
    return this;
  }
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.smartContract.contractCallMethod(request);
  }
  _getTransactionDataCase() {
    return "contractCall";
  }
  _makeTransactionData() {
    return {
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      gas: this._gas,
      amount: this._amount != null ? this._amount.toTinybars() : null,
      functionParameters: this._functionParameters
    };
  }
};
TRANSACTION_REGISTRY.set("contractCall", ContractExecuteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/contract/ContractInfo.js
var import_long23 = __toModule(require_long());
var proto10 = __toModule(require_lib());
var ContractInfo = class {
  constructor(props) {
    this.contractId = props.contractId;
    this.accountId = props.accountId;
    this.contractAccountId = props.contractAccountId;
    this.adminKey = props.adminKey != null ? props.adminKey : null;
    this.expirationTime = props.expirationTime;
    this.autoRenewPeriod = props.autoRenewPeriod;
    this.storage = props.storage;
    this.contractMemo = props.contractMemo;
    this.balance = props.balance;
    this.isDeleted = props.isDeleted;
    this.tokenRelationships = props.tokenRelationships;
    Object.freeze(this);
  }
  static _fromProtobuf(info) {
    const autoRenewPeriod = info.autoRenewPeriod.seconds;
    return new ContractInfo({
      contractId: ContractId._fromProtobuf(info.contractID),
      accountId: AccountId._fromProtobuf(info.accountID),
      contractAccountId: info.contractAccountID != null ? info.contractAccountID : "",
      adminKey: info.adminKey != null ? Key2._fromProtobufKey(info.adminKey) : null,
      expirationTime: Timestamp._fromProtobuf(info.expirationTime),
      autoRenewPeriod: new Duration(autoRenewPeriod),
      storage: info.storage != null ? info.storage instanceof import_long23.default ? info.storage : import_long23.default.fromValue(info.storage) : import_long23.default.ZERO,
      contractMemo: info.memo != null ? info.memo : "",
      balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),
      isDeleted: info.deleted,
      tokenRelationships: TokenRelationshipMap._fromProtobuf(info.tokenRelationships != null ? info.tokenRelationships : [])
    });
  }
  _toProtobuf() {
    return {
      contractID: this.contractId._toProtobuf(),
      accountID: this.accountId._toProtobuf(),
      contractAccountID: this.contractAccountId,
      adminKey: this.adminKey != null ? this.adminKey._toProtobufKey() : null,
      expirationTime: this.expirationTime._toProtobuf(),
      autoRenewPeriod: this.autoRenewPeriod != null ? this.autoRenewPeriod._toProtobuf() : null,
      storage: this.storage,
      memo: this.contractMemo,
      balance: this.balance.toTinybars(),
      deleted: this.isDeleted,
      tokenRelationships: this.tokenRelationships != null ? this.tokenRelationships._toProtobuf() : null
    };
  }
  static fromBytes(bytes2) {
    return ContractInfo._fromProtobuf(proto10.ContractGetInfoResponse.ContractInfo.decode(bytes2));
  }
  toBytes() {
    return proto10.ContractGetInfoResponse.ContractInfo.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/src/contract/ContractInfoQuery.js
var ContractInfoQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._contractId = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  static _fromProtobuf(query) {
    const info = query.contractGetInfo;
    return new ContractInfoQuery({
      contractId: info.contractID != null ? ContractId._fromProtobuf(info.contractID) : void 0
    });
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.smartContract.getContractInfo(request);
  }
  async getCost(client) {
    let cost = await super.getCost(client);
    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return Hbar.fromTinybars(25);
    }
  }
  _mapResponseHeader(response) {
    const contractGetInfo = response.contractGetInfo;
    return contractGetInfo.header;
  }
  _mapResponse(response, nodeAccountId, request) {
    const info = response.contractGetInfo;
    return Promise.resolve(ContractInfo._fromProtobuf(info.contractInfo));
  }
  _onMakeRequest(header) {
    return {
      contractGetInfo: {
        header,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("contractGetInfo", ContractInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/contract/ContractUpdateTransaction.js
var ContractUpdateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._contractId = null;
    this._expirationTime = null;
    this._adminKey = null;
    this._proxyAccountId = null;
    this._autoRenewPeriod = null;
    this._bytecodeFileId = null;
    this._contractMemo = null;
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.bytecodeFileId != null) {
      this.setBytecodeFileId(props.bytecodeFileId);
    }
    if (props.contractMemo != null) {
      this.setContractMemo(props.contractMemo);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update3 = body.contractUpdateInstance;
    let autoRenewPeriod = void 0;
    if (update3.autoRenewPeriod != null && update3.autoRenewPeriod.seconds != null) {
      autoRenewPeriod = update3.autoRenewPeriod.seconds;
    }
    let contractMemo = void 0;
    if (update3.memoWrapper != null && update3.memoWrapper.value != null) {
      contractMemo = update3.memoWrapper.value;
    }
    return Transaction._fromProtobufTransactions(new ContractUpdateTransaction({
      contractId: update3.contractID != null ? ContractId._fromProtobuf(update3.contractID) : void 0,
      bytecodeFileId: update3.fileID != null ? FileId._fromProtobuf(update3.fileID) : void 0,
      expirationTime: update3.expirationTime != null ? Timestamp._fromProtobuf(update3.expirationTime) : void 0,
      adminKey: update3.adminKey != null ? Key2._fromProtobufKey(update3.adminKey) : void 0,
      proxyAccountId: update3.proxyAccountID != null ? AccountId._fromProtobuf(update3.proxyAccountID) : void 0,
      autoRenewPeriod,
      contractMemo
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(contractId) {
    this._requireNotFrozen();
    this._contractId = typeof contractId === "string" ? ContractId.fromString(contractId) : contractId.clone();
    return this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(expirationTime) {
    this._requireNotFrozen();
    this._expirationTime = expirationTime instanceof Timestamp ? expirationTime : Timestamp.fromDate(expirationTime);
    return this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(adminKey) {
    this._requireNotFrozen();
    this._adminKey = adminKey;
    return this;
  }
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();
    this._proxyAccountId = typeof proxyAccountId === "string" ? AccountId.fromString(proxyAccountId) : proxyAccountId.clone();
    return this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration ? autoRenewPeriod : new Duration(autoRenewPeriod);
    return this;
  }
  get bytecodeFileId() {
    return this._bytecodeFileId;
  }
  setBytecodeFileId(bytecodeFileId) {
    console.warn("Deprecated: there is no replacement");
    this._requireNotFrozen();
    this._bytecodeFileId = typeof bytecodeFileId === "string" ? FileId.fromString(bytecodeFileId) : bytecodeFileId.clone();
    return this;
  }
  get contractMemo() {
    return this._contractMemo;
  }
  setContractMemo(contractMemo) {
    this._requireNotFrozen();
    this._contractMemo = contractMemo;
    return this;
  }
  clearContractMemo() {
    this._requireNotFrozen();
    this._contractMemo = null;
    return this;
  }
  _validateChecksums(client) {
    if (this._contractId != null) {
      this._contractId.validateChecksum(client);
    }
    if (this._bytecodeFileId != null) {
      this._bytecodeFileId.validateChecksum(client);
    }
    if (this._proxyAccountId != null) {
      this._proxyAccountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.smartContract.updateContract(request);
  }
  _getTransactionDataCase() {
    return "contractUpdateInstance";
  }
  _makeTransactionData() {
    return {
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      fileID: this._bytecodeFileId ? this._bytecodeFileId._toProtobuf() : null,
      memoWrapper: this._contractMemo != null ? {
        value: this._contractMemo
      } : null
    };
  }
};
TRANSACTION_REGISTRY.set("contractUpdateInstance", ContractUpdateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/file/FileAppendTransaction.js
var FileAppendTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._fileId = null;
    this._contents = null;
    this._maxChunks = 20;
    this.setMaxTransactionFee(new Hbar(5));
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
    if (props.contents != null) {
      this.setContents(props.contents);
    }
    if (props.maxChunks != null) {
      this.setMaxChunks(props.maxChunks);
    }
    this._startIndex = 0;
    this._transactionIds = [];
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const append = body.fileAppend;
    let contents;
    for (let i = 0; i < bodies.length; i += nodeIds.length) {
      const fileAppend = bodies[i].fileAppend;
      if (fileAppend.contents == null) {
        break;
      }
      if (contents == null) {
        contents = new Uint8Array(fileAppend.contents);
        continue;
      }
      const concat = new Uint8Array(contents.length + fileAppend.contents.length);
      concat.set(contents, 0);
      concat.set(fileAppend.contents, contents.length);
      contents = concat;
    }
    return Transaction._fromProtobufTransactions(new FileAppendTransaction({
      fileId: append.fileID != null ? FileId._fromProtobuf(append.fileID) : void 0,
      contents
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  setTransactionId(transactionId) {
    this._requireNotFrozen();
    if (transactionId.accountId == null || transactionId.validStart == null) {
      throw new Error("`FileAppendTransaction` does not support `TransactionId` built from `nonce`");
    }
    this._transactionIds = [transactionId];
    return this;
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = typeof fileId === "string" ? FileId.fromString(fileId) : fileId.clone();
    return this;
  }
  get contents() {
    return this._contents;
  }
  setContents(contents) {
    this._requireNotFrozen();
    this._contents = contents instanceof Uint8Array ? contents : encode4(contents);
    return this;
  }
  get maxChunks() {
    return this._maxChunks;
  }
  setMaxChunks(maxChunks) {
    this._requireNotFrozen();
    this._maxChunks = maxChunks;
    return this;
  }
  freezeWith(client) {
    super.freezeWith(client);
    if (this._contents == null) {
      return this;
    }
    const chunks = Math.floor((this._contents.length + (CHUNK_SIZE - 1)) / CHUNK_SIZE);
    if (chunks > this._maxChunks) {
      throw new Error(`Contents with size ${this._contents.length} too long for ${this._maxChunks} chunks`);
    }
    let nextTransactionId = this.transactionId;
    super._transactions = [];
    super._transactionIds = [];
    super._signedTransactions = [];
    super._nextTransactionIndex = 0;
    for (let chunk = 0; chunk < chunks; chunk++) {
      this._startIndex = chunk * CHUNK_SIZE;
      this._transactionIds.push(nextTransactionId);
      for (const nodeAccountId of this._nodeIds) {
        this._signedTransactions.push(this._makeSignedTransaction(nodeAccountId));
      }
      nextTransactionId = new TransactionId(nextTransactionId.accountId, new Timestamp(nextTransactionId.validStart.seconds, nextTransactionId.validStart.nanos.add(1)));
      super._nextTransactionIndex = this._nextTransactionIndex + 1;
    }
    this._startIndex = 0;
    super._nextTransactionIndex = 0;
    return this;
  }
  schedule() {
    this._requireNotFrozen();
    if (this._contents != null && this._contents.length > CHUNK_SIZE) {
      throw new Error(`cannot scheduled \`FileAppendTransaction\` with message over ${CHUNK_SIZE} bytes`);
    }
    return super.schedule();
  }
  async execute(client) {
    return (await this.executeAll(client))[0];
  }
  async executeAll(client) {
    if (!super._isFrozen()) {
      this.freezeWith(client);
    }
    const transactionId = this.transactionId;
    const operatorAccountId = client.operatorAccountId;
    if (operatorAccountId != null && operatorAccountId.equals(transactionId.accountId)) {
      await super.signWithOperator(client);
    }
    const responses = [];
    for (let i = 0; i < this._transactionIds.length; i++) {
      const response = await super.execute(client);
      await response.getReceipt(client);
      responses.push(response);
    }
    return responses;
  }
  _validateChecksums(client) {
    if (this._fileId != null) {
      this._fileId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.file.appendContent(request);
  }
  _getTransactionDataCase() {
    return "fileAppend";
  }
  _makeTransactionData() {
    const length = this._contents != null ? this._contents.length : 0;
    let endIndex = this._startIndex + CHUNK_SIZE;
    if (endIndex > length) {
      endIndex = length;
    }
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      contents: this._contents != null ? this._contents.slice(this._startIndex, endIndex) : null
    };
  }
};
TRANSACTION_REGISTRY.set("fileAppend", FileAppendTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/file/FileContentsQuery.js
var FileContentsQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._fileId = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
  }
  static _fromProtobuf(query) {
    const contents = query.fileGetContents;
    return new FileContentsQuery({
      fileId: contents.fileID != null ? FileId._fromProtobuf(contents.fileID) : void 0
    });
  }
  _validateChecksums(client) {
    if (this._fileId != null) {
      this._fileId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.file.getFileContent(request);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(fileId) {
    this._fileId = typeof fileId === "string" ? FileId.fromString(fileId) : fileId.clone();
    return this;
  }
  _mapResponseHeader(response) {
    const fileGetContents = response.fileGetContents;
    return fileGetContents.header;
  }
  _mapResponse(response) {
    const fileContentsResponse = response.fileGetContents;
    const fileConents = fileContentsResponse.fileContents;
    const contents = fileConents.contents;
    return Promise.resolve(contents);
  }
  _onMakeRequest(header) {
    return {
      fileGetContents: {
        header,
        fileID: this._fileId != null ? this._fileId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("fileGetContents", FileContentsQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/file/FileCreateTransaction.js
var FileCreateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._keys = null;
    this._expirationTime = Timestamp.fromDate(Date.now() + DEFAULT_AUTO_RENEW_PERIOD.toInt() * 1e3);
    this._contents = null;
    this._fileMemo = null;
    this.setMaxTransactionFee(new Hbar(5));
    if (props.keys != null) {
      this.setKeys(props.keys);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.contents != null) {
      this.setContents(props.contents);
    }
    if (props.fileMemo != null) {
      this.setFileMemo(props.fileMemo);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = body.fileCreate;
    return Transaction._fromProtobufTransactions(new FileCreateTransaction({
      keys: create.keys != null ? create.keys.keys != null ? create.keys.keys.map((key) => Key2._fromProtobufKey(key)) : void 0 : void 0,
      expirationTime: create.expirationTime != null ? Timestamp._fromProtobuf(create.expirationTime) : void 0,
      contents: create.contents != null ? create.contents : void 0,
      fileMemo: create.memo != null ? create.memo : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get keys() {
    return this._keys;
  }
  setKeys(keys) {
    this._requireNotFrozen();
    if (keys instanceof KeyList2 && keys.threshold != null) {
      throw new Error("Cannot set threshold key as file key");
    }
    this._keys = keys instanceof KeyList2 ? keys.toArray() : keys;
    return this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(expirationTime) {
    this._requireNotFrozen();
    this._expirationTime = expirationTime instanceof Timestamp ? expirationTime : Timestamp.fromDate(expirationTime);
    return this;
  }
  get contents() {
    return this._contents;
  }
  setContents(contents) {
    this._requireNotFrozen();
    this._contents = contents instanceof Uint8Array ? contents : encode4(contents);
    return this;
  }
  get fileMemo() {
    return this._fileMemo;
  }
  setFileMemo(memo) {
    this._requireNotFrozen();
    this._fileMemo = memo;
    return this;
  }
  _execute(channel, request) {
    return channel.file.createFile(request);
  }
  _getTransactionDataCase() {
    return "fileCreate";
  }
  _makeTransactionData() {
    return {
      keys: this._keys != null ? {
        keys: this._keys.map((key) => key._toProtobufKey())
      } : null,
      expirationTime: this._expirationTime._toProtobuf(),
      contents: this._contents,
      memo: this._fileMemo
    };
  }
};
TRANSACTION_REGISTRY.set("fileCreate", FileCreateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/file/FileDeleteTransaction.js
var FileDeleteTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._fileId = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const fileDelete = body.fileDelete;
    return Transaction._fromProtobufTransactions(new FileDeleteTransaction({
      fileId: fileDelete.fileID != null ? FileId._fromProtobuf(fileDelete.fileID) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = typeof fileId === "string" ? FileId.fromString(fileId) : fileId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._fileId != null) {
      this._fileId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.file.deleteFile(request);
  }
  _getTransactionDataCase() {
    return "fileDelete";
  }
  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("fileDelete", FileDeleteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/file/FileInfo.js
var import_long24 = __toModule(require_long());
var proto11 = __toModule(require_lib());
var FileInfo = class {
  constructor(props) {
    this.fileId = props.fileId;
    this.size = props.size;
    this.expirationTime = props.expirationTime;
    this.isDeleted = props.isDeleted;
    this.keys = props.keys;
    this.fileMemo = props.fileMemo;
    Object.freeze(this);
  }
  static _fromProtobuf(info) {
    const size = info.size;
    return new FileInfo({
      fileId: FileId._fromProtobuf(info.fileID),
      size: size instanceof import_long24.default ? size : import_long24.default.fromValue(size),
      expirationTime: Timestamp._fromProtobuf(info.expirationTime),
      isDeleted: info.deleted,
      keys: info.keys != null ? KeyList2.__fromProtobufKeyList(info.keys) : new KeyList2(),
      fileMemo: info.memo != null ? info.memo : ""
    });
  }
  _toProtobuf() {
    return {
      fileID: this.fileId._toProtobuf(),
      size: this.size,
      expirationTime: this.expirationTime._toProtobuf(),
      deleted: this.isDeleted,
      keys: this.keys._toProtobufKey().keyList,
      memo: this.fileMemo
    };
  }
  static fromBytes(bytes2) {
    return FileInfo._fromProtobuf(proto11.FileGetInfoResponse.FileInfo.decode(bytes2));
  }
  toBytes() {
    return proto11.FileGetInfoResponse.FileInfo.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/src/file/FileInfoQuery.js
var FileInfoQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._fileId = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
  }
  static _fromProtobuf(query) {
    const info = query.fileGetInfo;
    return new FileInfoQuery({
      fileId: info.fileID != null ? FileId._fromProtobuf(info.fileID) : void 0
    });
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(fileId) {
    this._fileId = typeof fileId === "string" ? FileId.fromString(fileId) : fileId.clone();
    return this;
  }
  async getCost(client) {
    let cost = await super.getCost(client);
    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return Hbar.fromTinybars(25);
    }
  }
  _validateChecksums(client) {
    if (this._fileId != null) {
      this._fileId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.file.getFileInfo(request);
  }
  _mapResponseHeader(response) {
    const fileGetInfo = response.fileGetInfo;
    return fileGetInfo.header;
  }
  _mapResponse(response, nodeAccountId, request) {
    const info = response.fileGetInfo;
    return Promise.resolve(FileInfo._fromProtobuf(info.fileInfo));
  }
  _onMakeRequest(header) {
    return {
      fileGetInfo: {
        header,
        fileID: this._fileId != null ? this._fileId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("fileGetInfo", FileInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/file/FileUpdateTransaction.js
var FileUpdateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._fileId = null;
    this._keys = null;
    this._expirationTime = null;
    this._contents = null;
    this._fileMemo = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
    if (props.keys != null) {
      this.setKeys(props.keys);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.contents != null) {
      this.setContents(props.contents);
    }
    if (props.fileMemo != null) {
      this.setFileMemo(props.fileMemo);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update3 = body.fileUpdate;
    return Transaction._fromProtobufTransactions(new FileUpdateTransaction({
      fileId: update3.fileID != null ? FileId._fromProtobuf(update3.fileID) : void 0,
      keys: update3.keys != null ? update3.keys.keys != null ? update3.keys.keys.map((key) => Key2._fromProtobufKey(key)) : void 0 : void 0,
      expirationTime: update3.expirationTime != null ? Timestamp._fromProtobuf(update3.expirationTime) : void 0,
      contents: update3.contents != null ? update3.contents : void 0,
      fileMemo: update3.memo != null ? update3.memo.value != null ? update3.memo.value : void 0 : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = typeof fileId === "string" ? FileId.fromString(fileId) : fileId.clone();
    return this;
  }
  get keys() {
    return this._keys;
  }
  setKeys(keys) {
    this._requireNotFrozen();
    if (keys instanceof KeyList2 && keys.threshold != null) {
      throw new Error("Cannot set threshold key as file key");
    }
    this._keys = keys instanceof KeyList2 ? keys.toArray() : keys;
    return this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(expirationTime) {
    this._requireNotFrozen();
    this._expirationTime = expirationTime instanceof Timestamp ? expirationTime : Timestamp.fromDate(expirationTime);
    return this;
  }
  get contents() {
    return this._contents;
  }
  setContents(contents) {
    this._requireNotFrozen();
    this._contents = contents instanceof Uint8Array ? contents : encode4(contents);
    return this;
  }
  get fileMemo() {
    return this._fileMemo;
  }
  setFileMemo(memo) {
    this._requireNotFrozen();
    this._fileMemo = memo;
    return this;
  }
  clearFileMemo() {
    this._requireNotFrozen();
    this._fileMemo = null;
    return this;
  }
  _validateChecksums(client) {
    if (this._fileId != null) {
      this._fileId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.file.updateFile(request);
  }
  _getTransactionDataCase() {
    return "fileUpdate";
  }
  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      keys: this._keys != null ? {
        keys: this._keys.map((key) => key._toProtobufKey())
      } : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      contents: this._contents,
      memo: this._fileMemo != null ? {
        value: this._fileMemo
      } : null
    };
  }
};
TRANSACTION_REGISTRY.set("fileUpdate", FileUpdateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/FreezeType.js
var FreezeType = class {
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  toString() {
    switch (this) {
      case FreezeType.UnknownFreezeType:
        return "UNKNOWN_FREEZE_TYPE";
      case FreezeType.FreezeOnly:
        return "FREEZE_ONLY";
      case FreezeType.PrepareUpgrade:
        return "PREPARE_UPGRADE";
      case FreezeType.FreezeUpgrade:
        return "FREEZE_UPGRADE";
      case FreezeType.FreezeAbort:
        return "FREEZE_ABORT";
      case FreezeType.TelemetryUpgrade:
        return "TELEMETRY_UPGRADE";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  static _fromCode(code) {
    switch (code) {
      case 0:
        return FreezeType.UnknownFreezeType;
      case 1:
        return FreezeType.FreezeOnly;
      case 2:
        return FreezeType.PrepareUpgrade;
      case 3:
        return FreezeType.FreezeUpgrade;
      case 4:
        return FreezeType.FreezeAbort;
      case 5:
        return FreezeType.TelemetryUpgrade;
      default:
        throw new Error(`(BUG) Status.fromCode() does not handle code: ${code}`);
    }
  }
  valueOf() {
    return this._code;
  }
};
FreezeType.UnknownFreezeType = new FreezeType(0);
FreezeType.FreezeOnly = new FreezeType(1);
FreezeType.PrepareUpgrade = new FreezeType(2);
FreezeType.FreezeUpgrade = new FreezeType(3);
FreezeType.FreezeAbort = new FreezeType(4);
FreezeType.TelemetryUpgrade = new FreezeType(5);

// node_modules/@hashgraph/sdk/src/system/FreezeTransaction.js
var FreezeTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._startTime = null;
    this._startTimestamp = null;
    this._endTime = null;
    this._fileId = null;
    this._fileHash = null;
    this._freezeType = null;
    if (props.startTime != null) {
      this.setStartTime(props.startTime.hour, props.startTime.minute);
    }
    if (props.endTime != null) {
      this.setEndTime(props.endTime.hour, props.endTime.minute);
    }
    if (props.startTimestamp != null) {
      this.setStartTimestamp(props.startTimestamp);
    }
    if (props.updateFileId != null) {
      this.setUpdateFileId(props.updateFileId);
    }
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
    if (props.fileHash != null) {
      this.setFileHash(props.fileHash);
    }
    if (props.freezeType != null) {
      this.setFreezeType(props.freezeType);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const freeze = body.freeze;
    return Transaction._fromProtobufTransactions(new FreezeTransaction({
      startTime: freeze.startHour != null && freeze.startMin != null ? {
        hour: freeze.startHour,
        minute: freeze.startMin
      } : void 0,
      endTime: freeze.endHour != null && freeze.endMin != null ? {
        hour: freeze.endHour,
        minute: freeze.endMin
      } : void 0,
      startTimestamp: freeze.startTime != null ? Timestamp._fromProtobuf(freeze.startTime) : void 0,
      updateFileId: freeze.updateFile != null ? FileId._fromProtobuf(freeze.updateFile) : void 0,
      fileHash: freeze.fileHash != null ? freeze.fileHash : void 0,
      freezeType: freeze.freezeType != null ? FreezeType._fromCode(freeze.freezeType) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get startTime() {
    return null;
  }
  setStartTime(startHourOrString, startMinute) {
    this._requireNotFrozen();
    if (typeof startHourOrString === "string") {
      const split = startHourOrString.split(":");
      this._startTime = {
        hour: Number(split[0]),
        minute: Number(split[1])
      };
    } else {
      this._startTime = {
        hour: startHourOrString,
        minute: startMinute
      };
    }
    return this;
  }
  get startTimestamp() {
    return this._startTimestamp;
  }
  setStartTimestamp(startTimestamp) {
    this._requireNotFrozen();
    this._startTimestamp = startTimestamp;
    return this;
  }
  get endTime() {
    console.warn("`FreezeTransaction.endTime` is deprecated");
    return this._endTime;
  }
  setEndTime(endHourOrString, endMinute) {
    console.warn("`FreezeTransaction.endTime` is deprecated");
    this._requireNotFrozen();
    if (typeof endHourOrString === "string") {
      const split = endHourOrString.split(":");
      this._endTime = {
        hour: Number(split[0]),
        minute: Number(split[1])
      };
    } else {
      this._endTime = {
        hour: endHourOrString,
        minute: endMinute
      };
    }
    return this;
  }
  get updateFileId() {
    return this.fileId;
  }
  setUpdateFileId(updateFileId) {
    return this.setFileId(updateFileId);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = fileId;
    return this;
  }
  get fileHash() {
    return this._fileHash;
  }
  setFileHash(fileHash) {
    this._requireNotFrozen();
    this._fileHash = typeof fileHash === "string" ? decode5(fileHash) : fileHash;
    return this;
  }
  get freezeType() {
    return this._freezeType;
  }
  setFreezeType(freezeType) {
    this._requireNotFrozen();
    this._freezeType = freezeType;
    return this;
  }
  _getTransactionDataCase() {
    return "freeze";
  }
  _makeTransactionData() {
    return {
      startTime: this._startTimestamp != null ? this._startTimestamp._toProtobuf() : null,
      updateFile: this._fileId != null ? this._fileId._toProtobuf() : null,
      fileHash: this._fileHash,
      freezeType: this._freezeType != null ? this._freezeType.valueOf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("freeze", FreezeTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/LiveHashAddTransaction.js
var LiveHashAddTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._hash = null;
    this._keys = null;
    this._duration = null;
    this._accountId = null;
    if (props.hash != null) {
      this.setHash(props.hash);
    }
    if (props.keys != null) {
      this.setKeys(props.keys);
    }
    if (props.duration != null) {
      this.setDuration(props.duration);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const hashes = body.cryptoAddLiveHash;
    const liveHash_ = hashes.liveHash;
    return Transaction._fromProtobufTransactions(new LiveHashAddTransaction({
      hash: liveHash_.hash != null ? liveHash_.hash : void 0,
      keys: liveHash_.keys != null ? liveHash_.keys.keys != null ? liveHash_.keys.keys.map((key) => Key2._fromProtobufKey(key)) : void 0 : void 0,
      duration: liveHash_.duration != null ? liveHash_.duration.seconds != null ? liveHash_.duration.seconds : void 0 : void 0,
      accountId: liveHash_.accountId != null ? AccountId._fromProtobuf(liveHash_.accountId) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get hash() {
    return this._hash;
  }
  setHash(hash2) {
    this._requireNotFrozen();
    this._hash = hash2;
    return this;
  }
  get keys() {
    return this._keys;
  }
  setKeys(keys) {
    this._requireNotFrozen();
    this._keys = keys instanceof KeyList2 ? keys.toArray() : keys;
    return this;
  }
  get duration() {
    return this._duration;
  }
  setDuration(duration) {
    this._requireNotFrozen();
    this._duration = duration instanceof Duration ? duration : new Duration(duration);
    return this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.addLiveHash(request);
  }
  _getTransactionDataCase() {
    return "cryptoAddLiveHash";
  }
  _makeTransactionData() {
    return {
      liveHash: {
        hash: this._hash,
        keys: this._keys != null ? {
          keys: this._keys.map((key) => key._toProtobufKey())
        } : void 0,
        duration: this._duration != null ? this._duration._toProtobuf() : null,
        accountId: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }
};
TRANSACTION_REGISTRY.set("cryptoAddLiveHash", LiveHashAddTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/LiveHashDeleteTransaction.js
var LiveHashDeleteTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._hash = null;
    this._accountId = null;
    if (props.hash != null) {
      this.setHash(props.hash);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const hashes = body.cryptoDeleteLiveHash;
    return Transaction._fromProtobufTransactions(new LiveHashDeleteTransaction({
      hash: hashes.liveHashToDelete != null ? hashes.liveHashToDelete : void 0,
      accountId: hashes.accountOfLiveHash != null ? AccountId._fromProtobuf(hashes.accountOfLiveHash) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get hash() {
    return this._hash;
  }
  setHash(hash2) {
    this._requireNotFrozen();
    this._hash = hash2;
    return this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.deleteLiveHash(request);
  }
  _getTransactionDataCase() {
    return "cryptoDeleteLiveHash";
  }
  _makeTransactionData() {
    return {
      liveHashToDelete: this._hash,
      accountOfLiveHash: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("cryptoDeleteLiveHash", LiveHashDeleteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/LiveHashQuery.js
var LiveHashQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._accountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    this._hash = null;
    if (props.hash != null) {
      this.setHash(props.hash);
    }
  }
  static _fromProtobuf(query) {
    const hash2 = query.cryptoGetLiveHash;
    return new LiveHashQuery({
      accountId: hash2.accountID != null ? AccountId._fromProtobuf(hash2.accountID) : void 0,
      hash: hash2.hash != null ? hash2.hash : void 0
    });
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._accountId = accountId instanceof AccountId ? accountId : AccountId.fromString(accountId);
    return this;
  }
  get liveHash() {
    return this._hash;
  }
  setHash(hash2) {
    this._hash = hash2;
    return this;
  }
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.crypto.getLiveHash(request);
  }
  _mapResponseHeader(response) {
    const cryptoGetLiveHash = response.cryptoGetLiveHash;
    return cryptoGetLiveHash.header;
  }
  _mapResponse(response) {
    const hashes = response.cryptoGetLiveHash;
    return Promise.resolve(LiveHash._fromProtobuf(hashes.liveHash));
  }
  _onMakeRequest(header) {
    return {
      cryptoGetLiveHash: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null,
        hash: this._hash
      }
    };
  }
};
QUERY_REGISTRY.set("cryptoGetLiveHash", LiveHashQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/NetworkName.js
var NetworkName = {
  Mainnet: "mainnet",
  Testnet: "testnet",
  Previewnet: "previewnet"
};
var _networkIds = ["0", "1", "2"];
function _ledgerIdToLedgerId(networkName) {
  switch (networkName) {
    case NetworkName.Mainnet:
      return _networkIds[0];
    case NetworkName.Testnet:
      return _networkIds[1];
    case NetworkName.Previewnet:
      return _networkIds[2];
    default:
      throw new Error(`unrecognized network name, expected "mainnet", "testnet", or "previewnet"`);
  }
}
function _ledgerIdToNetworkName(ledgerId) {
  switch (ledgerId) {
    case "0":
      return NetworkName.Mainnet;
    case "1":
      return NetworkName.Testnet;
    case "2":
      return NetworkName.Previewnet;
    default:
      throw new Error(`unrecognized ledgerId, expected "0", "1", or "2"`);
  }
}
var NetworkName_default = NetworkName;

// node_modules/@hashgraph/sdk/src/network/SemanticVersion.js
var proto12 = __toModule(require_lib());
var SemanticVersion2 = class {
  constructor(props) {
    this.major = props.major;
    this.minor = props.minor;
    this.patch = props.patch;
    Object.freeze(this);
  }
  static _fromProtobuf(version) {
    return new SemanticVersion2({
      major: version.major,
      minor: version.minor,
      patch: version.patch
    });
  }
  _toProtobuf() {
    return {
      major: this.major,
      minor: this.minor,
      patch: this.patch
    };
  }
  static fromBytes(bytes2) {
    return SemanticVersion2._fromProtobuf(proto12.SemanticVersion.decode(bytes2));
  }
  toBytes() {
    return proto12.SemanticVersion.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/src/network/NetworkVersionInfo.js
var proto13 = __toModule(require_lib());
var NetworkVersionInfo = class {
  constructor(props) {
    this.protobufVersion = props.protobufVersion;
    this.servicesVesion = props.servicesVesion;
    Object.freeze(this);
  }
  static _fromProtobuf(info) {
    return new NetworkVersionInfo({
      protobufVersion: SemanticVersion2._fromProtobuf(info.hapiProtoVersion),
      servicesVesion: SemanticVersion2._fromProtobuf(info.hederaServicesVersion)
    });
  }
  _toProtobuf() {
    return {
      hapiProtoVersion: this.protobufVersion._toProtobuf(),
      hederaServicesVersion: this.servicesVesion._toProtobuf()
    };
  }
  static fromBytes(bytes2) {
    return NetworkVersionInfo._fromProtobuf(proto13.NetworkGetVersionInfoResponse.decode(bytes2));
  }
  toBytes() {
    return proto13.NetworkGetVersionInfoResponse.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/src/network/NetworkVersionInfoQuery.js
var NetworkVersionInfoQuery = class extends Query {
  constructor() {
    super();
  }
  static _fromProtobuf(query) {
    return new NetworkVersionInfoQuery();
  }
  _execute(channel, request) {
    return channel.network.getVersionInfo(request);
  }
  _mapResponseHeader(response) {
    const networkGetVersionInfo = response.networkGetVersionInfo;
    return networkGetVersionInfo.header;
  }
  _mapResponse(response) {
    const info = response.networkGetVersionInfo;
    return Promise.resolve(NetworkVersionInfo._fromProtobuf(info));
  }
  _onMakeRequest(header) {
    return {
      networkGetVersionInfo: {
        header
      }
    };
  }
};
QUERY_REGISTRY.set("networkGetVersionInfo", NetworkVersionInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/schedule/ScheduleCreateTransaction.js
var ScheduleCreateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._adminKey = null;
    this._scheduledTransaction = null;
    this._payerAccountId = null;
    this._scheduleMemo = null;
    this._scheduledSignerPublicKeys = new Set();
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.payerAccountID != null) {
      this.setPayerAccountId(props.payerAccountID);
    }
    if (props.scheduleMemo != null) {
      this.setScheduleMemo(props.scheduleMemo);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = body.scheduleCreate;
    return Transaction._fromProtobufTransactions(new ScheduleCreateTransaction({
      adminKey: create.adminKey != null ? Key2._fromProtobufKey(create.adminKey) : void 0,
      payerAccountID: create.payerAccountID != null ? AccountId._fromProtobuf(create.payerAccountID) : void 0,
      scheduleMemo: create.memo != null ? create.memo : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  _setScheduledTransaction(tx) {
    this._scheduledTransaction = tx;
    return this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(key) {
    this._requireNotFrozen();
    this._adminKey = key;
    return this;
  }
  get payerAccountId() {
    return this._payerAccountId;
  }
  setPayerAccountId(account) {
    this._requireNotFrozen();
    this._payerAccountId = account;
    return this;
  }
  setScheduleMemo(memo) {
    this._requireNotFrozen();
    this._scheduleMemo = memo;
    return this;
  }
  get getScheduleMemo() {
    this._requireNotFrozen();
    return this._scheduleMemo;
  }
  setScheduledTransaction(transaction) {
    this._requireNotFrozen();
    transaction._requireNotFrozen();
    this._scheduledTransaction = transaction.schedule()._scheduledTransaction;
    return this;
  }
  _validateChecksums(client) {
    if (this._payerAccountId != null) {
      this._payerAccountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.schedule.createSchedule(request);
  }
  _getTransactionDataCase() {
    return "scheduleCreate";
  }
  _makeTransactionData() {
    return {
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      payerAccountID: this._payerAccountId != null ? this._payerAccountId._toProtobuf() : null,
      scheduledTransactionBody: this._scheduledTransaction != null ? this._scheduledTransaction._getScheduledTransactionBody() : null,
      memo: this._scheduleMemo
    };
  }
};
TRANSACTION_REGISTRY.set("scheduleCreate", ScheduleCreateTransaction._fromProtobuf);
SCHEDULE_CREATE_TRANSACTION.push(() => new ScheduleCreateTransaction());

// node_modules/@hashgraph/sdk/src/schedule/ScheduleDeleteTransaction.js
var ScheduleDeleteTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._scheduleId = null;
    if (props.scheduleId != null) {
      this.setScheduleId(props.scheduleId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const scheduleDelete = body.scheduleDelete;
    return Transaction._fromProtobufTransactions(new ScheduleDeleteTransaction({
      scheduleId: scheduleDelete.scheduleID != null ? ScheduleId._fromProtobuf(scheduleDelete.scheduleID) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get scheduleId() {
    return this._scheduleId;
  }
  setScheduleId(scheduleId) {
    this._requireNotFrozen();
    this._scheduleId = typeof scheduleId === "string" ? ScheduleId.fromString(scheduleId) : scheduleId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._scheduleId != null) {
      this._scheduleId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.schedule.deleteSchedule(request);
  }
  _getTransactionDataCase() {
    return "scheduleDelete";
  }
  _makeTransactionData() {
    return {
      scheduleID: this._scheduleId != null ? this._scheduleId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("scheduleDelete", ScheduleDeleteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/schedule/ScheduleInfo.js
var import_proto6 = __toModule(require_lib());
var ScheduleInfo = class {
  constructor(props) {
    this.scheduleId = props.scheduleId;
    this.creatorAccountId = props.creatorAccountID;
    this.payerAccountId = props.payerAccountID;
    this.schedulableTransactionBody = props.schedulableTransactionBody;
    this.signers = props.signers;
    this.scheduleMemo = props.scheduleMemo;
    this.adminKey = props.adminKey != null ? props.adminKey : null;
    this.expirationTime = props.expirationTime;
    this.executed = props.executed;
    this.deleted = props.deleted;
    this.scheduledTransactionId = props.scheduledTransactionId;
    Object.freeze(this);
  }
  static _fromProtobuf(info) {
    return new ScheduleInfo({
      scheduleId: ScheduleId._fromProtobuf(info.scheduleID),
      creatorAccountID: info.creatorAccountID != null ? AccountId._fromProtobuf(info.creatorAccountID) : null,
      payerAccountID: info.payerAccountID != null ? AccountId._fromProtobuf(info.payerAccountID) : null,
      schedulableTransactionBody: info.scheduledTransactionBody != null ? info.scheduledTransactionBody : null,
      adminKey: info.adminKey != null ? Key2._fromProtobufKey(info.adminKey) : null,
      signers: info.signers != null ? KeyList2.__fromProtobufKeyList(info.signers) : null,
      scheduleMemo: info.memo != null ? info.memo : null,
      expirationTime: info.expirationTime != null ? Timestamp._fromProtobuf(info.expirationTime) : null,
      executed: info.executionTime != null ? Timestamp._fromProtobuf(info.executionTime) : null,
      deleted: info.deletionTime != null ? Timestamp._fromProtobuf(info.deletionTime) : null,
      scheduledTransactionId: info.scheduledTransactionID != null ? TransactionId._fromProtobuf(info.scheduledTransactionID) : null
    });
  }
  _toProtobuf() {
    return {
      scheduleID: this.scheduleId != null ? this.scheduleId._toProtobuf() : null,
      creatorAccountID: this.creatorAccountId != null ? this.creatorAccountId._toProtobuf() : null,
      payerAccountID: this.payerAccountId != null ? this.payerAccountId._toProtobuf() : null,
      scheduledTransactionBody: this.schedulableTransactionBody != null ? this.schedulableTransactionBody : null,
      adminKey: this.adminKey != null ? this.adminKey._toProtobufKey() : null,
      signers: this.signers != null ? this.signers._toProtobufKey().keyList : null,
      memo: this.scheduleMemo != null ? this.scheduleMemo : "",
      expirationTime: this.expirationTime != null ? this.expirationTime._toProtobuf() : null,
      scheduledTransactionID: this.scheduledTransactionId != null ? this.scheduledTransactionId._toProtobuf() : null
    };
  }
  get scheduledTransaction() {
    if (this.schedulableTransactionBody == null) {
      throw new Error("Scheduled transaction body is empty");
    }
    const scheduled = new import_proto6.SchedulableTransactionBody(this.schedulableTransactionBody);
    const data = scheduled.data;
    return Transaction.fromBytes(import_proto6.TransactionList.encode({
      transactionList: [
        {
          signedTransactionBytes: import_proto6.SignedTransaction.encode({
            bodyBytes: import_proto6.TransactionBody.encode({
              transactionFee: this.schedulableTransactionBody.transactionFee,
              memo: this.schedulableTransactionBody.memo,
              [data]: scheduled[data]
            }).finish()
          }).finish()
        }
      ]
    }).finish());
  }
};

// node_modules/@hashgraph/sdk/src/schedule/ScheduleInfoQuery.js
var ScheduleInfoQuery = class extends Query {
  constructor(properties = {}) {
    super();
    this._scheduleId = null;
    if (properties.scheduleId != null) {
      this.setScheduleId(properties.scheduleId);
    }
  }
  static _fromProtobuf(query) {
    const info = query.scheduleGetInfo;
    return new ScheduleInfoQuery({
      scheduleId: info.scheduleID != null ? ScheduleId._fromProtobuf(info.scheduleID) : void 0
    });
  }
  get scheduleId() {
    return this._scheduleId;
  }
  setScheduleId(scheduleId) {
    this._scheduleId = typeof scheduleId === "string" ? ScheduleId.fromString(scheduleId) : scheduleId.clone();
    return this;
  }
  async getCost(client) {
    let cost = await super.getCost(client);
    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return Hbar.fromTinybars(25);
    }
  }
  _validateChecksums(client) {
    if (this._scheduleId != null) {
      this._scheduleId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.schedule.getScheduleInfo(request);
  }
  _mapResponseHeader(response) {
    const scheduleGetInfo = response.scheduleGetInfo;
    return scheduleGetInfo.header;
  }
  _mapResponse(response, nodeAccountId, request) {
    const info = response.scheduleGetInfo;
    return Promise.resolve(ScheduleInfo._fromProtobuf(info.scheduleInfo));
  }
  _onMakeRequest(header) {
    return {
      scheduleGetInfo: {
        header,
        scheduleID: this._scheduleId != null ? this._scheduleId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("scheduleGetInfo", ScheduleInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/schedule/ScheduleSignTransaction.js
var ScheduleSignTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._scheduleId = null;
    if (props.scheduleId != null) {
      this.setScheduleId(props.scheduleId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const sign2 = body.scheduleSign;
    return Transaction._fromProtobufTransactions(new ScheduleSignTransaction({
      scheduleId: sign2.scheduleID != null ? ScheduleId._fromProtobuf(sign2.scheduleID) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get scheduleId() {
    return this._scheduleId;
  }
  setScheduleId(scheduleId) {
    this._requireNotFrozen();
    this._scheduleId = typeof scheduleId === "string" ? ScheduleId.fromString(scheduleId) : scheduleId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._scheduleId != null) {
      this._scheduleId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.schedule.signSchedule(request);
  }
  _getTransactionDataCase() {
    return "scheduleSign";
  }
  _makeTransactionData() {
    return {
      scheduleID: this._scheduleId != null ? this._scheduleId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("scheduleSign", ScheduleSignTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/system/SystemDeleteTransaction.js
var SystemDeleteTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._fileId = null;
    this._contractId = null;
    this._expirationTime = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const systemDelete = body.systemDelete;
    return Transaction._fromProtobufTransactions(new SystemDeleteTransaction({
      fileId: systemDelete.fileID != null ? FileId._fromProtobuf(systemDelete.fileID) : void 0,
      contractId: systemDelete.contractID != null ? ContractId._fromProtobuf(systemDelete.contractID) : void 0,
      expirationTime: systemDelete.expirationTime != null ? Timestamp._fromProtobuf(systemDelete.expirationTime) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = fileId instanceof FileId ? fileId : FileId.fromString(fileId);
    return this;
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(contractId) {
    this._requireNotFrozen();
    this._contractId = contractId instanceof ContractId ? contractId : ContractId.fromString(contractId);
    return this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(expirationTime) {
    this._requireNotFrozen();
    this._expirationTime = expirationTime;
    return this;
  }
  _execute(channel, request) {
    if (this._fileId != null) {
      return channel.file.systemDelete(request);
    } else {
      return channel.smartContract.systemDelete(request);
    }
  }
  _getTransactionDataCase() {
    return "systemDelete";
  }
  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("systemDelete", SystemDeleteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/system/SystemUndeleteTransaction.js
var SystemUndeleteTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._fileId = null;
    this._contractId = null;
    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const systemUndelete = body.systemUndelete;
    return Transaction._fromProtobufTransactions(new SystemUndeleteTransaction({
      fileId: systemUndelete.fileID != null ? FileId._fromProtobuf(systemUndelete.fileID) : void 0,
      contractId: systemUndelete.contractID != null ? ContractId._fromProtobuf(systemUndelete.contractID) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(fileId) {
    this._requireNotFrozen();
    this._fileId = fileId instanceof FileId ? fileId : FileId.fromString(fileId);
    return this;
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(contractId) {
    this._requireNotFrozen();
    this._contractId = contractId instanceof ContractId ? contractId : ContractId.fromString(contractId);
    return this;
  }
  _execute(channel, request) {
    if (this._fileId != null) {
      return channel.file.systemUndelete(request);
    } else {
      return channel.smartContract.systemUndelete(request);
    }
  }
  _getTransactionDataCase() {
    return "systemUndelete";
  }
  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("systemUndelete", SystemUndeleteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/CustomFee.js
var CustomFee = class {
  constructor(props = {}) {
    this._feeCollectorAccountId;
    if (props.feeCollectorAccountId != null) {
      this.setFeeCollectorAccountId(props.feeCollectorAccountId);
    }
  }
  get feeCollectorAccountId() {
    return this._feeCollectorAccountId;
  }
  setFeeCollectorAccountId(feeCollectorAccountId) {
    this._feeCollectorAccountId = typeof feeCollectorAccountId === "string" ? AccountId.fromString(feeCollectorAccountId) : feeCollectorAccountId;
    return this;
  }
  static _fromProtobuf(info) {
    throw new Error("not implemented");
  }
  _toProtobuf() {
    throw new Error("not implemented");
  }
};

// node_modules/@hashgraph/sdk/src/token/CustomFixedFee.js
var import_long25 = __toModule(require_long());
var CustomFixedFee = class extends CustomFee {
  constructor(props = {}) {
    super(props);
    this._denominatingTokenId;
    if (props.denominatingTokenId != null) {
      this.setDenominatingTokenId(props.denominatingTokenId);
    }
    this._amount;
    if (props.amount != null) {
      this.setAmount(props.amount);
    }
  }
  setHbarAmount(amount) {
    this._amount = amount.toTinybars();
    this._denominatingTokenId = null;
    return this;
  }
  get hbarAmount() {
    return this._denominatingTokenId != null ? null : Hbar.fromTinybars(this._amount != null ? this._amount : 0);
  }
  setDenominatingTokenToSameToken() {
    this._denominatingTokenId = new TokenId(0, 0, 0);
    return this;
  }
  get denominatingTokenId() {
    return this._denominatingTokenId;
  }
  setDenominatingTokenId(denominatingTokenId) {
    this._denominatingTokenId = typeof denominatingTokenId === "string" ? TokenId.fromString(denominatingTokenId) : denominatingTokenId;
    return this;
  }
  get amount() {
    return this._amount;
  }
  setAmount(amount) {
    this._amount = typeof amount === "number" ? import_long25.default.fromNumber(amount) : amount;
    return this;
  }
  static _fromProtobuf(info) {
    const fee = info.fixedFee;
    return new CustomFixedFee({
      feeCollectorAccountId: info.feeCollectorAccountId != null ? AccountId._fromProtobuf(info.feeCollectorAccountId) : void 0,
      denominatingTokenId: fee.denominatingTokenId != null ? TokenId._fromProtobuf(fee.denominatingTokenId) : void 0,
      amount: fee.amount != null ? fee.amount : void 0
    });
  }
  _toProtobuf() {
    return {
      feeCollectorAccountId: this.feeCollectorAccountId != null ? this.feeCollectorAccountId._toProtobuf() : null,
      fixedFee: {
        denominatingTokenId: this._denominatingTokenId != null ? this._denominatingTokenId._toProtobuf() : null,
        amount: this._amount
      }
    };
  }
};

// node_modules/@hashgraph/sdk/src/token/CustomRoyaltyFee.js
var import_long26 = __toModule(require_long());
var CustomRoyalyFee = class extends CustomFee {
  constructor(props = {}) {
    super(props);
    this._fallbackFee;
    if (props.fallbackFee != null) {
      this.setFallbackFee(props.fallbackFee);
    }
    this._numerator;
    if (props.numerator != null) {
      this.setNumerator(props.numerator);
    }
    this._denominator;
    if (props.denominator != null) {
      this.setDenominator(props.denominator);
    }
  }
  get fallbackFee() {
    return this._fallbackFee;
  }
  setFallbackFee(fallbackFee) {
    this._fallbackFee = fallbackFee;
    return this;
  }
  get numerator() {
    return this._numerator;
  }
  setNumerator(numerator) {
    this._numerator = typeof numerator === "number" ? import_long26.default.fromNumber(numerator) : numerator;
    return this;
  }
  get denominator() {
    return this._denominator;
  }
  setDenominator(denominator) {
    this._denominator = typeof denominator === "number" ? import_long26.default.fromNumber(denominator) : denominator;
    return this;
  }
  static _fromProtobuf(info) {
    const fee = info.royaltyFee;
    const fraction = fee.exchangeValueFraction;
    return new CustomRoyalyFee({
      feeCollectorAccountId: info.feeCollectorAccountId != null ? AccountId._fromProtobuf(info.feeCollectorAccountId) : void 0,
      fallbackFee: fee.fallbackFee != null ? CustomFixedFee._fromProtobuf({
        fixedFee: fee.fallbackFee
      }) : void 0,
      numerator: fraction.numerator != null ? fraction.numerator : void 0,
      denominator: fraction.denominator != null ? fraction.denominator : void 0
    });
  }
  _toProtobuf() {
    return {
      feeCollectorAccountId: this.feeCollectorAccountId != null ? this.feeCollectorAccountId._toProtobuf() : null,
      royaltyFee: {
        exchangeValueFraction: {
          numerator: this._numerator,
          denominator: this._denominator
        },
        fallbackFee: this._fallbackFee != null ? this._fallbackFee._toProtobuf().fixedFee : null
      }
    };
  }
};

// node_modules/@hashgraph/sdk/src/token/CustomFractionalFee.js
var import_long27 = __toModule(require_long());
var CustomFractionalFee = class extends CustomFee {
  constructor(props = {}) {
    super(props);
    this._numerator;
    if (props.numerator != null) {
      this.setNumerator(props.numerator);
    }
    this._denominator;
    if (props.denominator != null) {
      this.setDenominator(props.denominator);
    }
    this._min;
    if (props.min != null) {
      this.setMin(props.min);
    }
    this._max;
    if (props.max != null) {
      this.setMax(props.max);
    }
    this._assessmentMethod;
    if (props.assessmentMethod != null) {
      this.setAssessmentMethod(props.assessmentMethod);
    }
  }
  get numerator() {
    return this._numerator;
  }
  setNumerator(numerator) {
    this._numerator = typeof numerator === "number" ? import_long27.default.fromNumber(numerator) : numerator;
    return this;
  }
  get denominator() {
    return this._denominator;
  }
  setDenominator(denominator) {
    this._denominator = typeof denominator === "number" ? import_long27.default.fromNumber(denominator) : denominator;
    return this;
  }
  get min() {
    return this._min;
  }
  setMin(min) {
    this._min = typeof min === "number" ? import_long27.default.fromNumber(min) : min;
    return this;
  }
  get max() {
    return this._max;
  }
  setMax(max) {
    this._max = typeof max === "number" ? import_long27.default.fromNumber(max) : max;
    return this;
  }
  get assessmentMethod() {
    return this._assessmentMethod;
  }
  setAssessmentMethod(assessmentMethod) {
    this._assessmentMethod = assessmentMethod;
    return this;
  }
  static _fromProtobuf(info) {
    const fee = info.fractionalFee;
    const fractional = fee.fractionalAmount;
    return new CustomFractionalFee({
      feeCollectorAccountId: info.feeCollectorAccountId != null ? AccountId._fromProtobuf(info.feeCollectorAccountId) : void 0,
      numerator: fractional.numerator != null ? fractional.numerator : void 0,
      denominator: fractional.denominator != null ? fractional.denominator : void 0,
      min: fee.minimumAmount != null ? fee.minimumAmount : void 0,
      max: fee.maximumAmount != null ? fee.maximumAmount : void 0
    });
  }
  _toProtobuf() {
    return {
      feeCollectorAccountId: this.feeCollectorAccountId != null ? this.feeCollectorAccountId._toProtobuf() : null,
      fractionalFee: {
        fractionalAmount: {
          numerator: this._numerator,
          denominator: this._denominator
        },
        minimumAmount: this._min,
        maximumAmount: this._max
      }
    };
  }
};

// node_modules/@hashgraph/sdk/src/token/NftId.js
var proto14 = __toModule(require_lib());
var import_long28 = __toModule(require_long());
var NftId = class {
  constructor(token, serial) {
    this.tokenId = token;
    this.serial = typeof serial === "number" ? import_long28.default.fromNumber(serial) : serial;
    Object.freeze(this);
  }
  static fromString(text) {
    const strings = text.split("/").length > 1 ? text.split("/") : text.split("@");
    for (const string of strings) {
      if (string === "") {
        throw new Error("invalid format for NftId: use [token]/[serial] or [token]@[serial]");
      }
    }
    const token = TokenId.fromString(strings[0]);
    const serial = import_long28.default.fromString(strings[1]);
    return new NftId(token, serial);
  }
  static _fromProtobuf(id) {
    return new NftId(TokenId._fromProtobuf(id.tokenID), id.serialNumber != null ? id.serialNumber : import_long28.default.ZERO);
  }
  static fromBytes(bytes2) {
    return NftId._fromProtobuf(proto14.NftID.decode(bytes2));
  }
  _toProtobuf() {
    return {
      tokenID: this.tokenId._toProtobuf(),
      serialNumber: import_long28.default.fromValue(this.serial !== void 0 ? this.serial : 0)
    };
  }
  toString() {
    return `${this.serial.toString()}@${this.tokenId.toString()}`;
  }
  toBytes() {
    return proto14.NftID.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/src/token/TokenAssociateTransaction.js
var TokenAssociateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenIds = null;
    this._accountId = null;
    this.setMaxTransactionFee(new Hbar(5));
    if (props.tokenIds != null) {
      this.setTokenIds(props.tokenIds);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const associateToken = body.tokenAssociate;
    return Transaction._fromProtobufTransactions(new TokenAssociateTransaction({
      tokenIds: associateToken.tokens != null ? associateToken.tokens.map((token) => TokenId._fromProtobuf(token)) : void 0,
      accountId: associateToken.account != null ? AccountId._fromProtobuf(associateToken.account) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenIds() {
    return this._tokenIds;
  }
  setTokenIds(tokenIds) {
    this._requireNotFrozen();
    this._tokenIds = tokenIds.map((tokenId) => typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone());
    return this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
    for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
      if (tokenId != null) {
        tokenId.validateChecksum(client);
      }
    }
  }
  _execute(channel, request) {
    return channel.token.associateTokens(request);
  }
  _getTransactionDataCase() {
    return "tokenAssociate";
  }
  _makeTransactionData() {
    return {
      tokens: this._tokenIds != null ? this._tokenIds.map((tokenId) => tokenId._toProtobuf()) : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("tokenAssociate", TokenAssociateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenBurnTransaction.js
var import_long29 = __toModule(require_long());
var TokenBurnTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._amount = null;
    this._serials = [];
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.amount != null) {
      this.setAmount(props.amount);
    }
    if (props.serials != null) {
      this.setSerials(props.serials);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const burnToken = body.tokenBurn;
    return Transaction._fromProtobufTransactions(new TokenBurnTransaction({
      tokenId: burnToken.token != null ? TokenId._fromProtobuf(burnToken.token) : void 0,
      amount: burnToken.amount != null ? burnToken.amount : void 0,
      serials: burnToken.serialNumbers != null ? burnToken.serialNumbers : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  get amount() {
    return this._amount;
  }
  setAmount(amount) {
    this._requireNotFrozen();
    this._amount = amount instanceof import_long29.default ? amount : import_long29.default.fromValue(amount);
    return this;
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  get serials() {
    return this._serials;
  }
  setSerials(serials) {
    this._requireNotFrozen();
    this._serials = serials.map((serial) => serial instanceof import_long29.default ? serial : import_long29.default.fromValue(serial));
    return this;
  }
  _execute(channel, request) {
    return channel.token.burnToken(request);
  }
  _getTransactionDataCase() {
    return "tokenBurn";
  }
  _makeTransactionData() {
    return {
      amount: this._amount,
      serialNumbers: this._serials,
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("tokenBurn", TokenBurnTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenCreateTransaction.js
var import_long30 = __toModule(require_long());

// node_modules/@hashgraph/sdk/src/token/TokenType.js
var TokenType = class {
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  toString() {
    switch (this) {
      case TokenType.FungibleCommon:
        return "FUNGIBLE_COMMON";
      case TokenType.NonFungibleUnique:
        return "NON_FUNGIBLE_UNIQUE";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  static _fromCode(code) {
    switch (code) {
      case 0:
        return TokenType.FungibleCommon;
      case 1:
        return TokenType.NonFungibleUnique;
    }
    throw new Error(`(BUG) TokenType.fromCode() does not handle code: ${code}`);
  }
  valueOf() {
    return this._code;
  }
};
TokenType.FungibleCommon = new TokenType(0);
TokenType.NonFungibleUnique = new TokenType(1);

// node_modules/@hashgraph/sdk/src/token/TokenSupplyType.js
var TokenSupplyType = class {
  constructor(code) {
    this._code = code;
    Object.freeze(this);
  }
  toString() {
    switch (this) {
      case TokenSupplyType.Infinite:
        return "INFINITE";
      case TokenSupplyType.Finite:
        return "FINITE";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  static _fromCode(code) {
    switch (code) {
      case 0:
        return TokenSupplyType.Infinite;
      case 1:
        return TokenSupplyType.Finite;
    }
    throw new Error(`(BUG) TokenSupplyType.fromCode() does not handle code: ${code}`);
  }
  valueOf() {
    return this._code;
  }
};
TokenSupplyType.Infinite = new TokenSupplyType(0);
TokenSupplyType.Finite = new TokenSupplyType(1);

// node_modules/@hashgraph/sdk/src/token/TokenCreateTransaction.js
var TokenCreateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenName = null;
    this._tokenSymbol = null;
    this._decimals = null;
    this._initialSupply = null;
    this._treasuryAccountId = null;
    this._adminKey = null;
    this._kycKey = null;
    this._freezeKey = null;
    this._pauseKey = null;
    this._wipeKey = null;
    this._supplyKey = null;
    this._feeScheduleKey = null;
    this._freezeDefault = null;
    this._autoRenewAccountId = null;
    this._expirationTime = null;
    this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);
    this._tokenMemo = null;
    this._customFees = [];
    this._tokenType = null;
    this._supplyType = null;
    this._maxSupply = null;
    this.setMaxTransactionFee(new Hbar(30));
    if (props.tokenName != null) {
      this.setTokenName(props.tokenName);
    }
    if (props.tokenSymbol != null) {
      this.setTokenSymbol(props.tokenSymbol);
    }
    if (props.decimals != null) {
      this.setDecimals(props.decimals);
    }
    if (props.initialSupply != null) {
      this.setInitialSupply(props.initialSupply);
    }
    if (props.treasuryAccountId != null) {
      this.setTreasuryAccountId(props.treasuryAccountId);
    }
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.kycKey != null) {
      this.setKycKey(props.kycKey);
    }
    if (props.freezeKey != null) {
      this.setFreezeKey(props.freezeKey);
    }
    if (props.pauseKey != null) {
      this.setPauseKey(props.pauseKey);
    }
    if (props.wipeKey != null) {
      this.setWipeKey(props.wipeKey);
    }
    if (props.supplyKey != null) {
      this.setSupplyKey(props.supplyKey);
    }
    if (props.feeScheduleKey != null) {
      this.setFeeScheduleKey(props.feeScheduleKey);
    }
    if (props.freezeDefault != null) {
      this.setFreezeDefault(props.freezeDefault);
    }
    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.tokenMemo != null) {
      this.setTokenMemo(props.tokenMemo);
    }
    if (props.customFees != null) {
      this.setCustomFees(props.customFees);
    }
    if (props.tokenType != null) {
      this.setTokenType(props.tokenType);
    }
    if (props.supplyType != null) {
      this.setSupplyType(props.supplyType);
    }
    if (props.maxSupply != null) {
      this.setMaxSupply(props.maxSupply);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = body.tokenCreation;
    return Transaction._fromProtobufTransactions(new TokenCreateTransaction({
      tokenName: create.name != null ? create.name : void 0,
      tokenSymbol: create.symbol != null ? create.symbol : void 0,
      decimals: create.decimals != null ? create.decimals : void 0,
      initialSupply: create.initialSupply != null ? create.initialSupply : void 0,
      treasuryAccountId: create.treasury != null ? AccountId._fromProtobuf(create.treasury) : void 0,
      adminKey: create.adminKey != null ? Key2._fromProtobufKey(create.adminKey) : void 0,
      kycKey: create.kycKey != null ? Key2._fromProtobufKey(create.kycKey) : void 0,
      freezeKey: create.freezeKey != null ? Key2._fromProtobufKey(create.freezeKey) : void 0,
      pauseKey: create.pauseKey != null ? Key2._fromProtobufKey(create.pauseKey) : void 0,
      wipeKey: create.wipeKey != null ? Key2._fromProtobufKey(create.wipeKey) : void 0,
      supplyKey: create.supplyKey != null ? Key2._fromProtobufKey(create.supplyKey) : void 0,
      feeScheduleKey: create.feeScheduleKey != null ? Key2._fromProtobufKey(create.feeScheduleKey) : void 0,
      freezeDefault: create.freezeDefault != null ? create.freezeDefault : void 0,
      autoRenewAccountId: create.autoRenewAccount != null ? AccountId._fromProtobuf(create.autoRenewAccount) : void 0,
      expirationTime: create.expiry != null ? Timestamp._fromProtobuf(create.expiry) : void 0,
      autoRenewPeriod: create.autoRenewPeriod != null ? Duration._fromProtobuf(create.autoRenewPeriod) : void 0,
      tokenMemo: create.memo != null ? create.memo : void 0,
      customFees: create.customFees != null ? create.customFees.map((fee) => {
        if (fee.fixedFee != null) {
          return CustomFixedFee._fromProtobuf(fee);
        } else if (fee.fractionalFee != null) {
          return CustomFractionalFee._fromProtobuf(fee);
        } else {
          return CustomRoyalyFee._fromProtobuf(fee);
        }
      }) : void 0,
      tokenType: create.tokenType != null ? TokenType._fromCode(create.tokenType) : void 0,
      supplyType: create.supplyType != null ? TokenSupplyType._fromCode(create.supplyType) : void 0,
      maxSupply: create.maxSupply != null ? create.maxSupply : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenName() {
    return this._tokenName;
  }
  setTokenName(name) {
    this._requireNotFrozen();
    this._tokenName = name;
    return this;
  }
  get tokenSymbol() {
    return this._tokenSymbol;
  }
  setTokenSymbol(symbol) {
    this._requireNotFrozen();
    this._tokenSymbol = symbol;
    return this;
  }
  get decimals() {
    return this._decimals;
  }
  setDecimals(decimals) {
    this._requireNotFrozen();
    this._decimals = decimals instanceof import_long30.default ? decimals : import_long30.default.fromValue(decimals);
    return this;
  }
  get initialSupply() {
    return this._initialSupply;
  }
  setInitialSupply(initialSupply) {
    this._requireNotFrozen();
    this._initialSupply = import_long30.default.fromValue(initialSupply);
    return this;
  }
  get treasuryAccountId() {
    return this._treasuryAccountId;
  }
  setTreasuryAccountId(id) {
    this._requireNotFrozen();
    this._treasuryAccountId = typeof id === "string" ? AccountId.fromString(id) : id.clone();
    return this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(key) {
    this._requireNotFrozen();
    this._adminKey = key;
    return this;
  }
  get kycKey() {
    return this._kycKey;
  }
  setKycKey(key) {
    this._requireNotFrozen();
    this._kycKey = key;
    return this;
  }
  get freezeKey() {
    return this._freezeKey;
  }
  setFreezeKey(key) {
    this._requireNotFrozen();
    this._freezeKey = key;
    return this;
  }
  get pauseKey() {
    return this._pauseKey;
  }
  setPauseKey(key) {
    this._requireNotFrozen();
    this._pauseKey = key;
    return this;
  }
  get wipeKey() {
    return this._wipeKey;
  }
  setWipeKey(key) {
    this._requireNotFrozen();
    this._wipeKey = key;
    return this;
  }
  get supplyKey() {
    return this._supplyKey;
  }
  setSupplyKey(key) {
    this._requireNotFrozen();
    this._supplyKey = key;
    return this;
  }
  get feeScheduleKey() {
    return this._feeScheduleKey;
  }
  setFeeScheduleKey(key) {
    this._requireNotFrozen();
    this._feeScheduleKey = key;
    return this;
  }
  get freezeDefault() {
    return this._freezeDefault;
  }
  setFreezeDefault(freeze) {
    this._requireNotFrozen();
    this._freezeDefault = freeze;
    return this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(time) {
    this._requireNotFrozen();
    this._autoRenewPeriod = null;
    this._expirationTime = time instanceof Timestamp ? time : Timestamp.fromDate(time);
    return this;
  }
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  setAutoRenewAccountId(id) {
    this._requireNotFrozen();
    this._autoRenewAccountId = id instanceof AccountId ? id : AccountId.fromString(id);
    return this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration ? autoRenewPeriod : new Duration(autoRenewPeriod);
    return this;
  }
  get tokenMemo() {
    return this._tokenMemo;
  }
  setTokenMemo(memo) {
    this._requireNotFrozen();
    this._tokenMemo = memo;
    return this;
  }
  get customFees() {
    return this._customFees;
  }
  setCustomFees(customFees) {
    this._customFees = customFees;
    return this;
  }
  get tokenType() {
    return this._tokenType;
  }
  setTokenType(tokenType) {
    this._tokenType = tokenType;
    return this;
  }
  get supplyType() {
    return this._supplyType;
  }
  setSupplyType(supplyType) {
    this._supplyType = supplyType;
    return this;
  }
  get maxSupply() {
    return this._maxSupply;
  }
  setMaxSupply(maxSupply) {
    this._maxSupply = typeof maxSupply === "number" ? import_long30.default.fromNumber(maxSupply) : maxSupply;
    return this;
  }
  freezeWith(client) {
    if (this._autoRenewPeriod != null && client != null && client.operatorAccountId) {
      this._autoRenewAccountId = client.operatorAccountId;
    }
    return super.freezeWith(client);
  }
  _validateChecksums(client) {
    if (this._treasuryAccountId != null) {
      this._treasuryAccountId.validateChecksum(client);
    }
    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.token.createToken(request);
  }
  _getTransactionDataCase() {
    return "tokenCreation";
  }
  _makeTransactionData() {
    return {
      name: this._tokenName,
      symbol: this._tokenSymbol,
      decimals: this._decimals != null ? this._decimals.toInt() : null,
      initialSupply: this._initialSupply,
      treasury: this._treasuryAccountId != null ? this._treasuryAccountId._toProtobuf() : null,
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      kycKey: this._kycKey != null ? this._kycKey._toProtobufKey() : null,
      freezeKey: this._freezeKey != null ? this._freezeKey._toProtobufKey() : null,
      pauseKey: this._pauseKey != null ? this._pauseKey._toProtobufKey() : null,
      wipeKey: this._wipeKey != null ? this._wipeKey._toProtobufKey() : null,
      supplyKey: this._supplyKey != null ? this._supplyKey._toProtobufKey() : null,
      feeScheduleKey: this._feeScheduleKey != null ? this._feeScheduleKey._toProtobufKey() : null,
      freezeDefault: this._freezeDefault,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      expiry: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      memo: this._tokenMemo,
      customFees: this.customFees.map((fee) => fee._toProtobuf()),
      tokenType: this._tokenType != null ? this._tokenType._code : null,
      supplyType: this._supplyType != null ? this._supplyType._code : null,
      maxSupply: this.maxSupply
    };
  }
};
TRANSACTION_REGISTRY.set("tokenCreation", TokenCreateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenDeleteTransaction.js
var TokenDeleteTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const deleteToken = body.tokenDeletion;
    return Transaction._fromProtobufTransactions(new TokenDeleteTransaction({
      tokenId: deleteToken.token != null ? TokenId._fromProtobuf(deleteToken.token) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.token.deleteToken(request);
  }
  _getTransactionDataCase() {
    return "tokenDeletion";
  }
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("tokenDeletion", TokenDeleteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenDissociateTransaction.js
var TokenDissociateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenIds = null;
    this._accountId = null;
    this.setMaxTransactionFee(new Hbar(5));
    if (props.tokenIds != null) {
      this.setTokenIds(props.tokenIds);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const dissociateToken = body.tokenDissociate;
    return Transaction._fromProtobufTransactions(new TokenDissociateTransaction({
      tokenIds: dissociateToken.tokens != null ? dissociateToken.tokens.map((token) => TokenId._fromProtobuf(token)) : void 0,
      accountId: dissociateToken.account != null ? AccountId._fromProtobuf(dissociateToken.account) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenIds() {
    return this._tokenIds;
  }
  setTokenIds(tokenIds) {
    this._requireNotFrozen();
    this._tokenIds = tokenIds.map((tokenId) => typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone());
    return this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
    for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
      if (tokenId != null) {
        tokenId.validateChecksum(client);
      }
    }
  }
  _execute(channel, request) {
    return channel.token.dissociateTokens(request);
  }
  _getTransactionDataCase() {
    return "tokenDissociate";
  }
  _makeTransactionData() {
    return {
      tokens: this._tokenIds != null ? this._tokenIds.map((tokenId) => tokenId._toProtobuf()) : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("tokenDissociate", TokenDissociateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenFeeScheduleUpdateTransaction.js
var TokenFeeScheduleUpdateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._customFees = [];
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.customFees != null) {
      this.setCustomFees(props.customFees);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const feeScheduleUpdate = body.tokenFeeScheduleUpdate;
    return Transaction._fromProtobufTransactions(new TokenFeeScheduleUpdateTransaction({
      tokenId: feeScheduleUpdate.tokenId != null ? TokenId._fromProtobuf(feeScheduleUpdate.tokenId) : void 0,
      customFees: feeScheduleUpdate.customFees != null ? feeScheduleUpdate.customFees.map((fee) => {
        if (fee.fixedFee != null) {
          return CustomFixedFee._fromProtobuf(fee);
        } else if (fee.fractionalFee != null) {
          return CustomFractionalFee._fromProtobuf(fee);
        } else {
          return CustomRoyalyFee._fromProtobuf(fee);
        }
      }) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : TokenId._fromProtobuf(tokenId._toProtobuf());
    return this;
  }
  get customFees() {
    return this._customFees;
  }
  setCustomFees(fees) {
    this._requireNotFrozen();
    this._customFees = fees;
    return this;
  }
  _execute(channel, request) {
    return channel.token.updateTokenFeeSchedule(request);
  }
  _getTransactionDataCase() {
    return "tokenFeeScheduleUpdate";
  }
  _makeTransactionData() {
    return {
      tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      customFees: this._customFees.map((fee) => fee._toProtobuf())
    };
  }
};
TRANSACTION_REGISTRY.set("tokenFeeScheduleUpdate", TokenFeeScheduleUpdateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenFreezeTransaction.js
var TokenFreezeTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._accountId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const freezeToken = body.tokenFreeze;
    return Transaction._fromProtobufTransactions(new TokenFreezeTransaction({
      tokenId: freezeToken.token != null ? TokenId._fromProtobuf(freezeToken.token) : void 0,
      accountId: freezeToken.account != null ? AccountId._fromProtobuf(freezeToken.account) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.token.freezeTokenAccount(request);
  }
  _getTransactionDataCase() {
    return "tokenFreeze";
  }
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("tokenFreeze", TokenFreezeTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenPauseTransaction.js
var TokenPauseTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const pauseToken = body.tokenPause;
    return Transaction._fromProtobufTransactions(new TokenPauseTransaction({
      tokenId: pauseToken.token != null ? TokenId._fromProtobuf(pauseToken.token) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.token.pauseToken(request);
  }
  _getTransactionDataCase() {
    return "tokenPause";
  }
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("tokenPause", TokenPauseTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenGrantKycTransaction.js
var TokenGrantKycTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._accountId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const grantKycToken = body.tokenGrantKyc;
    return Transaction._fromProtobufTransactions(new TokenGrantKycTransaction({
      tokenId: grantKycToken.token != null ? TokenId._fromProtobuf(grantKycToken.token) : void 0,
      accountId: grantKycToken.account != null ? AccountId._fromProtobuf(grantKycToken.account) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.token.grantKycToTokenAccount(request);
  }
  _getTransactionDataCase() {
    return "tokenGrantKyc";
  }
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("tokenGrantKyc", TokenGrantKycTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenInfo.js
var import_long31 = __toModule(require_long());
var proto15 = __toModule(require_lib());
var TokenInfo2 = class {
  constructor(props) {
    this.tokenId = props.tokenId;
    this.name = props.name;
    this.symbol = props.symbol;
    this.decimals = props.decimals;
    this.totalSupply = props.totalSupply;
    this.treasuryAccountId = props.treasuryAccountId;
    this.adminKey = props.adminKey;
    this.kycKey = props.kycKey;
    this.freezeKey = props.freezeKey;
    this.pauseKey = props.pauseKey;
    this.wipeKey = props.wipeKey;
    this.supplyKey = props.supplyKey;
    this.feeScheduleKey = props.feeScheduleKey;
    this.defaultFreezeStatus = props.defaultFreezeStatus;
    this.defaultKycStatus = props.defaultKycStatus;
    this.pauseStatus = props.pauseStatus;
    this.isDeleted = props.isDeleted;
    this.autoRenewAccountId = props.autoRenewAccountId;
    this.autoRenewPeriod = props.autoRenewPeriod;
    this.expirationTime = props.expirationTime;
    this.tokenMemo = props.tokenMemo;
    this.customFees = props.customFees;
    this.tokenType = props.tokenType;
    this.supplyType = props.supplyType;
    this.maxSupply = props.maxSupply;
  }
  static _fromProtobuf(info) {
    const defaultFreezeStatus = info.defaultFreezeStatus;
    const defaultKycStatus = info.defaultKycStatus;
    const pauseStatus = info.pauseStatus;
    const autoRenewAccountId = info.autoRenewAccount != null ? AccountId._fromProtobuf(info.autoRenewAccount) : new AccountId(0);
    return new TokenInfo2({
      tokenId: TokenId._fromProtobuf(info.tokenId),
      name: info.name,
      symbol: info.symbol,
      decimals: info.decimals,
      totalSupply: import_long31.default.fromValue(info.totalSupply),
      treasuryAccountId: info.treasury != null ? AccountId._fromProtobuf(info.treasury) : null,
      adminKey: info.adminKey != null ? Key2._fromProtobufKey(info.adminKey) : null,
      kycKey: info.kycKey != null ? Key2._fromProtobufKey(info.kycKey) : null,
      freezeKey: info.freezeKey != null ? Key2._fromProtobufKey(info.freezeKey) : null,
      pauseKey: info.pauseKey != null ? Key2._fromProtobufKey(info.pauseKey) : null,
      wipeKey: info.wipeKey != null ? Key2._fromProtobufKey(info.wipeKey) : null,
      supplyKey: info.supplyKey != null ? Key2._fromProtobufKey(info.supplyKey) : null,
      feeScheduleKey: info.feeScheduleKey != null ? Key2._fromProtobufKey(info.feeScheduleKey) : null,
      defaultFreezeStatus: defaultFreezeStatus === 0 ? null : defaultFreezeStatus == 1,
      defaultKycStatus: defaultKycStatus === 0 ? null : defaultKycStatus == 1,
      pauseStatus: pauseStatus === 0 ? null : pauseStatus == 1,
      isDeleted: info.deleted,
      autoRenewAccountId: !(autoRenewAccountId.shard.toInt() == 0 && autoRenewAccountId.realm.toInt() == 0 && autoRenewAccountId.num.toInt() == 0) ? autoRenewAccountId : null,
      autoRenewPeriod: info.autoRenewPeriod != null ? Duration._fromProtobuf(info.autoRenewPeriod) : null,
      expirationTime: info.expiry != null ? Timestamp._fromProtobuf(info.expiry) : null,
      tokenMemo: info.memo != null ? info.memo : "",
      customFees: info.customFees != null ? info.customFees.map((fee) => {
        if (fee.fixedFee != null) {
          return CustomFixedFee._fromProtobuf(fee);
        } else if (fee.fractionalFee != null) {
          return CustomFractionalFee._fromProtobuf(fee);
        } else {
          return CustomRoyalyFee._fromProtobuf(fee);
        }
      }) : [],
      tokenType: info.tokenType != null ? TokenType._fromCode(info.tokenType) : null,
      supplyType: info.supplyType != null ? TokenSupplyType._fromCode(info.supplyType) : null,
      maxSupply: info.maxSupply != null ? info.maxSupply : null
    });
  }
  _toProtobuf() {
    return {
      tokenId: this.tokenId._toProtobuf(),
      name: this.name,
      symbol: this.symbol,
      decimals: this.decimals,
      totalSupply: this.totalSupply,
      treasury: this.treasuryAccountId != null ? this.treasuryAccountId._toProtobuf() : null,
      adminKey: this.adminKey != null ? this.adminKey._toProtobufKey() : null,
      kycKey: this.kycKey != null ? this.kycKey._toProtobufKey() : null,
      freezeKey: this.freezeKey != null ? this.freezeKey._toProtobufKey() : null,
      pauseKey: this.pauseKey != null ? this.pauseKey._toProtobufKey() : null,
      wipeKey: this.wipeKey != null ? this.wipeKey._toProtobufKey() : null,
      supplyKey: this.supplyKey != null ? this.supplyKey._toProtobufKey() : null,
      feeScheduleKey: this.feeScheduleKey != null ? this.feeScheduleKey._toProtobufKey() : null,
      defaultFreezeStatus: this.defaultFreezeStatus == null ? 0 : this.defaultFreezeStatus ? 1 : 2,
      defaultKycStatus: this.defaultKycStatus == null ? 0 : this.defaultKycStatus ? 1 : 2,
      pauseStatus: this.pauseStatus == null ? 0 : this.pauseStatus ? 1 : 2,
      deleted: this.isDeleted,
      autoRenewAccount: this.autoRenewAccountId != null ? this.autoRenewAccountId._toProtobuf() : void 0,
      autoRenewPeriod: this.autoRenewPeriod != null ? this.autoRenewPeriod._toProtobuf() : null,
      expiry: this.expirationTime != null ? this.expirationTime._toProtobuf() : null,
      memo: this.tokenMemo,
      customFees: this.customFees.map((fee) => fee._toProtobuf()),
      tokenType: this.tokenType != null ? this.tokenType._code : null,
      supplyType: this.supplyType != null ? this.supplyType._code : null,
      maxSupply: this.maxSupply
    };
  }
  static fromBytes(bytes2) {
    return TokenInfo2._fromProtobuf(proto15.TokenInfo.decode(bytes2));
  }
  toBytes() {
    return proto15.TokenInfo.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/src/token/TokenInfoQuery.js
var TokenInfoQuery = class extends Query {
  constructor(properties = {}) {
    super();
    this._tokenId = null;
    if (properties.tokenId != null) {
      this.setTokenId(properties.tokenId);
    }
  }
  static _fromProtobuf(query) {
    const info = query.tokenGetInfo;
    return new TokenInfoQuery({
      tokenId: info.token != null ? TokenId._fromProtobuf(info.token) : void 0
    });
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  async getCost(client) {
    let cost = await super.getCost(client);
    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return Hbar.fromTinybars(25);
    }
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.token.getTokenInfo(request);
  }
  _mapResponseHeader(response) {
    const tokenGetInfo = response.tokenGetInfo;
    return tokenGetInfo.header;
  }
  _mapResponse(response, nodeAccountId, request) {
    const info = response.tokenGetInfo;
    return Promise.resolve(TokenInfo2._fromProtobuf(info.tokenInfo));
  }
  _onMakeRequest(header) {
    return {
      tokenGetInfo: {
        header,
        token: this._tokenId != null ? this._tokenId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("tokenGetInfo", TokenInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenMintTransaction.js
var import_long32 = __toModule(require_long());
var TokenMintTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._amount = null;
    this._metadata = [];
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.amount != null) {
      this.setAmount(props.amount);
    }
    if (props.metadata != null) {
      this.setMetadata(props.metadata);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const mintToken = body.tokenMint;
    return Transaction._fromProtobufTransactions(new TokenMintTransaction({
      tokenId: mintToken.token != null ? TokenId._fromProtobuf(mintToken.token) : void 0,
      amount: mintToken.amount != null ? mintToken.amount : void 0,
      metadata: mintToken.metadata != null ? mintToken.metadata : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  get amount() {
    return this._amount;
  }
  setAmount(amount) {
    this._requireNotFrozen();
    this._amount = amount instanceof import_long32.default ? amount : import_long32.default.fromValue(amount);
    return this;
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  get metadata() {
    return this._metadata;
  }
  addMetadata(metadata) {
    this._requireNotFrozen();
    if (typeof metadata === "string") {
      console.warn("Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead.");
    }
    this._metadata.push(typeof metadata === "string" ? decode5(metadata) : metadata);
    return this;
  }
  setMetadata(metadata) {
    this._requireNotFrozen();
    for (const data of metadata) {
      if (typeof data === "string") {
        console.warn("Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead.");
        break;
      }
    }
    this._metadata = metadata.map((data) => typeof data === "string" ? decode5(data) : data);
    return this;
  }
  _execute(channel, request) {
    return channel.token.mintToken(request);
  }
  _getTransactionDataCase() {
    return "tokenMint";
  }
  _makeTransactionData() {
    return {
      amount: this._amount,
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      metadata: this._metadata
    };
  }
};
TRANSACTION_REGISTRY.set("tokenMint", TokenMintTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenNftInfo.js
var TokenNftInfo = class {
  constructor(props) {
    this.nftId = props.nftId;
    this.accountId = props.accountId;
    this.creationTime = props.creationTime;
    this.metadata = props.metadata;
    Object.freeze(this);
  }
  static _fromProtobuf(info) {
    return new TokenNftInfo({
      nftId: NftId._fromProtobuf(info.nftID),
      accountId: AccountId._fromProtobuf(info.accountID),
      creationTime: Timestamp._fromProtobuf(info.creationTime),
      metadata: info.metadata !== void 0 ? info.metadata : null
    });
  }
  _toProtobuf() {
    return {
      nftID: this.nftId._toProtobuf(),
      accountID: this.accountId._toProtobuf(),
      creationTime: this.creationTime._toProtobuf(),
      metadata: this.metadata
    };
  }
  toJson() {
    return {
      nftId: this.nftId.toString(),
      accountId: this.accountId.toString(),
      creationTime: this.creationTime.toString(),
      metadata: this.metadata != null ? encode3(this.metadata) : null
    };
  }
  toString() {
    return JSON.stringify(this.toJson());
  }
};

// node_modules/@hashgraph/sdk/src/token/TokenNftInfoQuery.js
var import_long33 = __toModule(require_long());
var TokenNftInfoQuery = class extends Query {
  constructor(properties = {}) {
    super();
    this._nftId = null;
    if (properties.nftId != null) {
      this.setNftId(properties.nftId);
    }
    this._accountId = null;
    if (properties.accountId != null) {
      this.setAccountId(properties.accountId);
    }
    this._tokenId = null;
    if (properties.tokenId != null) {
      this.setTokenId(properties.tokenId);
    }
    this._start = null;
    if (properties.start != null) {
      this.setStart(properties.start);
    }
    this._end = null;
    if (properties.end != null) {
      this.setEnd(properties.end);
    }
  }
  static _fromProtobuf(query) {
    if (query.tokenGetNftInfo != null) {
      const info = query.tokenGetNftInfo;
      return new TokenNftInfoQuery({
        nftId: info.nftID != null ? NftId._fromProtobuf(info.nftID) : void 0
      });
    } else if (query.tokenGetAccountNftInfos != null) {
      const info = query.tokenGetAccountNftInfos;
      return new TokenNftInfoQuery({
        accountId: info.accountID != null ? AccountId._fromProtobuf(info.accountID) : void 0,
        start: info.start != null ? info.start : void 0,
        end: info.end != null ? info.end : void 0
      });
    } else {
      const info = query.tokenGetNftInfos;
      return new TokenNftInfoQuery({
        tokenId: info.tokenID != null ? TokenId._fromProtobuf(info.tokenID) : void 0,
        start: info.start != null ? info.start : void 0,
        end: info.end != null ? info.end : void 0
      });
    }
  }
  get nftId() {
    return this._nftId;
  }
  setNftId(nftId) {
    this._nftId = typeof nftId === "string" ? NftId.fromString(nftId) : NftId._fromProtobuf(nftId._toProtobuf());
    return this;
  }
  get accountId() {
    console.warn("`TokenNftInfoQuery.accountId` is deprecated with no replacement");
    return this._accountId;
  }
  setAccountId(accountId) {
    console.warn("`TokenNftInfoQuery.setAccountId()` is deprecated with no replacement");
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : AccountId._fromProtobuf(accountId._toProtobuf());
    return this;
  }
  get tokenId() {
    console.warn("`TokenNftInfoQuery.tokenId` is deprecated with no replacement");
    return this._tokenId;
  }
  setTokenId(tokenId) {
    console.warn("`TokenNftInfoQuery.setTokenId()` is deprecated with no replacement");
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : TokenId._fromProtobuf(tokenId._toProtobuf());
    return this;
  }
  get start() {
    console.warn("`TokenNftInfoQuery.start` is deprecated with no replacement");
    return this._start;
  }
  setStart(start) {
    console.warn("`TokenNftInfoQuery.setStart()` is deprecated with no replacement");
    this._start = typeof start === "number" ? import_long33.default.fromNumber(start) : start;
    return this;
  }
  get end() {
    console.warn("`TokenNftInfoQuery.end` is deprecated with no replacement");
    return this._end;
  }
  setEnd(end) {
    console.warn("`TokenNftInfoQuery.setEnd()` is deprecated with no replacement");
    this._end = typeof end === "number" ? import_long33.default.fromNumber(end) : end;
    return this;
  }
  async getCost(client) {
    let cost = await super.getCost(client);
    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return Hbar.fromTinybars(25);
    }
  }
  _execute(channel, request) {
    return channel.token.getTokenNftInfo(request);
  }
  _mapResponseHeader(response) {
    const infos = response.tokenGetNftInfo;
    return infos.header;
  }
  _mapResponse(response, nodeAccountId, request) {
    const nfts = [
      response.tokenGetNftInfo.nft
    ];
    return Promise.resolve(nfts.map((nft) => TokenNftInfo._fromProtobuf(nft)));
  }
  _onMakeRequest(header) {
    return {
      tokenGetNftInfo: {
        header,
        nftID: this._nftId != null ? this._nftId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("tokenGetNftInfo", TokenNftInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenRevokeKycTransaction.js
var TokenRevokeKycTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._accountId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const revokeKycToken = body.tokenRevokeKyc;
    return Transaction._fromProtobufTransactions(new TokenRevokeKycTransaction({
      tokenId: revokeKycToken.token != null ? TokenId._fromProtobuf(revokeKycToken.token) : void 0,
      accountId: revokeKycToken.account != null ? AccountId._fromProtobuf(revokeKycToken.account) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.token.revokeKycFromTokenAccount(request);
  }
  _getTransactionDataCase() {
    return "tokenRevokeKyc";
  }
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("tokenRevokeKyc", TokenRevokeKycTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenUnfreezeTransaction.js
var TokenUnfreezeTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._accountId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const unfreezeToken = body.tokenUnfreeze;
    return Transaction._fromProtobufTransactions(new TokenUnfreezeTransaction({
      tokenId: unfreezeToken.token != null ? TokenId._fromProtobuf(unfreezeToken.token) : void 0,
      accountId: unfreezeToken.account != null ? AccountId._fromProtobuf(unfreezeToken.account) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.token.unfreezeTokenAccount(request);
  }
  _getTransactionDataCase() {
    return "tokenUnfreeze";
  }
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("tokenUnfreeze", TokenUnfreezeTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenUnpauseTransaction.js
var TokenUnpauseTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const unpauseToken = body.tokenUnpause;
    return Transaction._fromProtobufTransactions(new TokenUnpauseTransaction({
      tokenId: unpauseToken.token != null ? TokenId._fromProtobuf(unpauseToken.token) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.token.unpauseToken(request);
  }
  _getTransactionDataCase() {
    return "tokenUnpause";
  }
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("tokenUnpause", TokenUnpauseTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenUpdateTransaction.js
var TokenUpdateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._tokenName = null;
    this._tokenSymbol = null;
    this._treasuryAccountId = null;
    this._adminKey = null;
    this._kycKey = null;
    this._freezeKey = null;
    this._wipeKey = null;
    this._supplyKey = null;
    this._autoRenewAccountId = null;
    this._expirationTime = null;
    this._autoRenewPeriod = null;
    this._tokenMemo = null;
    this._feeScheduleKey = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.tokenName != null) {
      this.setTokenName(props.tokenName);
    }
    if (props.tokenSymbol != null) {
      this.setTokenSymbol(props.tokenSymbol);
    }
    if (props.treasuryAccountId != null) {
      this.setTreasuryAccountId(props.treasuryAccountId);
    }
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.kycKey != null) {
      this.setKycKey(props.kycKey);
    }
    if (props.freezeKey != null) {
      this.setFreezeKey(props.freezeKey);
    }
    if (props.wipeKey != null) {
      this.setWipeKey(props.wipeKey);
    }
    if (props.supplyKey != null) {
      this.setsupplyKey(props.supplyKey);
    }
    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }
    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.tokenMemo != null) {
      this.setTokenMemo(props.tokenMemo);
    }
    if (props.feeScheduleKey != null) {
      this.setFeeScheduleKey(props.feeScheduleKey);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update3 = body.tokenUpdate;
    return Transaction._fromProtobufTransactions(new TokenUpdateTransaction({
      tokenId: update3.token != null ? TokenId._fromProtobuf(update3.token) : void 0,
      tokenName: update3.name != null ? update3.name : void 0,
      tokenSymbol: update3.symbol != null ? update3.symbol : void 0,
      treasuryAccountId: update3.treasury != null ? AccountId._fromProtobuf(update3.treasury) : void 0,
      adminKey: update3.adminKey != null ? Key2._fromProtobufKey(update3.adminKey) : void 0,
      kycKey: update3.kycKey != null ? Key2._fromProtobufKey(update3.kycKey) : void 0,
      freezeKey: update3.freezeKey != null ? Key2._fromProtobufKey(update3.freezeKey) : void 0,
      wipeKey: update3.wipeKey != null ? Key2._fromProtobufKey(update3.wipeKey) : void 0,
      supplyKey: update3.supplyKey != null ? Key2._fromProtobufKey(update3.supplyKey) : void 0,
      autoRenewAccountId: update3.autoRenewAccount != null ? AccountId._fromProtobuf(update3.autoRenewAccount) : void 0,
      expirationTime: update3.expiry != null ? Timestamp._fromProtobuf(update3.expiry) : void 0,
      autoRenewPeriod: update3.autoRenewPeriod != null ? Duration._fromProtobuf(update3.autoRenewPeriod) : void 0,
      tokenMemo: update3.memo != null ? update3.memo.value != null ? update3.memo.value : void 0 : void 0,
      feeScheduleKey: update3.feeScheduleKey != null ? Key2._fromProtobufKey(update3.feeScheduleKey) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  get tokenName() {
    return this._tokenName;
  }
  setTokenName(name) {
    this._requireNotFrozen();
    this._tokenName = name;
    return this;
  }
  get tokenSymbol() {
    return this._tokenSymbol;
  }
  setTokenSymbol(symbol) {
    this._requireNotFrozen();
    this._tokenSymbol = symbol;
    return this;
  }
  get treasuryAccountId() {
    return this._treasuryAccountId;
  }
  setTreasuryAccountId(id) {
    this._requireNotFrozen();
    this._treasuryAccountId = typeof id === "string" ? AccountId.fromString(id) : id.clone();
    return this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(key) {
    this._requireNotFrozen();
    this._adminKey = key;
    return this;
  }
  get kycKey() {
    return this._kycKey;
  }
  setKycKey(key) {
    this._requireNotFrozen();
    this._kycKey = key;
    return this;
  }
  get freezeKey() {
    return this._freezeKey;
  }
  setFreezeKey(key) {
    this._requireNotFrozen();
    this._freezeKey = key;
    return this;
  }
  get wipeKey() {
    return this._wipeKey;
  }
  setWipeKey(key) {
    this._requireNotFrozen();
    this._wipeKey = key;
    return this;
  }
  get supplyKey() {
    return this._supplyKey;
  }
  setsupplyKey(key) {
    this._requireNotFrozen();
    this._supplyKey = key;
    return this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(time) {
    this._requireNotFrozen();
    this._expirationTime = time instanceof Timestamp ? time : Timestamp.fromDate(time);
    return this;
  }
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  setAutoRenewAccountId(id) {
    this._requireNotFrozen();
    this._autoRenewAccountId = id instanceof AccountId ? id : AccountId.fromString(id);
    return this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration ? autoRenewPeriod : new Duration(autoRenewPeriod);
    return this;
  }
  get tokenMemo() {
    return this._tokenMemo;
  }
  setTokenMemo(tokenMemo) {
    this._requireNotFrozen();
    this._tokenMemo = tokenMemo;
    return this;
  }
  get feeScheduleKey() {
    return this._feeScheduleKey;
  }
  setFeeScheduleKey(feeScheduleKey) {
    this._requireNotFrozen();
    this._feeScheduleKey = feeScheduleKey;
    return this;
  }
  clearTokenMemo() {
    this._requireNotFrozen();
    this._tokenMemo = null;
    return this;
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._treasuryAccountId != null) {
      this._treasuryAccountId.validateChecksum(client);
    }
    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.token.updateToken(request);
  }
  _getTransactionDataCase() {
    return "tokenUpdate";
  }
  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      name: this.tokenName,
      symbol: this.tokenSymbol,
      treasury: this._treasuryAccountId != null ? this._treasuryAccountId._toProtobuf() : null,
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      kycKey: this._kycKey != null ? this._kycKey._toProtobufKey() : null,
      freezeKey: this._freezeKey != null ? this._freezeKey._toProtobufKey() : null,
      wipeKey: this._wipeKey != null ? this._wipeKey._toProtobufKey() : null,
      supplyKey: this._supplyKey != null ? this._supplyKey._toProtobufKey() : null,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      expiry: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      memo: this._tokenMemo != null ? {
        value: this._tokenMemo
      } : null,
      feeScheduleKey: this._feeScheduleKey != null ? this._feeScheduleKey._toProtobufKey() : null
    };
  }
};
TRANSACTION_REGISTRY.set("tokenUpdate", TokenUpdateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/token/TokenWipeTransaction.js
var import_long34 = __toModule(require_long());
var TokenWipeTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenId = null;
    this._accountId = null;
    this._serials = [];
    this._amount = null;
    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    if (props.amount != null) {
      this.setAmount(props.amount);
    }
    if (props.serials != null) {
      this.setSerials(props.serials);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const wipeToken = body.tokenWipe;
    return Transaction._fromProtobufTransactions(new TokenWipeTransaction({
      tokenId: wipeToken.token != null ? TokenId._fromProtobuf(wipeToken.token) : void 0,
      accountId: wipeToken.account != null ? AccountId._fromProtobuf(wipeToken.account) : void 0,
      amount: wipeToken.amount != null ? wipeToken.amount : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(tokenId) {
    this._requireNotFrozen();
    this._tokenId = typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId.clone();
    return this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._requireNotFrozen();
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  get amount() {
    return this._amount;
  }
  setAmount(amount) {
    this._requireNotFrozen();
    this._amount = amount instanceof import_long34.default ? amount : import_long34.default.fromValue(amount);
    return this;
  }
  _validateChecksums(client) {
    if (this._tokenId != null) {
      this._tokenId.validateChecksum(client);
    }
    if (this._accountId != null) {
      this._accountId.validateChecksum(client);
    }
  }
  get serials() {
    return this._serials;
  }
  setSerials(serials) {
    this._requireNotFrozen();
    this._serials = serials.map((serial) => typeof serial === "number" ? import_long34.default.fromNumber(serial) : serial);
    return this;
  }
  _execute(channel, request) {
    return channel.token.wipeTokenAccount(request);
  }
  _getTransactionDataCase() {
    return "tokenWipe";
  }
  _makeTransactionData() {
    return {
      amount: this._amount,
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null,
      serialNumbers: this.serials
    };
  }
};
TRANSACTION_REGISTRY.set("tokenWipe", TokenWipeTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/topic/TopicCreateTransaction.js
var TopicCreateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._adminKey = null;
    this._submitKey = null;
    this._autoRenewAccountId = null;
    this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);
    this._topicMemo = null;
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    if (props.submitKey != null) {
      this.setSubmitKey(props.submitKey);
    }
    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
    if (props.topicMemo != null) {
      this.setTopicMemo(props.topicMemo);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create = body.consensusCreateTopic;
    return Transaction._fromProtobufTransactions(new TopicCreateTransaction({
      adminKey: create.adminKey != null ? Key2._fromProtobufKey(create.adminKey) : void 0,
      submitKey: create.submitKey != null ? Key2._fromProtobufKey(create.submitKey) : void 0,
      autoRenewAccountId: create.autoRenewAccount != null ? AccountId._fromProtobuf(create.autoRenewAccount) : void 0,
      autoRenewPeriod: create.autoRenewPeriod != null ? create.autoRenewPeriod.seconds != null ? create.autoRenewPeriod.seconds : void 0 : void 0,
      topicMemo: create.memo != null ? create.memo : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get topicMemo() {
    return this._topicMemo;
  }
  setTopicMemo(topicMemo) {
    this._requireNotFrozen();
    this._topicMemo = topicMemo;
    return this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(adminKey) {
    this._requireNotFrozen();
    this._adminKey = adminKey;
    return this;
  }
  get submitKey() {
    return this._submitKey;
  }
  setSubmitKey(submitKey) {
    this._requireNotFrozen();
    this._submitKey = submitKey;
    return this;
  }
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  setAutoRenewAccountId(autoRenewAccountId) {
    this._requireNotFrozen();
    this._autoRenewAccountId = autoRenewAccountId instanceof AccountId ? autoRenewAccountId : AccountId.fromString(autoRenewAccountId);
    return this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration ? autoRenewPeriod : new Duration(autoRenewPeriod);
    return this;
  }
  _validateChecksums(client) {
    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.consensus.createTopic(request);
  }
  _getTransactionDataCase() {
    return "consensusCreateTopic";
  }
  _makeTransactionData() {
    return {
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      submitKey: this._submitKey != null ? this._submitKey._toProtobufKey() : null,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
      memo: this._topicMemo
    };
  }
};
TRANSACTION_REGISTRY.set("consensusCreateTopic", TopicCreateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/topic/TopicDeleteTransaction.js
var TopicDeleteTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._topicId = null;
    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const topicDelete = body.consensusDeleteTopic;
    return Transaction._fromProtobufTransactions(new TopicDeleteTransaction({
      topicId: topicDelete.topicID != null ? TopicId._fromProtobuf(topicDelete.topicID) : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get topicId() {
    return this._topicId;
  }
  setTopicId(topicId) {
    this._requireNotFrozen();
    this._topicId = typeof topicId === "string" ? TopicId.fromString(topicId) : topicId.clone();
    return this;
  }
  _validateChecksums(client) {
    if (this._topicId != null) {
      this._topicId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.consensus.deleteTopic(request);
  }
  _getTransactionDataCase() {
    return "consensusDeleteTopic";
  }
  _makeTransactionData() {
    return {
      topicID: this._topicId != null ? this._topicId._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("consensusDeleteTopic", TopicDeleteTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/topic/TopicInfo.js
var import_long35 = __toModule(require_long());
var proto16 = __toModule(require_lib());
var TopicInfo = class {
  constructor(props) {
    this.topicId = props.topicId;
    this.topicMemo = props.topicMemo;
    this.runningHash = props.runningHash;
    this.sequenceNumber = props.sequenceNumber;
    this.expirationTime = props.expirationTime;
    this.adminKey = props.adminKey;
    this.submitKey = props.submitKey;
    this.autoRenewPeriod = props.autoRenewPeriod;
    this.autoRenewAccountId = props.autoRenewAccountId;
    Object.freeze(this);
  }
  static _fromProtobuf(infoResponse) {
    const info = infoResponse.topicInfo;
    return new TopicInfo({
      topicId: TopicId._fromProtobuf(infoResponse.topicID),
      topicMemo: info.memo != null ? info.memo : "",
      runningHash: info.runningHash != null ? info.runningHash : new Uint8Array(),
      sequenceNumber: info.sequenceNumber != null ? info.sequenceNumber instanceof import_long35.default ? info.sequenceNumber : import_long35.default.fromValue(info.sequenceNumber) : import_long35.default.ZERO,
      expirationTime: info.expirationTime != null ? Timestamp._fromProtobuf(info.expirationTime) : null,
      adminKey: info.adminKey != null ? Key2._fromProtobufKey(info.adminKey) : null,
      submitKey: info.submitKey != null ? Key2._fromProtobufKey(info.submitKey) : null,
      autoRenewPeriod: info.autoRenewPeriod != null ? new Duration(info.autoRenewPeriod.seconds) : null,
      autoRenewAccountId: info.autoRenewAccount != null ? AccountId._fromProtobuf(info.autoRenewAccount) : null
    });
  }
  _toProtobuf() {
    return {
      topicID: this.topicId._toProtobuf(),
      topicInfo: {
        memo: this.topicMemo,
        runningHash: this.runningHash,
        sequenceNumber: this.sequenceNumber,
        expirationTime: this.expirationTime != null ? this.expirationTime._toProtobuf() : null,
        adminKey: this.adminKey != null ? this.adminKey._toProtobufKey() : null,
        submitKey: this.submitKey != null ? this.submitKey._toProtobufKey() : null,
        autoRenewPeriod: this.autoRenewPeriod != null ? this.autoRenewPeriod._toProtobuf() : null,
        autoRenewAccount: this.autoRenewAccountId != null ? this.autoRenewAccountId._toProtobuf() : null
      }
    };
  }
  static fromBytes(bytes2) {
    return TopicInfo._fromProtobuf({
      topicInfo: proto16.ConsensusTopicInfo.decode(bytes2)
    });
  }
  toBytes() {
    return proto16.ConsensusTopicInfo.encode(this._toProtobuf().topicInfo).finish();
  }
};

// node_modules/@hashgraph/sdk/src/topic/TopicInfoQuery.js
var TopicInfoQuery = class extends Query {
  constructor(props = {}) {
    super();
    this._topicId = null;
    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
  }
  static _fromProtobuf(query) {
    const info = query.consensusGetTopicInfo;
    return new TopicInfoQuery({
      topicId: info.topicID != null ? TopicId._fromProtobuf(info.topicID) : void 0
    });
  }
  get topicId() {
    return this._topicId;
  }
  setTopicId(topicId) {
    this._topicId = typeof topicId === "string" ? TopicId.fromString(topicId) : topicId.clone();
    return this;
  }
  async getCost(client) {
    let cost = await super.getCost(client);
    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return Hbar.fromTinybars(25);
    }
  }
  _validateChecksums(client) {
    if (this._topicId != null) {
      this._topicId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.consensus.getTopicInfo(request);
  }
  _mapResponseHeader(response) {
    const consensusGetTopicInfo = response.consensusGetTopicInfo;
    return consensusGetTopicInfo.header;
  }
  _mapResponse(response, nodeAccountId, request) {
    return Promise.resolve(TopicInfo._fromProtobuf(response.consensusGetTopicInfo));
  }
  _onMakeRequest(header) {
    return {
      consensusGetTopicInfo: {
        header,
        topicID: this._topicId != null ? this._topicId._toProtobuf() : null
      }
    };
  }
};
QUERY_REGISTRY.set("consensusGetTopicInfo", TopicInfoQuery._fromProtobuf);

// node_modules/@hashgraph/sdk/src/topic/TopicMessageChunk.js
var import_long36 = __toModule(require_long());
var TopicMessageChunk = class {
  constructor(props) {
    this.consensusTimestamp = props.consensusTimestamp;
    this.contents = props.contents;
    this.runningHash = props.runningHash;
    this.sequenceNumber = props.sequenceNumber;
    Object.freeze(this);
  }
  static _fromProtobuf(response) {
    return new TopicMessageChunk({
      consensusTimestamp: Timestamp._fromProtobuf(response.consensusTimestamp),
      contents: response.message != null ? response.message : new Uint8Array(),
      runningHash: response.runningHash != null ? response.runningHash : new Uint8Array(),
      sequenceNumber: response.sequenceNumber != null ? response.sequenceNumber instanceof import_long36.default ? response.sequenceNumber : import_long36.default.fromValue(response.sequenceNumber) : import_long36.default.ZERO
    });
  }
  _toProtobuf() {
    return {
      consensusTimestamp: this.consensusTimestamp._toProtobuf(),
      message: this.contents,
      runningHash: this.runningHash,
      sequenceNumber: this.sequenceNumber
    };
  }
};

// node_modules/@hashgraph/sdk/src/topic/TopicMessage.js
var import_long37 = __toModule(require_long());
var TopicMessage = class {
  constructor(props) {
    this.consensusTimestamp = props.consensusTimestamp;
    this.contents = props.contents;
    this.runningHash = props.runningHash;
    this.sequenceNumber = props.sequenceNumber;
    this.chunks = props.chunks;
    Object.freeze(this);
  }
  static _ofSingle(response) {
    return new TopicMessage({
      consensusTimestamp: Timestamp._fromProtobuf(response.consensusTimestamp),
      contents: response.message != null ? response.message : new Uint8Array(),
      runningHash: response.runningHash != null ? response.runningHash : new Uint8Array(),
      sequenceNumber: response.sequenceNumber != null ? response.sequenceNumber instanceof import_long37.default ? response.sequenceNumber : import_long37.default.fromNumber(response.sequenceNumber) : import_long37.default.ZERO,
      chunks: [TopicMessageChunk._fromProtobuf(response)]
    });
  }
  static _ofMany(responses) {
    const length = responses.length;
    const last = responses[length - 1];
    const consensusTimestamp = Timestamp._fromProtobuf(last.consensusTimestamp);
    const runningHash = last.runningHash;
    const sequenceNumber = last.sequenceNumber != null ? last.sequenceNumber instanceof import_long37.default ? last.sequenceNumber : import_long37.default.fromValue(last.sequenceNumber) : import_long37.default.ZERO;
    responses.sort((a, b) => (a != null ? a.chunkInfo != null ? a.chunkInfo.number != null ? a.chunkInfo.number : 0 : 0 : 0) < (b != null ? b.chunkInfo != null ? b.chunkInfo.number != null ? b.chunkInfo.number : 0 : 0 : 0) ? -1 : 1);
    const chunks = responses.map((m) => TopicMessageChunk._fromProtobuf(m));
    const size = chunks.map((chunk) => chunk.contents.length).reduce((sum, current) => sum + current, 0);
    const contents = new Uint8Array(size);
    let offset = 0;
    responses.forEach((value) => {
      contents.set(value.message, offset);
      offset += value.message.length;
    });
    return new TopicMessage({
      consensusTimestamp,
      contents,
      runningHash,
      sequenceNumber,
      chunks
    });
  }
};

// node_modules/@hashgraph/sdk/src/topic/SubscriptionHandle.js
var SubscriptionHandle = class {
  constructor() {
    this._call = null;
  }
  _setCall(call) {
    this._call = call;
  }
  unsubscribe() {
    if (this._call != null) {
      this._call();
    }
  }
};

// node_modules/@hashgraph/sdk/src/topic/TopicMessageQuery.js
var proto17 = __toModule(require_lib());
var import_long38 = __toModule(require_long());
var TopicMessageQuery = class {
  constructor(props = {}) {
    this._topicId = null;
    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
    this._startTime = null;
    if (props.startTime != null) {
      this.setStartTime(props.startTime);
    }
    this._endTime = null;
    if (props.endTime != null) {
      this.setEndTime(props.endTime);
    }
    this._limit = null;
    if (props.limit != null) {
      this.setLimit(props.limit);
    }
    this._errorHandler = (message, error) => {
      console.error(`Error attempting to subscribe to topic: ${this._topicId != null ? this._topicId.toString() : ""}`);
    };
    if (props.errorHandler != null) {
      this._errorHandler = props.errorHandler;
    }
    this._listener = null;
    this._completionHandler = () => {
      console.log(`Subscription to topic ${this._topicId != null ? this._topicId.toString() : ""} complete`);
    };
    if (props.completionHandler != null) {
      this._completionHandler = props.completionHandler;
    }
    this._retryHandler = (error) => {
      if (error != null) {
        if (error instanceof Error) {
          return true;
        } else {
          switch (error.code) {
            case 13:
              return RST_STREAM.test(error.details.toString());
            case 5:
            case 8:
            case 14:
              return true;
            default:
              return false;
          }
        }
      }
      return false;
    };
    if (props.retryHandler != null) {
      this._retryHandler = props.retryHandler;
    }
    this._maxAttempts = 10;
    this._maxBackoff = 8e3;
    this._attempt = 0;
    this._handle = null;
  }
  get topicId() {
    return this._topicId;
  }
  setTopicId(topicId) {
    this.requireNotSubscribed();
    this._topicId = typeof topicId === "string" ? TopicId.fromString(topicId) : topicId.clone();
    return this;
  }
  get startTime() {
    return this._startTime;
  }
  setStartTime(startTime) {
    this.requireNotSubscribed();
    this._startTime = startTime instanceof Timestamp ? startTime : startTime instanceof Date ? Timestamp.fromDate(startTime) : new Timestamp(startTime, 0);
    return this;
  }
  get endTime() {
    return this._endTime;
  }
  setEndTime(endTime) {
    this.requireNotSubscribed();
    this._endTime = endTime instanceof Timestamp ? endTime : endTime instanceof Date ? Timestamp.fromDate(endTime) : new Timestamp(endTime, 0);
    return this;
  }
  get limit() {
    return this._limit;
  }
  setLimit(limit) {
    this.requireNotSubscribed();
    this._limit = limit instanceof import_long38.default ? limit : import_long38.default.fromValue(limit);
    return this;
  }
  setErrorHandler(errorHandler) {
    this._errorHandler = errorHandler;
    return this;
  }
  setCompletionHandler(completionHandler) {
    this.requireNotSubscribed();
    this._completionHandler = completionHandler;
    return this;
  }
  setMaxAttempts(attempts) {
    this.requireNotSubscribed();
    this._maxAttempts = attempts;
  }
  setMaxBackoff(backoff) {
    this.requireNotSubscribed();
    this._maxBackoff = backoff;
  }
  subscribe(client, errorHandler, listener) {
    this._handle = new SubscriptionHandle();
    this._listener = listener;
    if (errorHandler != null) {
      this._errorHandler = errorHandler;
    }
    this._makeServerStreamRequest(client);
    return this._handle;
  }
  _makeServerStreamRequest(client) {
    const list = new Map();
    const request = proto17.ConsensusTopicQuery.encode({
      topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
      consensusStartTime: this._startTime != null ? this._startTime._toProtobuf() : null,
      consensusEndTime: this._endTime != null ? this._endTime._toProtobuf() : null,
      limit: this._limit
    }).finish();
    const cancel = client._mirrorNetwork.getNextMirrorNode().getChannel().makeServerStreamRequest(request, (data) => {
      const message = proto17.ConsensusTopicResponse.decode(data);
      if (this._limit != null && this._limit.gt(0)) {
        this._limit = this._limit.sub(1);
      }
      this._startTime = Timestamp._fromProtobuf(message.consensusTimestamp).plusNanos(1);
      if (message.chunkInfo == null || message.chunkInfo != null && message.chunkInfo.total === 1) {
        this._passTopicMessage(TopicMessage._ofSingle(message));
      } else {
        const chunkInfo = message.chunkInfo;
        const initialTransactionID = chunkInfo.initialTransactionID;
        const total = chunkInfo.total;
        const transactionId = TransactionId._fromProtobuf(initialTransactionID).toString();
        let responses = [];
        const temp = list.get(transactionId);
        if (temp == null) {
          list.set(transactionId, responses);
        } else {
          responses = temp;
        }
        responses.push(message);
        if (responses.length === total) {
          const topicMessage = TopicMessage._ofMany(responses);
          list.delete(transactionId);
          this._passTopicMessage(topicMessage);
        }
      }
    }, (error) => {
      const message = error instanceof Error ? error.message : error.details;
      if (this._attempt < this._maxAttempts && this._retryHandler(error)) {
        const delay = Math.min(250 * 2 ** this._attempt, this._maxBackoff);
        console.warn(`Error subscribing to topic ${this._topicId != null ? this._topicId.toString() : "UNKNOWN"} during attempt ${this._attempt}. Waiting ${delay} ms before next attempt: ${message}`);
        this._attempt += 1;
        setTimeout(() => {
          this._makeServerStreamRequest(client);
        }, delay);
      }
    }, this._completionHandler);
    if (this._handle != null) {
      this._handle._setCall(() => cancel());
    }
  }
  requireNotSubscribed() {
    if (this._handle != null) {
      throw new Error("Cannot change fields on an already subscribed query");
    }
  }
  _passTopicMessage(topicMessage) {
    try {
      if (this._listener != null) {
        this._listener(topicMessage);
      } else {
        throw new Error("(BUG) listener is unexpectedly not set");
      }
    } catch (error) {
      this._errorHandler(topicMessage, error);
    }
  }
};

// node_modules/@hashgraph/sdk/src/topic/TopicMessageSubmitTransaction.js
var TopicMessageSubmitTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._topicId = null;
    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
    this._message = null;
    if (props.message != null) {
      this.setMessage(props.message);
    }
    this._maxChunks = 20;
    if (props.maxChunks != null) {
      this.setMaxChunks(props.maxChunks);
    }
    this._chunkInfo = null;
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const message = body.consensusSubmitMessage;
    return Transaction._fromProtobufTransactions(new TopicMessageSubmitTransaction({
      topicId: message.topicID != null ? TopicId._fromProtobuf(message.topicID) : void 0,
      message: message.message != null ? message.message : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  setTransactionId(transactionId) {
    this._requireNotFrozen();
    if (transactionId.accountId == null || transactionId.validStart == null) {
      throw new Error("`TopicMessageSubmitTransaction` does not support `TransactionId` built from `nonce`");
    }
    this._transactionIds = [transactionId];
    return this;
  }
  get topicId() {
    return this._topicId;
  }
  setTopicId(topicId) {
    this._requireNotFrozen();
    this._topicId = typeof topicId === "string" ? TopicId.fromString(topicId) : topicId.clone();
    return this;
  }
  get message() {
    return this._message;
  }
  setMessage(message) {
    this._requireNotFrozen();
    message = requireStringOrUint8Array(message);
    this._message = typeof message === "string" ? encode4(message) : message;
    return this;
  }
  get maxChunks() {
    return this._maxChunks;
  }
  setMaxChunks(maxChunks) {
    this._requireNotFrozen();
    this._maxChunks = maxChunks;
    return this;
  }
  freezeWith(client) {
    super.freezeWith(client);
    if (this._message == null) {
      return this;
    }
    const chunks = Math.floor((this._message.length + (CHUNK_SIZE - 1)) / CHUNK_SIZE);
    if (chunks > this._maxChunks) {
      throw new Error(`Message with size ${this._message.length} too long for ${this._maxChunks} chunks`);
    }
    const initialTransactionId = this.transactionId._toProtobuf();
    let nextTransactionId = this.transactionId;
    super._transactions = [];
    super._transactionIds = [];
    super._signedTransactions = [];
    super._nextTransactionIndex = 0;
    for (let chunk = 0; chunk < chunks; chunk++) {
      this._chunkInfo = {
        initialTransactionID: initialTransactionId,
        total: chunks,
        number: chunk + 1
      };
      this._transactionIds.push(nextTransactionId);
      for (const nodeAccountId of this._nodeIds) {
        this._signedTransactions.push(this._makeSignedTransaction(nodeAccountId));
      }
      nextTransactionId = new TransactionId(nextTransactionId.accountId, new Timestamp(nextTransactionId.validStart.seconds, nextTransactionId.validStart.nanos.add(1)));
      super._nextTransactionIndex = this._nextTransactionIndex + 1;
    }
    this._chunkInfo = null;
    super._nextTransactionIndex = 0;
    return this;
  }
  schedule() {
    this._requireNotFrozen();
    if (this._message != null && this._message.length > CHUNK_SIZE) {
      throw new Error(`cannot scheduled \`TopicMessageSubmitTransaction\` with message over ${CHUNK_SIZE} bytes`);
    }
    return super.schedule();
  }
  async execute(client) {
    return (await this.executeAll(client))[0];
  }
  async executeAll(client) {
    if (!super._isFrozen()) {
      this.freezeWith(client);
    }
    const transactionId = this.transactionId;
    const operatorAccountId = client.operatorAccountId;
    if (operatorAccountId != null && operatorAccountId.equals(transactionId.accountId)) {
      await super.signWithOperator(client);
    }
    const responses = [];
    for (let i = 0; i < this._transactionIds.length; i++) {
      responses.push(await super.execute(client));
    }
    return responses;
  }
  _execute(channel, request) {
    return channel.consensus.submitMessage(request);
  }
  _getTransactionDataCase() {
    return "consensusSubmitMessage";
  }
  _makeTransactionData() {
    if (this._chunkInfo != null && this._message != null) {
      const num = this._chunkInfo.number;
      const startIndex = (num - 1) * CHUNK_SIZE;
      let endIndex = startIndex + CHUNK_SIZE;
      if (endIndex > this._message.length) {
        endIndex = this._message.length;
      }
      return {
        topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
        message: this._message.slice(startIndex, endIndex),
        chunkInfo: this._chunkInfo
      };
    } else {
      return {
        topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
        message: this._message
      };
    }
  }
};
TRANSACTION_REGISTRY.set("consensusSubmitMessage", TopicMessageSubmitTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/topic/TopicUpdateTransaction.js
var TopicUpdateTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._topicId = null;
    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
    this._topicMemo = null;
    if (props.topicMemo != null) {
      this.setTopicMemo(props.topicMemo);
    }
    this._submitKey = null;
    if (props.submitKey != null) {
      this.setSubmitKey(props.submitKey);
    }
    this._adminKey = null;
    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    this._autoRenewAccountId = null;
    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }
    this._autoRenewPeriod = null;
    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update3 = body.consensusUpdateTopic;
    return Transaction._fromProtobufTransactions(new TopicUpdateTransaction({
      topicId: update3.topicID != null ? TopicId._fromProtobuf(update3.topicID) : void 0,
      adminKey: update3.adminKey != null ? Key2._fromProtobufKey(update3.adminKey) : void 0,
      submitKey: update3.submitKey != null ? Key2._fromProtobufKey(update3.submitKey) : void 0,
      autoRenewAccountId: update3.autoRenewAccount != null ? AccountId._fromProtobuf(update3.autoRenewAccount) : void 0,
      autoRenewPeriod: update3.autoRenewPeriod != null ? update3.autoRenewPeriod.seconds != null ? update3.autoRenewPeriod.seconds : void 0 : void 0,
      topicMemo: update3.memo != null ? update3.memo.value != null ? update3.memo.value : void 0 : void 0
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get topicId() {
    return this._topicId;
  }
  setTopicId(topicId) {
    this._requireNotFrozen();
    this._topicId = typeof topicId === "string" ? TopicId.fromString(topicId) : topicId.clone();
    return this;
  }
  clearTopicId() {
    this._requireNotFrozen();
    this._topicId = null;
    return this;
  }
  get topicMemo() {
    return this._topicMemo;
  }
  setTopicMemo(topicMemo) {
    this._requireNotFrozen();
    this._topicMemo = topicMemo;
    return this;
  }
  clearTopicMemo() {
    this._requireNotFrozen();
    this._topicMemo = null;
    return this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(adminKey) {
    this._requireNotFrozen();
    this._adminKey = adminKey;
    return this;
  }
  clearAdminKey() {
    this._requireNotFrozen();
    this._adminKey = null;
    return this;
  }
  get submitKey() {
    return this._submitKey;
  }
  setSubmitKey(submitKey) {
    this._requireNotFrozen();
    this._submitKey = submitKey;
    return this;
  }
  clearSubmitKey() {
    this._requireNotFrozen();
    this._submitKey = null;
    return this;
  }
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  setAutoRenewAccountId(autoRenewAccountId) {
    this._requireNotFrozen();
    this._autoRenewAccountId = autoRenewAccountId instanceof AccountId ? autoRenewAccountId : AccountId.fromString(autoRenewAccountId);
    return this;
  }
  clearAutoRenewAccountId() {
    this._requireNotFrozen();
    this._autoRenewAccountId = null;
    return this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();
    this._autoRenewPeriod = autoRenewPeriod instanceof Duration ? autoRenewPeriod : new Duration(autoRenewPeriod);
    return this;
  }
  _validateChecksums(client) {
    if (this._topicId != null) {
      this._topicId.validateChecksum(client);
    }
    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validateChecksum(client);
    }
  }
  _execute(channel, request) {
    return channel.consensus.updateTopic(request);
  }
  _getTransactionDataCase() {
    return "consensusUpdateTopic";
  }
  _makeTransactionData() {
    return {
      topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
      adminKey: this._adminKey != null ? this._adminKey._toProtobufKey() : null,
      submitKey: this._submitKey != null ? this._submitKey._toProtobufKey() : null,
      memo: this._topicMemo != null ? {
        value: this._topicMemo
      } : null,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null
    };
  }
};
TRANSACTION_REGISTRY.set("consensusUpdateTopic", TopicUpdateTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/account/TransferTransaction.js
var import_long39 = __toModule(require_long());

// node_modules/@hashgraph/sdk/src/account/HbarTransferMap.js
var HbarTransferMap = class extends ObjectMap {
  constructor() {
    super((s) => AccountId.fromString(s));
  }
  static _fromProtobuf(transfers) {
    const accountTransfers = new HbarTransferMap();
    for (const transfer of transfers.accountAmounts != null ? transfers.accountAmounts : []) {
      const account = AccountId._fromProtobuf(transfer.accountID);
      accountTransfers._set(account, Hbar.fromTinybars(transfer.amount));
    }
    return accountTransfers;
  }
};

// node_modules/@hashgraph/sdk/src/account/TransferTransaction.js
var TransferTransaction = class extends Transaction {
  constructor(props = {}) {
    super();
    this._tokenTransfers = new TokenTransferMap();
    this._hbarTransfers = new HbarTransferMap();
    this._nftTransfers = new TokenNftTransferMap();
    this.setMaxTransactionFee(new Hbar(1));
    for (const transfer of props.tokenTransfers != null ? props.tokenTransfers : []) {
      this.addTokenTransfer(transfer.tokenId, transfer.accountId, transfer.amount);
    }
    for (const transfer of props.hbarTransfers != null ? props.hbarTransfers : []) {
      this.addHbarTransfer(transfer.accountId, transfer.amount);
    }
    for (const transfer of props.nftTransfers != null ? props.nftTransfers : []) {
      this.addNftTransfer(transfer.tokenId, transfer.serial, transfer.sender, transfer.recipient);
    }
  }
  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const cryptoTransfer = body.cryptoTransfer;
    const transfers = new TransferTransaction();
    for (const list of cryptoTransfer.tokenTransfers != null ? cryptoTransfer.tokenTransfers : []) {
      const tokenId = TokenId._fromProtobuf(list.token);
      for (const transfer of list.transfers != null ? list.transfers : []) {
        transfers.addTokenTransfer(tokenId, AccountId._fromProtobuf(transfer.accountID), transfer.amount);
      }
      for (const transfer of list.nftTransfers != null ? list.nftTransfers : []) {
        transfers.addNftTransfer(tokenId, transfer.serialNumber, AccountId._fromProtobuf(transfer.senderAccountID), AccountId._fromProtobuf(transfer.receiverAccountID));
      }
    }
    const accountAmounts = cryptoTransfer.transfers != null ? cryptoTransfer.transfers.accountAmounts != null ? cryptoTransfer.transfers.accountAmounts : [] : [];
    for (const aa of accountAmounts) {
      transfers.addHbarTransfer(AccountId._fromProtobuf(aa.accountID), Hbar.fromTinybars(aa.amount));
    }
    return Transaction._fromProtobufTransactions(transfers, transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  get tokenTransfers() {
    return this._tokenTransfers;
  }
  addTokenTransfer(tokenId, accountId, amount) {
    this._requireNotFrozen();
    this._tokenTransfers.__set(tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId), accountId instanceof AccountId ? accountId : AccountId.fromString(accountId), amount instanceof import_long39.default ? amount : import_long39.default.fromNumber(amount));
    return this;
  }
  get hbarTransfers() {
    return this._hbarTransfers;
  }
  addHbarTransfer(accountId, amount) {
    this._requireNotFrozen();
    if (this.hbarTransfers.get(accountId) != null) {
      amount = this._squashTransfers(accountId, amount);
    }
    this._hbarTransfers._set(accountId instanceof AccountId ? accountId : AccountId.fromString(accountId), amount instanceof Hbar ? amount : new Hbar(amount));
    return this;
  }
  _squashTransfers(accountId, amount) {
    let currentValue = this.hbarTransfers.get(accountId);
    return Hbar.fromTinybars((currentValue == null ? import_long39.default.ZERO : currentValue.toTinybars()).add(amount instanceof Hbar ? amount.toTinybars() : new Hbar(amount).toTinybars()));
  }
  _validateChecksums(client) {
    for (const [a, _] of this._hbarTransfers) {
      if (a != null) {
        a.validateChecksum(client);
      }
    }
    for (const [tokenId, transfers] of this._tokenTransfers) {
      if (tokenId != null) {
        tokenId.validateChecksum(client);
      }
      for (const [a, _] of transfers) {
        if (a != null) {
          a.validateChecksum(client);
        }
      }
    }
  }
  get nftTransfers() {
    return this._nftTransfers;
  }
  addNftTransfer(tokenIdOrNftId, senderAccountIdOrSerialNumber, recipientAccountIdOrSenderAccountId, recipient) {
    this._requireNotFrozen();
    let tokenId;
    let serial;
    let senderId;
    let recipientId;
    if (typeof tokenIdOrNftId === "string") {
      if (tokenIdOrNftId.includes("/") || tokenIdOrNftId.includes("@")) {
        tokenIdOrNftId = NftId.fromString(tokenIdOrNftId);
      } else {
        tokenIdOrNftId = TokenId.fromString(tokenIdOrNftId);
      }
    }
    if (tokenIdOrNftId instanceof NftId) {
      tokenId = tokenIdOrNftId.tokenId;
      serial = tokenIdOrNftId.serial;
      senderId = senderAccountIdOrSerialNumber;
      recipientId = recipientAccountIdOrSenderAccountId;
    } else if (tokenIdOrNftId instanceof TokenId) {
      tokenId = tokenIdOrNftId;
      serial = senderAccountIdOrSerialNumber;
      senderId = recipientAccountIdOrSenderAccountId;
      requireNonNull(recipient);
      recipientId = recipient;
    } else {
      throw new Error("unintended type for tokenIdOrNftId");
    }
    this._nftTransfers.__set(typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId, {
      serial: typeof serial === "number" ? import_long39.default.fromNumber(serial) : serial,
      sender: typeof senderId === "string" ? AccountId.fromString(senderId) : senderId,
      recipient: typeof recipientId === "string" ? AccountId.fromString(recipientId) : recipientId
    });
    return this;
  }
  _execute(channel, request) {
    return channel.crypto.cryptoTransfer(request);
  }
  _getTransactionDataCase() {
    return "cryptoTransfer";
  }
  _makeTransactionData() {
    const tokenIds = new Set();
    for (const tokenId of this._tokenTransfers.keys()) {
      tokenIds.add(tokenId.toString());
    }
    for (const tokenId of this._nftTransfers.keys()) {
      tokenIds.add(tokenId.toString());
    }
    const tokenTransfers = Array.from(tokenIds, (tokenId) => {
      const thisTokenTransfers = this._tokenTransfers.get(tokenId);
      const thisNftTransfers = this._nftTransfers.get(tokenId);
      let transfers;
      let nftTransfers;
      if (thisTokenTransfers != null) {
        transfers = Array.from(thisTokenTransfers, ([accountId, amount]) => {
          return {
            accountId,
            amount
          };
        });
        transfers.sort((a, b) => {
          const accountIdComparison = a.accountId.compare(b.accountId);
          if (accountIdComparison != 0) {
            return accountIdComparison;
          }
          return a.amount.compare(b.amount);
        });
      }
      if (thisNftTransfers != null) {
        nftTransfers = thisNftTransfers.map((transfer) => {
          return {
            sender: transfer.sender,
            recipient: transfer.recipient,
            serialNumber: transfer.serial
          };
        });
        nftTransfers.sort((a, b) => {
          const senderComparision = a.sender.compare(b.sender);
          if (senderComparision != 0) {
            return senderComparision;
          }
          const recipientComparision = a.recipient.compare(b.recipient);
          if (recipientComparision != 0) {
            return recipientComparision;
          }
          return a.serialNumber.compare(b.serialNumber);
        });
      }
      return {
        token: TokenId.fromString(tokenId),
        transfers,
        nftTransfers
      };
    });
    const hbarTransfers = Array.from(this._hbarTransfers, ([accountId, amount]) => {
      return {
        accountId,
        amount
      };
    });
    tokenTransfers.sort((a, b) => {
      return a.token.compare(b.token);
    });
    hbarTransfers.sort((a, b) => {
      const accountIdComparison = a.accountId.compare(b.accountId);
      if (accountIdComparison != 0) {
        return accountIdComparison;
      }
      return a.amount.toTinybars().compare(b.amount.toTinybars());
    });
    return {
      transfers: {
        accountAmounts: hbarTransfers.map((transfer) => {
          return {
            accountID: transfer.accountId._toProtobuf(),
            amount: transfer.amount.toTinybars()
          };
        })
      },
      tokenTransfers: tokenTransfers.map((tokenTransfer) => {
        return {
          token: tokenTransfer.token._toProtobuf(),
          transfers: (tokenTransfer.transfers != null ? tokenTransfer.transfers : []).map((transfer) => {
            return {
              accountID: transfer.accountId._toProtobuf(),
              amount: transfer.amount
            };
          }),
          nftTransfers: (tokenTransfer.nftTransfers != null ? tokenTransfer.nftTransfers : []).map((nftTransfer) => {
            return {
              senderAccountID: nftTransfer.sender._toProtobuf(),
              receiverAccountID: nftTransfer.recipient._toProtobuf(),
              serialNumber: nftTransfer.serialNumber
            };
          })
        };
      })
    };
  }
};
TRANSACTION_REGISTRY.set("cryptoTransfer", TransferTransaction._fromProtobuf);

// node_modules/@hashgraph/sdk/src/query/CostQuery.js
var import_proto7 = __toModule(require_lib());
var CostQuery = class extends Executable {
  constructor(query) {
    super();
    this._query = query;
    this._nodeIds = query._nodeIds;
    this._header = null;
  }
  _getTransactionId() {
    return this._query._getTransactionId();
  }
  async _beforeExecute(client) {
    if (client == null) {
      throw new Error("Cannot do CostQuery without Client");
    }
    const operator = client._operator;
    if (operator == null) {
      throw new Error("`client` must have an `operator` or an explicit payment transaction must be provided");
    }
    if (this._query._nodeIds.length == 0) {
      this._query._nodeIds = client._network.getNodeAccountIdsForExecute();
    }
    this._header = {
      payment: await _makePaymentTransaction(TransactionId.generate(new AccountId(0)), new AccountId(0), operator, new Hbar(0)),
      responseType: import_proto7.ResponseType.COST_ANSWER
    };
  }
  _makeRequestAsync() {
    return Promise.resolve(this._query._onMakeRequest(this._header));
  }
  _shouldRetry(request, response) {
    return this._query._shouldRetry(request, response);
  }
  _mapStatusError(request, response) {
    return this._query._mapStatusError(request, response);
  }
  _mapResponse(response, nodeAccountId, request) {
    const cost = this._query._mapResponseHeader(response).cost;
    return Promise.resolve(Hbar.fromTinybars(cost));
  }
  _execute(channel, request) {
    return this._query._execute(channel, request);
  }
  _getNodeAccountId() {
    if (this._nodeIds.length > 0) {
      return this._nodeIds[this._nextNodeIndex];
    } else {
      throw new Error("(BUG) nodeAccountIds were not set for query before executing");
    }
  }
};
COST_QUERY.push((query) => new CostQuery(query));

// node_modules/@hashgraph/sdk/src/ManagedNodeAddress.js
var HOST_AND_PORT = /^(?<address>.*)(:(?<port>\d+))?/;
var ManagedNodeAddress = class {
  constructor(props = {}) {
    if (props.address != null) {
      const hostAndPortResult = HOST_AND_PORT.exec(props.address);
      if (hostAndPortResult == null || hostAndPortResult.groups == null) {
        throw new Error(`failed to parse address: ${props.address}`);
      }
      this._address = hostAndPortResult.groups["address"];
      this._port = hostAndPortResult.groups["port"] != null ? parseInt(hostAndPortResult.groups["port"]) : null;
    } else if (props.host != null && props.port != null) {
      this._address = props.host;
      this._port = props.port;
    } else {
      throw new Error(`failed to create a managed node address: ${JSON.stringify(props)}`);
    }
    Object.freeze(this);
  }
  static fromString(address) {
    return new ManagedNodeAddress({ address });
  }
  toInsecure() {
    let port = this.port;
    switch (this.port) {
      case 50212:
        port = 50211;
        break;
      case 433:
        port = 5600;
    }
    return new ManagedNodeAddress({ host: this.address, port });
  }
  toSecure() {
    let port = this.port;
    switch (this.port) {
      case 50211:
        port = 50212;
        break;
      case 5600:
        port = 433;
    }
    return new ManagedNodeAddress({ host: this.address, port });
  }
  get address() {
    return this._address;
  }
  get port() {
    return this._port;
  }
  isTransportSecurity() {
    return this._port == 50212 || this._port == 433;
  }
  toString() {
    if (this.port == null) {
      return this.address;
    } else {
      return `${this.address}:${this.port}`;
    }
  }
};

// node_modules/@hashgraph/sdk/src/ManagedNode.js
var ManagedNode = class {
  constructor(props = {}) {
    if (props.newNode != null) {
      this._address = typeof props.newNode.address === "string" ? ManagedNodeAddress.fromString(props.newNode.address) : props.newNode.address;
      this._cert = void 0;
      this._channel = null;
      this._channelInitFunction = props.newNode.channelInitFunction;
      this._currentBackoff = 250;
      this._lastUsed = Date.now();
      this._backoffUntil = Date.now();
      this._useCount = 0;
      this._attempts = 0;
      this._minBackoff = 250;
      this._maxBackoff = 8e3;
    } else if (props.cloneNode != null) {
      this._address = props.cloneNode.address;
      this._cert = props.cloneNode.node._cert;
      this._channel = props.cloneNode.node._channel;
      this._channelInitFunction = props.cloneNode.node._channelInitFunction;
      this._currentBackoff = props.cloneNode.node._currentBackoff;
      this._lastUsed = props.cloneNode.node._lastUsed;
      this._backoffUntil = props.cloneNode.node._backoffUntil;
      this._useCount = props.cloneNode.node._useCount;
      this._attempts = props.cloneNode.node._attempts;
      this._minBackoff = props.cloneNode.node._minBackoff;
      this._maxBackoff = props.cloneNode.node._minBackoff;
    } else {
      throw new Error(`failed to create ManagedNode: ${JSON.stringify(props)}`);
    }
  }
  getKey() {
    throw new Error("not implemented");
  }
  toInsecure() {
    throw new Error("not implemented");
  }
  toSecure() {
    throw new Error("not implemented");
  }
  setCert(ledgerId) {
    return this;
  }
  get address() {
    return this._address;
  }
  get attempts() {
    return this._attempts;
  }
  get minBackoff() {
    return this._minBackoff;
  }
  setMinBackoff(minBackoff) {
    if (this._currentBackoff <= minBackoff) {
      this._currentBackoff = minBackoff;
    }
    this._minBackoff = minBackoff;
    return this;
  }
  get maxBackoff() {
    return this._maxBackoff;
  }
  setmaxBackoff(maxBackoff) {
    if (this._currentBackoff <= maxBackoff) {
      this._currentBackoff = maxBackoff;
    }
    this._maxBackoff = maxBackoff;
    return this;
  }
  getChannel() {
    this._useCount++;
    this.__lastUsed = Date.now();
    if (this._channel != null) {
      return this._channel;
    }
    this._channel = this._channelInitFunction(this.address.toString(), this._cert);
    return this._channel;
  }
  isHealthy() {
    return this._backoffUntil <= Date.now();
  }
  increaseDelay() {
    this._currentBackoff = Math.min(this._currentBackoff * 2, this._maxBackoff);
    this._backoffUntil = Date.now() + this._currentBackoff;
  }
  decreaseDelay() {
    this._currentBackoff = Math.max(this._currentBackoff / 2, this._minBackoff);
  }
  wait() {
    const _currentBackoff = this._backoffUntil - this._lastUsed;
    return new Promise((resolve) => setTimeout(resolve, _currentBackoff));
  }
  compare(node) {
    if (this.isHealthy() && node.isHealthy()) {
      if (this._useCount < node._useCount) {
        return -1;
      } else if (this._useCount > node._useCount) {
        return 1;
      } else {
        if (this._lastUsed < node._lastUsed) {
          return -1;
        } else if (this._lastUsed > node._lastUsed) {
          return 1;
        } else {
          return 0;
        }
      }
    } else if (this.isHealthy() && !node.isHealthy()) {
      return -1;
    } else if (!this.isHealthy() && node.isHealthy()) {
      return 1;
    } else {
      if (this._useCount < node._useCount) {
        return -1;
      } else if (this._useCount > node._useCount) {
        return 1;
      } else {
        if (this._lastUsed < node._lastUsed) {
          return -1;
        } else if (this._lastUsed > node._lastUsed) {
          return 1;
        } else {
          return 0;
        }
      }
    }
  }
  close() {
    if (this._channel != null) {
      this._channel.close();
    }
    this._channel = null;
  }
};

// node_modules/@hashgraph/sdk/src/NodeCerts.js
var PREVIEWNET_CERTS = {
  "0.0.3": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUenyqJ4UaFBbwokatcUqAwW3o3rswCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDAxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU4WhgPMjI5NTA2MDcyMjIxNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAwMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEm5b1+oG9R0qt
zM7UZnS5l/xxUNHIHq5+NAvtlviCpJL19jrW9+/UOy00Qqc6vS6tS1hS+dNJmpiZ
FN0EHew4VDR7ACnL4LDJKmIHWjQ0iwvZo5kCpO0r9BtPN5FvaSxyo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUeciBviJtjeuue0GPf1xllNw7qvYwCgYIKoZIzj0EAwMDaAAwZQIw
JeG0H2HdsI1VhOYmJmYlNeKCNgAk+LMorzPmsIInVBO2HK2IrKfpReWDS/m5j51V
AjEAxKBxDezJDqAZHTkTXCg+X9Q9V6J6M5yDy5IS90aCWEo+W8C1Hc6hkn2/NrvT
PhwK
-----END CERTIFICATE-----
`,
  "0.0.4": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUUfjO8LyXBdzrzbAe1Yl+d34IDsIwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDExHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU5WhgPMjI5NTA2MDcyMjIxNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAxMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAERwfj4ZtD/wRb
f8h9NEMu2sQoLFK9Gc4SQ8o6j4ccLYGdgOoVoq4zzy4Jr7ZtCTuACfCfhp7wy8ra
+6cugccaSd6AzOKRSVZvQvkUTFKIoAOKwp6IhlU48rmi80MT07eyo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUCGhfVMP72Y0G5XUksE3dPgFHrzkwCgYIKoZIzj0EAwMDZwAwZAIw
cpX7irZWyuujWRYUs9kLNgB2YLQK+n8r1fH+tJg3+zkcZ2pzhGWmpUUZWOzsDqGC
AjBUbhlmrTc4LrEBN0EMiRYzfPD2kBZxusLBDIg/aDYERCMcsFvF1T9SsuasF/B+
cI8=
-----END CERTIFICATE-----
`,
  "0.0.5": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUIo4L+7xe/mUmpKy4qOAQEIxz8UMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDIxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU5WhgPMjI5NTA2MDcyMjIxNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAyMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEoFgCjb1/7BUJ
EXKIPJLlsOSp/39G8l92wOSr7h+Py7iwVwu68H2ykftMOq3tRwDRXZHz7ViqcIZ9
lfMcS8sbRtVm9tBbNciVUqTLWX9nHr/c4PhKEi+LdgtSUr2+hHiWo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUMR89BHC3yKC4YwUgyBVQUGBCprQwCgYIKoZIzj0EAwMDZwAwZAIw
Us2BdslcScIwcmxoB60K7/1BPfQI8ccDZIMosas6U2zhinTnRKik1T0i+uHhLl8e
AjA5apAwSPTnP7j3Bo/FOCkfjTqOjwp2lUqzDJYKolKsHX2sy8hX9MkYiY46SaJ1
P+0=
-----END CERTIFICATE-----
`,
  "0.0.6": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUWpji03mJsR/16MP8BrOfpNz7aQMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDMxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU5WhgPMjI5NTA2MDcyMjIxNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAzMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE+KDMC99Q1rWi
+FwlytGMS5qzTDytCvk+PzdONnDZ/weNSv4j3BXSo588IwhIxLtfcBlyo/+PmE1c
5qGFXuMoZjGr22VpvogkRgPejD+Gawb4A2XHkMCD8NmO66uPw97po1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUN1qEI4eQ+WHavb9ypGV417NvhGowCgYIKoZIzj0EAwMDaAAwZQIw
L0khkiDOiFRa3wx9l5JNjaSRePPc3ZaTaJQkPYeauMaLWEvmC/0e2/e9gPm5qJ8E
AjEAgXQMko3vNB8VRN4XjyFJa8p/muZ/tLA15wPnb/boUmiZ+njDDSaiu8tIQrTB
gHW6
-----END CERTIFICATE-----
`,
  "0.0.7": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUEJ7AJvrqDUBNKbssGoJtww3v+WowCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDQxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjAwWhgPMjI5NTA2MDcyMjIyMDBaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA0MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEfgJ8w9GUWM3y
yusedZOFQrgXFVsdtRsMSHbqyVCN6+Wow6SIjy29GRMSP5R2aswupFgh6lXJRqnr
tY+hpRumFKsmSo+5+l8DBcql4rzs4utESTehM+Cq9LYc4A1z0UIRo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUMCm3UqSbT01Zr23hLzCGnXbDa+MwCgYIKoZIzj0EAwMDZwAwZAIw
FNcN7mKJo/bwpRT+y/KbYkCJsvljdbXzJOXXQ3e6J6R+0vLqcT25J/ry6pBZMUwR
AjAswu29z8KJCSxnWwnPpHDmkRT15zG/xS+pAmx3oeQSqp6ZD7qpdJE8zzhbfe5x
wAc=
-----END CERTIFICATE-----
`
};
var TESTNET_CERTS = {
  "0.0.3": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUMkNeM6Sbk9ZFYmRWZmSgTQHHWyUwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDAxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU4WhgPMjI5NTA2MDcyMjIyNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAwMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAETLLoIMZjEhDP
KLHS7bJT4OTYGgR/8mB65yfx3KqMLYFF+q2SpWkIrYgUQLVEUEibVSnLlxRUzH7R
szcKynpTwh0W0yfWanZKQg+RWoKkEYlu2GvkUtJb8cRVM9NLmJUeo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUSrIepwFx8gZ8/G+WGaxs6GgkMtQwCgYIKoZIzj0EAwMDaQAwZgIx
AJxC0fjB1OrF9vkCKsfnPS3Z+1hscrZhEDG38NxdLEAfPQ5VmyrSBgJy11FBp8yB
0QIxAKzbge3Lf7iBMwYwm+2M/GiVgmHNMLdtrYuerWpdbYOHgRNAkyt57JoThn0u
Tzkd5Q==
-----END CERTIFICATE-----
`,
  "0.0.4": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUGLriiLPacglp6U+BtJcF9TI7xEUwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDExHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU4WhgPMjI5NTA2MDcyMjIyNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAxMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEXhR9cb6mH9AE
GNSGk3OkxN1C/JW49ddYZ/XWD4InjS8D1kXmB1Y39v1mF0L1loG6lDT8Zp46zrj7
5zMONXZeD2b0mx5hHhtllPTpJ10Tlt9FDoyFbKwPRQ/SAPNADfuzo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUCaKtx8RZ1XJO9rmZMbIcFJZkcv4wCgYIKoZIzj0EAwMDaAAwZQIx
APhDW0VrNSmq8hODdhIVV4GyvpYhp3Fksg+sZr3DmUatwn+ptj+X+9IzgPl9QYE3
kAIwcy2ixgNkjC/DYVmgT4MpUnLneLK0gA23Vj2QwACaTH99H/ybqUH7srj0POB9
5wvV
-----END CERTIFICATE-----
`,
  "0.0.5": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUEMduome38hvAuIKoGjg/tHatQZMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDIxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU4WhgPMjI5NTA2MDcyMjIyNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAyMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEl1olzP1L4WgX
d7aujOXmTQZt3tEOGzkMa3S6qJwISLBI7Tb9KaW8zYIe9xWBVAwphCbD0wn9xpPV
wMr4uTn+JocugYBbe2YoUGzWTkxWnOEKXbh/nQJCe3XE/C0FY8fAo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQULfw7LVtTiUDVIvZwhhWW0soQtSQwCgYIKoZIzj0EAwMDaQAwZgIx
AID5v3Lo2zlnpFzTdJFqBpw6fV+vmpI+JBj61f264J/uHMbELiu2dwxhwWaMElX7
wQIxAJxccFr7Bf1KjaMyT2dq75zQzFuKDMj9x92yAqM2Gas/Yay+Ccpm8FBn7BFl
ke1Qwg==
-----END CERTIFICATE-----
`,
  "0.0.6": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUcCg/gZGxk/UjYkhW1jg4Zki+jfwwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDMxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU5WhgPMjI5NTA2MDcyMjIyNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAzMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEOSsXBZicyrxy
tHJHKh04Mvu6SKM49IC7rAXw5CjlOod5OTeHg0fa5vVoBME4mlWP+LsMMqf8welC
20b4wMwUC1Hnd66v8crX8L1wvZ9EmKLTvhTd65bS5zloMiSbpdF2o1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUgMMwqaGuUT6JCH0gsbqullaW6/QwCgYIKoZIzj0EAwMDaAAwZQIx
AMggJ1eMmT7C14z7wHCsOdDOgmzg733+a5dsuAcxknoz/sQLN8wqy1JxShWgEIA/
xwIweTDAX/4JZnr3mlSC57lYXbHk/c319VfN9Ybxg0FaDXa8tOqg7Ml6Uu3IGujQ
a3eY
-----END CERTIFICATE-----
`,
  "0.0.7": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUXADwhiD5acpA66GPoXuAevBfZBIwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDQxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU5WhgPMjI5NTA2MDcyMjIyNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA0MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEBgLhLiGz8qWu
50vzxSyQkrmhpxuHBJhpGzA0WaUJdAUlaUOL1753ZxxA08wUmcozILNEnMaQ+ROn
+fuGctv90ZcrSekODjxjbKH2ntVLP8xwkBRCTJ0WRBNenxxBD438o1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUhYOOD/z3ty9O5GuSTXnyujIqBRgwCgYIKoZIzj0EAwMDaQAwZgIx
AMxbZ4gvkXaORauQFUPRYwOJrihWIA+3ttGDua//YfEbshytQ8b4L65W/1Xs8eOd
DwIxAImwTzRam8tScdOzmuGgPcML2lkETMpMA2rZYVyEL/VNktIxvB2oE+4M0v5l
r8IbTA==
-----END CERTIFICATE-----
`
};
var MAINNET_CERTS = {
  "0.0.3": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUZWoT9TlgbZy+syLbqZhO5++1cVgwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDAxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ3WhgPMjI5NTA2MDcyMjQyNDdaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAwMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE8NhDGK/dgWvD
RHEJ8af7CBDdhvujH5XIrLen33GTLY8DbJwJW2jdsLGx3+DRVVmeNQZxCbcGj0e2
IyypkG6s0mtnmeymD8mI3JU8m1aZiuIptZSH3Bw1BNn2hKU4x42co1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUbYGliiNtMkGaroQxXWCl+kYHDBwwCgYIKoZIzj0EAwMDZwAwZAIw
ImTOEYu0y73Ggt4NAjFFsN2sV7CsEL3NoJqJ7MZ6U+b3Ax1hnc1eE0oei6xH4VNF
AjBB4iZNvAn6Esiu4k+JPlYuMesplgMv33fU5GsfvLIovN8pOJDe0c+CUmsnfGbP
OsQ=
-----END CERTIFICATE-----
`,
  "0.0.4": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUEGWU0F4aKffY+le55ahQaScDYDwwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDExHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ3WhgPMjI5NTA2MDcyMjQyNDdaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAxMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEqW6TqxMmjL3h
9AVBgfVaFRZlXUcyWa+QYhzxr8sksgJqfDbmGtdaHIdiL1qCPuC4v4G3qrAbXZRm
TYNo5Lz0X2ic5pES6DbacdjOgHH7TAY4BVKkuVrydln2jjhh7SmBo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUcBlY5a1rV0H1iQuJMwWxrTEWQ6MwCgYIKoZIzj0EAwMDZwAwZAIw
R+mY9B2U26yD44s03hjz4TlpkyXbVfmgL3Elqo3lrWDJtvT4zpjGjxg3Q1P3SpZQ
AjAy9DRVrZPzq8iq5Ir7B8XgLQH5QL7SQ3tUL1HzXJYOukvn9Ofr+QADhpb0oJLB
Kug=
-----END CERTIFICATE-----
`,
  "0.0.5": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUbxzfD3ihIK5snumqqKtqtcBPSSQwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDIxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ3WhgPMjI5NTA2MDcyMjQyNDdaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAyMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEWoAjWmW7vpUr
U69wRbK9Firons4kRoin6N8lMjCD+xzsrsT6/wycpzC0F8fxfIvOYSMWRtinhOKl
ZAxp60OWYP87iH7RqWBAnHIJZj/znKTGd+8Sqp/RVQmButFHg/+Go1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUTMtwuDzI4Hun7SPp2Nb3scjUUXkwCgYIKoZIzj0EAwMDZwAwZAIw
HKAgaX39Lgc+4/xHXzZR9mi2p3pf6CDO85Xm56UR/t48HnBkRorR3TFCBXACeIIs
AjBtXglpDnRf6M+nVBlxLdwCQXiwr6vQJ9+dUo+suNkZ1JBmtHypyIqkG2yT4z9C
Lcs=
-----END CERTIFICATE-----
`,
  "0.0.6": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUPwXdJvpCJYO9lm6uQN3S1aBi3PswCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDMxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ4WhgPMjI5NTA2MDcyMjQyNDhaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAzMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE8PwBQ0ywu+0t
eIYbaiKwzGEScQMOYFYAMw49++6bGRiH/XZjsypqlJWy3F/mB3+HNVZsqgB61Jpj
2p98Afkl57MYWhWM29t/x5qAQ8LhKGu2k+BOnCcvHDU2pR+fmFSOo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUgI4r3/iwzFN2wh76y/4XDBk7wgkwCgYIKoZIzj0EAwMDaQAwZgIx
ANAjwHdTWYMCCjrtb2NWzDpsKjf3m6ZcaxbEcM1ta/Zji/4x0+VRZa917CkfaEsr
LAIxAK/erPvIXRU9eNaK/TAQqppSRaF35G6iNnYjQZzfjTU2DczhT4oCjKzGoCHT
kI1zOg==
-----END CERTIFICATE-----
`,
  "0.0.7": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUXUGzJj13Ck2Cp0BKauLOdzgCPwIwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDQxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ4WhgPMjI5NTA2MDcyMjQyNDhaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA0MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE8Ee64Tbu53i/
KsuLOJG3GQ4e9gQ+9BtEy7U8kfFzRHh6Ejn7LOW38ZdKX1HP4zXuUusjNvytqDvr
7eclitqnegcEOkIeFK3wQwBoNILuq+r4LRVi19V+AIcl5w3qkJvIo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQU2tbfu7hd7USgbS2WsG/6BduKEAMwCgYIKoZIzj0EAwMDaAAwZQIw
Rw/BOLoScmU7P/1JnNPsGarmnvcuJrokAv1wk6j8s5LGuQHReX+d+O3RPLggwcAY
AjEAjoZnt9simul4cVcVy4G/0f39atanUva17gyzlYXEYx7B6UloxLeEcZhlbBf8
GjRf
-----END CERTIFICATE-----
`,
  "0.0.8": ``,
  "0.0.9": ``,
  "0.0.10": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUNauEDBCmP9igXLWtRpzkQqIGo/wwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDcxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ5WhgPMjI5NTA2MDcyMjQyNDlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA3MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEjbkoJBshQXUy
qm5K8ldpTDR94Wk8iEM7QwHfceIxK5pPgaVGRkoJyVLSK5LMH4jyaIHUrtA0lIBQ
o0MsYkq7TOOm7+vo1Yrd8EMbu5StMb3gsXUrj7E/SBKIxULak6hCo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUyKHMzIBPRV/mrgG7tIjzOiw2xbUwCgYIKoZIzj0EAwMDaAAwZQIx
ANsigVtLgTdKWBPVJPstWA0H8yihf0/dmM3GO4qp5keGTWz/O3tnom4iDB6eSrcA
jwIwU82Dh+Wxl3kAD3YJH5VhlfHTm1rPlJETBHZgvPBOYqippao6+WZFEpn2/IDC
NTjn
-----END CERTIFICATE-----
`,
  "0.0.11": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUWtnJm2kswnXYu7/S5BnnTQiDRcUwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDgxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjUwWhgPMjI5NTA2MDcyMjQyNTBaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA4MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEjY9Rl+s00xFV
tdTpAixLR4kJIGLfSLOdm+ofU/KuKMRSz5x1ORhIicppKZK24U5WLGXQU1fKLvxX
OmqwqL+6oAONmiHszqVdhWne4QPUba0yw7rf1/OI+IFF1HRK3shQo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUb/htoTodbq5hjP5RNlQ0rkKwWB0wCgYIKoZIzj0EAwMDZwAwZAIw
bO+9yArr21XKXjYHPadEAYINDxgXEC3W8e3X6MJsHCIZITddWWOyXRNFhz504vN0
AjB8aBuhrKcg1b4CrQDZQcosyVPUGIZKkXdQFfbVdivKrGZvqLS+GdPLd3v2MmHY
orA=
-----END CERTIFICATE-----
`,
  "0.0.12": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUHBsegV0bKtwpHRoOnnhbK7CTHxMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDkxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjUwWhgPMjI5NTA2MDcyMjQyNTBaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA5MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEK+ZAs/00RXaj
buQJJy4zwr/YTj9h5V+vbY7sq9Z1RByEwTRRQOI3OuzzMq1EWKkVJKF/QF5b4yda
x6W9O/NT4EjBXH5XR5X1V6h7aT01YBqsxgMxuUP7kw9K+fW4k6Zao1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUKbecoYirLjf2O2oPkoggEE2P7FcwCgYIKoZIzj0EAwMDaQAwZgIx
AP67wsVOkeFo/9QRo+PnZhzEvjOZ/+IUoUhimdljcVwn79tzNP+obf7VW3Oq1wH7
4wIxAL65+WmMTMoI2cN7TCiL7G/W2ChDsASeHfaP/4e4ZViNONWotlY9i9aS3Kwt
LTea1Q==
-----END CERTIFICATE-----
`,
  "0.0.13": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUBNxMZRKru9jzFA8zsOAI4xkMFCMwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDEwMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MFoYDzIyOTUwNjA3MjI0MjUwWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTAxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAShUi9sglwb
0U8QUrGOXJuHRXA9HP8RypkgNBwNRs1YcmPLcuwK70unWlkB81M44IQ7z/dG/0cW
hfFdRI5x4jAeiUFivmWmMLT6lJMPxJ0BkWTGVFVwI3SKcgSvHP9pNS2jVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBSqIMCDzCKKwJJLCXhu9YJYPw6lsDAKBggqhkjOPQQDAwNnADBk
AjBl0bJG2A3443ybvrkKjWu8do6nDSR08/M49+19QfA1aDw0nb2sdCOE+xNitpQ9
7ngCMGuQHmnKA2EyOIVpNl2EtRoG+vdmLJQaoukhmCWjkGrQHkai473tGa9cRZ/8
+RZFzw==
-----END CERTIFICATE-----
`,
  "0.0.14": `-----BEGIN CERTIFICATE-----
MIICoTCCAiegAwIBAgIUJcQrEmPlIh0KWwiC2X6lZ/OdNs8wCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDExMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MVoYDzIyOTUwNjA3MjI0MjUxWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTExHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASxRizKJSbB
HmG2amvTHLCyExJngCh42agaFkv5Ab9mZYbqZPe0nUn/8RlVAvEiRNggCMYXC6MU
e4J6D1aeLhYaa0UY8Fmxd20NUjAOWhJgUXds4ILMMVG+pevofeC8AsujVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBS2Ic+LU/6Wssns4Yyf3N6E666xDzAKBggqhkjOPQQDAwNoADBl
AjAH0JMX48GD6vThA6FUsVnJmBID376PRZgxhuZvn9C0HawvNjZVQTkpzpYCwmia
dO4CMQCotakNxyiOxu/BbnPx6ld5+dqVCugsfqClhUhy8ROpNHfKxp3rW7HopowT
WiMlIyI=
-----END CERTIFICATE-----
`,
  "0.0.15": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUSFFNFv1iquxd5txlWA3PlkNju2EwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDEyMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MVoYDzIyOTUwNjA3MjI0MjUxWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTIxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQus3nAPZkb
ja4Efo7iD4s8NLsFwEwQXQBgBGIJwtA2JRgLyXeWpuu125ib6qJzT8CHvQZhel3b
cwYWi4f2JpabMDepHELLxwZ9fILnAQ8GiHlzhrVq2NI15DI84dXVe4OjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBSEO/JFC5/fDcT2gtipDMYMMTd96DAKBggqhkjOPQQDAwNnADBk
AjBalAU47XQL4ziHD8lj21pcp3+R5FKzn96HclMT/vraknCT1Sl+vCf6EYsqmi6Z
+RwCMDpxL6P6OMqyE+HzAeYQ4Fa7MYEQfZGMjka4zxetBLvIpwUCT4EAO8gv9GoU
wCBUzQ==
-----END CERTIFICATE-----
`,
  "0.0.16": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUdnkil4P+VthVMnqygVwGKLt7VfAwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDEzMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MVoYDzIyOTUwNjA3MjI0MjUxWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTMxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAARUdz9ig/iA
hEAth2YinHKY6WM63BAxUVItzgk65l1T4wTzwoK4XEwclY5vIeFmZy2e0s95lWgq
SI68VS9gmJ3xp8Q9wOel/bvuF2tvNZmF393TeoNQQVHrQM1yJAx+nPyjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBTBFdNwHKSRDo6CxfA1aglY0N8joTAKBggqhkjOPQQDAwNnADBk
AjAqPIel58Rcl2kDxZxJPD9mK9xW4TU+d2NuP3n140TQ6nPlw1OwCPI7a4i3wfEe
08ICMBbrpNRdFZcvy76KoLPfTPvqbtWWaR/0tLZg4Rjj3x7SYgUg3vrVDmodHGkb
4T2Raw==
-----END CERTIFICATE-----
`,
  "0.0.17": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUDg+G4Ep+KEmIo+nCOY8DjFX60swwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE0MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MloYDzIyOTUwNjA3MjI0MjUyWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTQxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASCQRL5xUUh
1bsTXRPAf/qVFWEOxsJTiMlF3+UJ4MajWE5zmc2QNIzqj7NE24z3fNxgjViNK/8+
oBNQeqXfyJ/4etNMzTyG4JTsvWRAQ3aR1J4WDbfwpcgw6AIOKq9OLP6jVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBQB9V2fygf48zyyVL3bnAxCLDUV9zAKBggqhkjOPQQDAwNnADBk
AjBonlThjjvi3fg7ODQcatPHBkp8Yon/p1ukm3YzYA3kitqroXU7BkmwRae2fbqD
TTICMHI+fAy+xWGwXAFNcvNTop11IIoszcgJJY+1Mc2Q/USk3pP6iezta+rvnaWu
7JySHg==
-----END CERTIFICATE-----
`,
  "0.0.18": `-----BEGIN CERTIFICATE-----
MIICojCCAiegAwIBAgIUBvI2Vq6O8yXNzbQlj6uQOdpd1lIwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE1MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MloYDzIyOTUwNjA3MjI0MjUyWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTUxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAR+jFDSzCdn
mMQpgz/vrmD/xioMioumUmyLAkB+voTNsMAOtiaDVbvJty3b4SJETv5tuZyaF5Gb
QAYuKsP7X8siCCVLZC9i9nCg46NHtuQkEmw1pzUUDmYFDfSV2tWedNqjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBSqvCmoaVEp2d9WPctby+ooPMGmvTAKBggqhkjOPQQDAwNpADBm
AjEA9fQ2OFZa7fAQGGYydfVaUF0ObxKj3T+hyl0jiCKLe+hyxJSrXCFS2BM71UiG
ZMVxAjEAmCzESBzTVvl4Uv3TyActGTijTCqTNpN3gJmQbZYjKVtqf8Wxj9WeH0pM
E8BlA/qE
-----END CERTIFICATE-----
`,
  "0.0.19": `-----BEGIN CERTIFICATE-----
MIICojCCAiegAwIBAgIUZBwp7UPLJkDgngbUIx5xjbAn+7YwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE2MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1M1oYDzIyOTUwNjA3MjI0MjUzWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTYxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASCVYu2uF3T
kCkyRP0FfXVyyTA1z8DFqCKGrcODgGJuVAk59H6u8FIRsNipkb3BXFI0xGccok5X
T+t5bMaGDHYJ4fjU78UtPNmankQ5HoiMRJpy7Vn8mzizUzUqGpnhu6GjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBQzE6RGn4YlIbdrl0niKWTtJzfXoTAKBggqhkjOPQQDAwNpADBm
AjEAobnXnwlNGNWoHscbl/ytUBSyjC7V11sLYJqtORSRX3k2+bFGsg4ltmOVjTdd
lXatAjEA/Ja3jufmdruqfLa6qigXuYI00YaI96sOwNhdHlnksYfqF41nDe4BsSW6
eQ6N5M9d
-----END CERTIFICATE-----
`,
  "0.0.20": `-----BEGIN CERTIFICATE-----
MIICoTCCAiegAwIBAgIUE1ZRB5n+Yby+Mwgb2xAcVfTZ53kwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE3MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1M1oYDzIyOTUwNjA3MjI0MjUzWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTcxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAR0OfTmHjxT
kBiU3GMa/bTvlTswCDAuFQGIIpMWHaf6V4ighzmn20jCg0AVFStb2q7YLRr4HUx8
ToMzsd7/yjl74BwJgfZnL75T/JInwyMgOBiCTXEf6qVDvhNzL4QJuVujVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBQFKRUUmdFcDFQzBN9XqMvLgPd7NzAKBggqhkjOPQQDAwNoADBl
AjEA5MUUXSehY3KVIv/2LMgrqo1kPiV39fwYuLSnsMJ67wK8yN1NAkkycg6q2K6g
rBIvAjB3J3a40TINOZTYG+eQs+MSWyfANJLRuJTEOorXzMWM6+05+JYhPnLA8hke
CRfzmSw=
-----END CERTIFICATE-----
`
};

// node_modules/@hashgraph/sdk/src/Node.js
var Node = class extends ManagedNode {
  constructor(props = {}) {
    super(props);
    if (props.newNode != null) {
      this._accountId = props.newNode.accountId;
      this._nodeAddress = null;
    } else if (props.cloneNode != null) {
      this._accountId = props.cloneNode.node._accountId;
      this._nodeAddress = props.cloneNode.node._nodeAddress;
    } else {
      throw new Error(`failed to create node: ${JSON.stringify(props)}`);
    }
  }
  getKey() {
    return this._accountId.toString();
  }
  toInsecure() {
    return new Node({
      cloneNode: { node: this, address: this._address.toInsecure() }
    });
  }
  toSecure() {
    return new Node({
      cloneNode: { node: this, address: this._address.toSecure() }
    });
  }
  setCert(ledgerId) {
    const networkName = _ledgerIdToNetworkName(ledgerId);
    switch (networkName) {
      case "previewnet":
        this._cert = PREVIEWNET_CERTS[this._accountId.toString()];
        break;
      case "testnet":
        this._cert = TESTNET_CERTS[this._accountId.toString()];
        break;
      case "mainnet":
        this._cert = MAINNET_CERTS[this._accountId.toString()];
        break;
    }
    return this;
  }
  get accountId() {
    return this._accountId;
  }
  get nodeAddress() {
    return this._nodeAddress;
  }
  setNodeAddress(nodeAddress) {
    this._nodeAddress = nodeAddress;
    return this;
  }
};

// node_modules/@hashgraph/sdk/src/address_book/IPv4AddressPart.js
var IPv4AddressPart = class {
  constructor(props = {}) {
    this._left = null;
    if (props.left != null) {
      this.setLeft(props.left);
    }
    this._right = null;
    if (props.right != null) {
      this.setRight(props.right);
    }
  }
  get left() {
    return this._left;
  }
  setLeft(part) {
    this._left = part;
    return this;
  }
  get right() {
    return this._right;
  }
  setRight(part) {
    this._right = part;
    return this;
  }
  toString() {
    if (this._left != null && this._right != null) {
      return `${this._left.toString()}.${this._right.toString()}`;
    } else {
      return "";
    }
  }
};

// node_modules/@hashgraph/sdk/src/address_book/IPv4Address.js
var IPv4Address = class {
  constructor(props = {}) {
    this._network = null;
    if (props.network != null) {
      this.setNetwork(props.network);
    }
    this._host = null;
    if (props.host != null) {
      this.setHost(props.host);
    }
  }
  get newtork() {
    return this._network;
  }
  setNetwork(part) {
    this._network = part;
    return this;
  }
  get host() {
    return this._host;
  }
  setHost(part) {
    this._host = part;
    return this;
  }
  static _fromProtobuf(bytes2) {
    return new IPv4Address({
      network: new IPv4AddressPart().setLeft(bytes2[0]).setRight(bytes2[1]),
      host: new IPv4AddressPart().setLeft(bytes2[2]).setRight(bytes2[3])
    });
  }
  _toProtobuf() {
    return Uint8Array.of(this._network != null && this._network._left != null ? this._network._left : 0, this._network != null && this._network.right != null ? this._network.right : 0, this._host != null && this._host.left != null ? this._host.left : 0, this._host != null && this._host.right != null ? this._host.right : 0);
  }
  toString() {
    if (this._network != null && this._host != null) {
      return `${this._network.toString()}.${this._host.toString()}`;
    } else {
      return "";
    }
  }
};

// node_modules/@hashgraph/sdk/src/address_book/Endpoint.js
var EndPoint = class {
  constructor(props = {}) {
    this._address = null;
    if (props.address != null) {
      this.setAddress(props.address);
    }
    this._port = null;
    if (props.port != null) {
      this.setPort(props.port);
    }
  }
  get address() {
    return this.address;
  }
  setAddress(address) {
    this._address = address;
    return this;
  }
  get port() {
    return this._port;
  }
  setPort(port) {
    this._port = port;
    return this;
  }
  static _fromProtobuf(endpoint) {
    return new EndPoint({
      address: endpoint.ipAddressV4 != null ? IPv4Address._fromProtobuf(endpoint.ipAddressV4) : void 0,
      port: endpoint.port != null ? endpoint.port : void 0
    });
  }
  _toProtobuf() {
    return {
      ipAddressV4: this._address != null ? this._address._toProtobuf() : null,
      port: this._port
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    return {
      address: this._address != null ? this._address.toString() : null,
      port: this._port != null ? this._port.toString() : null
    };
  }
};

// node_modules/@hashgraph/sdk/src/address_book/NodeAddress.js
var NodeAddress = class {
  constructor(props = {}) {
    this._publicKey = null;
    if (props.publicKey != null) {
      this.setPublicKey(props.publicKey);
    }
    this._nodeId = null;
    if (props.nodeId != null) {
      this.setNodeId(props.nodeId);
    }
    this._accountId = null;
    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    this._certHash = null;
    if (props.certHash != null) {
      this.setCertHash(props.certHash);
    }
    this._addresses = [];
    if (props.addresses != null) {
      this.setAddresses(props.addresses);
    }
    this._description = null;
    if (props.description != null) {
      this.setDescription(props.description);
    }
    this._stake = null;
    if (props.stake != null) {
      this.setStake(props.stake);
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  setPublicKey(publicKey) {
    this._publicKey = publicKey;
    return this;
  }
  get nodeId() {
    return this._nodeId;
  }
  setNodeId(nodeId) {
    this._nodeId = nodeId;
    return this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? AccountId.fromString(accountId) : accountId.clone();
    return this;
  }
  get certHash() {
    return this._certHash;
  }
  setCertHash(certHash) {
    this._certHash = certHash;
    return this;
  }
  get addresses() {
    return this._addresses;
  }
  setAddresses(addresses) {
    this._addresses = addresses;
    return this;
  }
  get description() {
    return this._description;
  }
  setDescription(description) {
    this._description = description;
    return this;
  }
  get stake() {
    return this._stake;
  }
  setStake(stake) {
    this._stake = stake;
    return this;
  }
  static _fromProtobuf(nodeAddress) {
    return new NodeAddress({
      publicKey: nodeAddress.RSA_PubKey != null ? nodeAddress.RSA_PubKey : void 0,
      nodeId: nodeAddress.nodeId != null ? nodeAddress.nodeId : void 0,
      accountId: nodeAddress.nodeAccountId != null ? AccountId._fromProtobuf(nodeAddress.nodeAccountId) : void 0,
      certHash: nodeAddress.nodeCertHash != null ? nodeAddress.nodeCertHash : void 0,
      addresses: nodeAddress.serviceEndpoint != null ? nodeAddress.serviceEndpoint.map((address) => EndPoint._fromProtobuf(address)) : void 0,
      description: nodeAddress.description != null ? nodeAddress.description : void 0,
      stake: nodeAddress.stake != null ? nodeAddress.stake : void 0
    });
  }
  _toProtobuf() {
    return {
      RSA_PubKey: this._publicKey,
      nodeId: this._nodeId,
      nodeAccountId: this._accountId != null ? this._accountId._toProtobuf() : null,
      nodeCertHash: this._certHash,
      serviceEndpoint: this._addresses.map((address) => address._toProtobuf()),
      description: this._description,
      stake: this._stake
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    return {
      publicKey: this._publicKey,
      nodeId: this._nodeId != null ? this._nodeId.toString() : null,
      accountId: this._accountId != null ? this._accountId.toString() : null,
      certHash: this._certHash != null ? decode6(this._certHash) : null,
      addresses: this._addresses.map((address) => address.toJSON()),
      description: this._description,
      stake: this._stake != null ? this._stake.toString() : null
    };
  }
};

// node_modules/@hashgraph/sdk/src/address_book/NodeAddressBook.js
var NodeAddressBook = class {
  constructor(props = {}) {
    this._nodeAddresses = [];
    if (props.nodeAddresses != null) {
      this.setNodeAddresses(props.nodeAddresses);
    }
  }
  get nodeAddresses() {
    return this._nodeAddresses;
  }
  setNodeAddresses(nodeAddresses) {
    this._nodeAddresses = nodeAddresses;
    return this;
  }
  static _fromProtobuf(nodeAddressBook) {
    return new NodeAddressBook({
      nodeAddresses: nodeAddressBook.nodeAddress != null ? nodeAddressBook.nodeAddress.map((nodeAddress) => NodeAddress._fromProtobuf(nodeAddress)) : void 0
    });
  }
  _toProtobuf() {
    return {
      nodeAddress: this._nodeAddresses.map((nodeAddress) => nodeAddress._toProtobuf())
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    return {
      nodeAddresses: this._nodeAddresses.map((nodeAddress) => nodeAddress.toJSON())
    };
  }
};

// node_modules/@hashgraph/sdk/src/address_book/AddressBooks.js
var proto18 = __toModule(require_lib());
var PREVIEWNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(proto18.NodeAddressBook.decode(decode5("0ad0070a0e33352e3233312e3230382e31343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340acf070a0d332e3231312e3234382e31373210a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ace070a0c34302e3132312e36342e343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ad1070a0d33352e3139392e31352e31373710a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad1070a0d332e3133332e3231332e31343610a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad0070a0c34302e37302e31312e32303210a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad2070a0e33352e3232352e3230312e31393510a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d35322e31352e3130352e31333010a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d3130342e34332e3234382e363310a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad2070a0e33352e3234372e3130392e31333510a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b35342e3234312e33382e3110a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b31332e38382e32322e343710a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330ad0070a0c33352e3233352e36352e353110a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d35342e3137372e35312e31323710a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad0070a0c31332e36342e3137302e343010a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d33342e3130362e3234372e363510a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33352e38332e38392e31373110a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad1070a0d31332e37382e3233322e31393210a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33342e3132352e32332e343910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390acf070a0b35302e31382e31372e393310a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390ad1070a0d32302e3135302e3133362e383910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a60363465303938363135626634303566376564356134303133343436623839633438386366636436626232356134613637366463373765656131316433336437303236383266306136396138303330653863353737376430653432323033373939")));
var TESTNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(proto18.NodeAddressBook.decode(decode5("0a7f0a0c33342e39342e3130362e363110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a80010a0d35302e31382e3133322e32313110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a81010a0e3133382e39312e3134322e32313910a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a82010a0d33352e3233372e3131392e353510a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a7f0a0a332e3231322e362e313310a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d35322e3136382e37362e32343110a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d33352e3234352e32372e31393310a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a80010a0b35322e32302e31382e383610a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a81010a0c34302e37392e38332e31323410a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a82010a0d33342e38332e3131322e31313610a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35342e37302e3139322e333310a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35322e3138332e34352e363510a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a80010a0b33342e39342e3136302e3410a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e35342e3137362e3139392e31303910a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a82010a0d31332e36342e3138312e31333610a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e33342e3130362e3130322e32313810a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a82010a0d33352e3135352e34392e31343710a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a81010a0c31332e37382e3233382e333210a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a83010a0e33342e3133332e3139372e32333010a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e31342e3235322e32303710a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e3136352e31372e32333110a388031a05302e302e392806320218093a60363938333261373361333630326538643166626535616435386431633236333761316236373264373165653837616631306462363438656239316166623232383235336231663437653537643364346134346666353437623333393461613232")));
var MAINNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(proto18.NodeAddressBook.decode(decode5("0ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633435363165336332373863643635306538306334313363613434343233633163336331336366313437356636663639373664353937616534333262343961623432303836623739623834313332363035346238623364636635376438666364373962666330353831383363613234636434633163626335373465643131313765326635623762336336336365376230366439623465666366373337353633376234316665366635336338313162396465363134336633613532393537636466393536373735313230623333373033666635373632313430376162393537356263326433356330643434663039383366633165663633613466663532303966303730633932616631303632393536303163393662636564303634656331393031393730313963363831316334633864643830636234663461633731663961643736653761633839343536666266346630313166393061626432643930353336653832333436353166366265663932376533643564386237626634353930353039383362656361336162656632613964393761663334353737326137373430653936393932373562303138656130646632383661646436636539323365663930386662653736326137356632313131363836326462343464336463613164343462346432653864633130363663353030366262356137643935346164323535643462363033323733343735653531316165623438356430363961303637633061623563323435333863393333633036623561366165666139343030356332393135323133653463636461653663393432663632373266396464353238326436623839306631663230656664323339396364363734393234666135373034366163366461333265373339353161373331313365393166633262376666323965343835316238336666333966383362613965633666303863656664626236636262626666616266646661613931643933306637323030646134383133376333393463626431336537303165636463323631366664323162616436383161613466303031303230333031303030312804320218073a603665396138616263646364653665313134396133656265313766643538643839303538333961383664623732623036613365613230616131373666383638623235343838353261653432336437613963366237636666396537313436323961320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613163343037373135343330336363373263346662373639326333663934323531626465633132333961316637613839373261626539316133353332336662656361363235613766666165363430366338353564633261663231313039303062306466306536653664623736333634646661316666653835656461353637393336653239383562383536333461333261613532613635393964643663333062653166376136633562386635656563616632363231643861343539363832666364326462616164313536316431316633336663636237663535303061633536386431363564626561616365333238366432383934663634313239643738316436633732666437643539396339653164336166346161343333633233623931306661653463343834313634316636313532366164373837656265613533393837343136376539643361373363633066623135363432396431356563373633613664306630363131356137396239616637383364373762393864383330393661613437343366393734303864396531346263663464646666653435393137363838343762343063623864613763613337353235366432623933356430393566653235326661653831666636653337663834643761393064376535373061346638656633633764373636656564613437326630393230313939303135613839303832353961383733633534353466636262646361643265353238646538353435356234303833633764633461646335613938386530636464666463313539643564373132616264353434616137336563303239303839383134633938613434663236666330363434363539633138336533313834616132373266386431646330626661336530613536303438346362303535626134646262356363333339656338306264313164363432646333613730326538633730336162323139333038346439626436336630646665313261343333633235373665616637383163666164383637656637306264613631373638623262656631346635306336633362386230393666303230333031303030312805320218083a606464336233653763643361323537643832373665343635333533363162303138623730303931663438363635653832303031306538316563303539326236396264346265316662643765636435303964303730313364643034313238343266640ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623263636163363561643066633736343561383137626661626334383761643765343133313165376133313938623337666238343264383463333935623366363764366264383438663130633666303363323930653866376461613864303031613834343164633335326131393136306133313933653638623832656466313961653637363933613961333364346362383765373839613130373037313535313565613737326361613862383661353639623931633534353038333564396333353466306461636563393766653737303931623435623134373639386237663836303134323264636432323631653932386465346461633963343264636261666466393663303732333362613330323730373666333763393639653865643330623662356438663530333462653764393263353936663862653836316535316663633361323432626639643862653965326139653865306631353565626366663233656666613763643537633130353432383131643830373736633935383535323666646230656161333465653139353564353131313933393066653837336534633034646564643239313635383834623938623436333038373838616537666334643461613461386663396263323637346261333231343933623632343435356164343130633164653731626339356431643931666130663230313431386137393565333039656166323937623639396266323763396661323736336364353963656230323165313662383230306331303630663238313766643833636663373637313833343839343631653335393932393162333830643665393339626161346231393233326136613237326464653635316638303436666463333464623237366137373764366662326265633332353562326363323434623461663536366231303566333063363530366464616530656233646564646366393437626362396336306530303039383466336234613863366334656434626639306263313933326237663934646333616536623336303030386562393032303430663962303230333031303030312802320218053a603561383634313561303861306138323566336232656237353031303135353230326533313234336665343161303333333834653738633138633131653565386632303964343933623062326664343565303662333734663262363964663564370ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613365333762373663366364356636363232643639323434343464313263363737633339356632623539303266336262393862386138623530353561373037373036636130323863643735303630613264383730326432643862303439343762646366653061386331343161613238343462316530366536363139303031326538623633323661623066613331373937336263376362346432393439663231303861613034633462306339316261613537323866356235363232656337356162663537386131663762343165646532613637656264363963313865353831666466396336303230616330646539636132633331663063363436393030333331316662623563653764623439633738376531613764323761613432356565376238346461376536363933396639633830643065383266636535356530326466633862356337383431386132366161343336353036393837313962616663656366306264343930303061646463666134303537303862646265666262313937343964323264616230303765343464343565613233623130366638383334633135326532353036326434636632346666323533353663376562333732393130353339336662343962616239303461303266306630626234313763643931396433353238393031323865366262666634666163396639306465313138613937346632613664643031653033326137396231373866363066613166636262643032623537303466623436323935633135313930383136333733656464363633356338353639373866316239353033663166373362346230626538616261326564316665656164353939353362663832656664653933613334373161626435356364613362613861363733666262333739393734396662303036643030336630653633663636356333343631643261376232396463386232303462613539613635363638613436616532383738663030643166393439306466396532383066656266343331356561303465616135363861336139666434386336326336336236656364613639303230333031303030312803320218063a606434363430333938303337393230373965636364356134343331316361306463323262353065633839356235366535336431326232396637326463366462613363616665326535623831303466626461303338616635623434376430666231320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393361323135636334613761373232636165396331336162643633366466393963636565633661663964623436623639666135313637313665663530636532343930613938316530396162303139636132636234363831316235623631396431626431643565653666343661343263373737636264656536343261313438346563646635646464333732393634326333386336643433613838353838373434373566353832343434333636346330346466656439623839303435666230383565323563336566636234383431373333656666376335323963313339653639333530633263643739623263386431393637396137313265346538636166643332363735343162383332623365313061303132353564656636396466316539643362386438656166303331316465363764356531326232366464303164626264396433653432643335643964653237313330326530663166363964383763626337616361396538383637653964343238643363616230363636656234393064356662616233306266663366373835643033663230373261343362623962356535343635366135393263623631656166643561356566323834633763616563363666376634373332356363306434633164323766363631643861373438636135303731633036656631333464666639366634303836363838333636643436386132343738303031376530623536616261376661623433623362376330623737393036666165353438326633323831316332393265366231343435346531346238393438303161383661303363633437373934646430643734353237613732653432346564336166613034383939656362396136336632613961653732626537666139383961646630643635613332633835316439383031666334313034386466333335363466633762333137303765633866623830313430666537623761316661313230626131636236363033323463656666623462636332643962623764653063663534633831396632646433626365616465633963323566356531396463396231303230333031303030312806320218093a603365303261363732306334343636353965383633303564353562666565383230623335653635306665636163633535333039373435356532633465303332636339646564313662316262343464336235393262626163623663326266663165360ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303930323539663465336439663066333934323536353438653963373330386231306237333430336363393039346439376164313531623737303631373062393737326365623634643636326563656639303161386437643135643331396135396338623731303731616363643839356237633933363130646336393736663637633465313732396261383337336162376535326133663363386632363534393164646536396436653039393934373065373434353938313133316264393663333665363836353230336662326562643564353065616461666237323633393664656331643931373438393862346539626530346337346433303466656164643963626433323334633362376633333036633939636230633333396663323539363962343164353861326237636663313833326532323664383163313936333939336532323535613038376431363938633033643432313062643634353830363434643039356361373661613137393465646434306331633837623566383261386533396636303365393731313662613034353738653765383033343634393564373835643465663763663737313462396562366635663965306239613934663462373338383436313962393237346434613935656631353735346138396439376566356331613838623664363933653061383065626435333766633963663063613931643163363264393135646537656438313862393532653634633230303239336565386532383461343136613732613365313266633764343233623135386639623439363630636263323436366662656430666564326532346531303266646539343265623463666439346265633436643364393066633038633339666563626130336530636132343634616536363462393739353135626132396531663730326333666537303262653739333739366438656462313761613438633039323930623032343534396630363131663561653233656437653136343432646637643164616432323836633262623039643535323264643365643639386332663032303330313030303128093202180c3a606339373462623938326338313931336237333236643561336639646363343836313261313566376161643032663230376230663130636432303137613666626666353830336537636139626662343730396162323862366230396435623133660ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303962646438653834666164616133353332666334636530316138613137643463336232333266353061393739306532363236383465646334383233653831356131626435623230656365613762663536653239663662623762383331666233626636656663643134373566306238656435666662306231333835623936643136366236323966303339366138666566356630366534626361323565653461313334306565323633613464396262303230643866343732333036663364383836313338646537613031396530353962643061666339303263636261316132313361653264616136306338613031333735356665306134386530333466356234303233613264616465616138386335343836383335336163376137613364663132623266623634313837373465396231346265366561623863633237623838303132616436313632646137346530656562313631333539303566343337333734646162383538366437353061323662626433616332346165643837386334643533653635313037326338373165393464376163633537356339363733383137333461353366656166346437626136626364643234316363363435386336303837643836333032616132353163303466366435366239633332643764393636323437353065643035353738356430373733663433646330393962323863393232383131343865366338316632393766663964313636653030306163303462333132343138363737356663656637356635656261306331303332626631333064663663643761343632313164306466336530353834643932656136373334396438343930353038656234656638386635346338633364343836646538373139663130666139366665623835636337393630373663613738313331386565326439656439303363613133333630343063353961643931613464326636393865393130386165306564623962316362393561643333623139376666623138626431626138623536636265653261616539353835656365323038613165313462343835363436333032303330313030303128083202180b3a603937303834333033333130373866353638326337663332343464383263336233653238316139313837393537386465656163646363326132656265353431616631383831313561643265383338363565356635643234376234613138633165650ab50722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039303938383635646566326632616233373663376630663733386331643837613237616330316166643030383632306333356362366562666362623063333330303331393361333838633334366433303233313732373031323139336262373666643330303462383634333132633638396566353231336362623930313130313530396465616239346632366137333265363337393239646134633463623332353137653361646262333831316435306163346337376331666365386236353136303632313566333437303766336537323635353435653538633839343630396532383337366264623737373566653330343339653065313539326664636230633365653163333035373733643037326136623839353765616663653161313162653936356564616666333834333336366362366134346563323561383930313036653632343735363766373662353530666461343832626165633633303764363938656338383834316664363666323366323130653437623861396463626136626134653166613731366462333363383065333038313934393664636235653536303966623665376336313533373962646465643432376539323331623932353463326261663934333630386138366436393861653961336338363339646638383764366636623561373133383564323433333864393131613231326266373166316532616363386231383662393665633865363963383662366430353832313737373661303963396336383935336564623539313635373862356132363362326634363965336230633037656164613731613434376565613766386663316262383037343235353536376237663062643165366166623033353837313863393862343239653234623232393835393666633736636636616633393663613934333464373932366563376433376434623932616635366434356665666638313936303935323234613931366331666665366236363765323535666333616338636363656639323064633034346232353030333133326238373830363734326630323033303130303031320218033a603333373339306438666561313434616663313265383132353461323864616336656138323839333833366163303732656666643835653061373734383538306566323830393636343863356137663864626234636538313437363831353133370ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130306335376564623966663237366530323362323830323163623164383763646631393636623639386366343865346561616137633639323037376365656538636362323339613463393231353937653865383966376363303564336633313331353738393736633465333134343035643461346530336137323431306335633039636135323761643561383562393938363337653732613332653166626330643535343662323436356539653830366332646435303965623035306162356662323730363366643932383135623164643236383965323131316361656236663534396539346139663030663038323164346361366336613631313766356135333363393236336266303734613330643563626566353064316338633233383762636139373265646564613039383362356430613662353764636230303230303036383238623430653430373662343837306232346261643834303536656535326235663432326538383430303238633235303036333832643865396336363132323566346637366561373265333430363037653966633666336332303433333037366131636138636231356564303361633839363664303530376263646536383165346530323331656539663837643131316537623438616338663934643264383432623532646637336635373363633534313439363437393763363236393638666661653734313866336236313039623561306630396533323233663461346435653335303964643235303133386636626331376266366365636531373539343433306466313830613338653930616466326166666266616430633662386331623837663137386130363164636662666638623932633931363664383734633166663561663466626364626665386539643039393337306464663630626537343736333364333665653465623563643531663665336333333965313531653431626462356135636532633863393761306134336233636434636330383138383463383739663964326633373438343238633835373366313763393066336362643032303330313030303128073202180a3a603734306166366266373339653838336338386633333434633961306638623330316533396463393831633531363365306465326133666634326239396534323665643765353662363766343231383530333834356466363266343963396662300ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393133316161333638663933343532323966393762363235396363636166666561323365303063643565616430326533663639366331653731346565333933396461643836306533386266393561323937346639656234386539333433663861616334303565613935356430353332336531313762336231633934383133613361663432666538303832633364343362616631626434643833363765393364623030616436393665363237613130333661653533346630313165616435653536663337613666666534346236623965303939343031313932616435363061303334366234316138313030393566356632643766643332643665656236353562613735386336623532366331323933383661663731393763376135336165363033643632323833323235343936316631366430656661383037396137363835363138383862653733333439323231373935366262636166616562623631333563356662623234383464356234613566646630333336616330326532366331363532633162643865616633306461653164366433656230306637623466616238643634373866653864393565623931316466393636613064656134653532326462373662383936363537306563633561663039353136343234663061663566386565363665333836643536353037313339393731363961633337353733626635326664303538646539356162326666363865363831313161623233343035656139363462326262383864303263306631636165643731656364643465346534303835393438373666646238353030626335356337626130323036366530356162393864396637653034363664393730326562353765653337323266386663633835613735353035666633323632313730323838623738383732336164623937653464653536323063633930656164313338326663643735373138383966656662313165363737316263336636663366656231396337616335343238373864303361393032373035323663336565643234393465666635346531353363613966363839303230333031303030312801320218043a603765616236393661623935343336363538626331346666366234626534643932356364353162323230646632613164356336656531363061646166323961353165363934646533656531383463653232656164386437646239333231383266330ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038326465373330363566333466666332393334306435393439643232323062316534333636656435636637633665626436313663663934313661353365613030313766366262313136626664336633646566636331356237613464646630653434643032666536393536383830353365373961373730653230316263663731393333393030333965653866303836643466613734366337653035363931383330316639623565383465333932363238323830383561373962333232626361306235643835666539373232316132366262646532353863363230663064636561303261623165646431366363343961336632616239323838653364643166333764633462366136663731333366663932653534316337316237306432613266363664353537323561623138626638366430303965633364323466356431326530623565363830326431313531333732643462373634656265636234616638326636343934383565633537623561303164633637393538663561303363636161623763626139333534613137333732633133313662613437633935336161663934393031623366386332346536613361666436373538653766336231343363653264643363623037316232613734633932316365653934396134623561366265383739663163373930613662386436336231393264376565323961393439316664643638396139386330613763336436303332306631623461633264363232396466643934653432663361363034386137366265316562393538633861313837336265386433333861656339666335396162376633373632363738393430326331666435393566313930383735373565306265383237666334633061346662336433393361643734613934396363393836626662363463616264646165353339333566366463353630373464623933643737656133623831366264643662653533343439373237323238393835396666333463653531383630616666623632316431303438376463333834336631663836643534303334613633653438613161306430323033303130303031280a3202180d3a606132656363316232616539386264323862633161303864386633373161306434663734356337363864306337373339363235363265333433623235643833343235656565613765663865613134323935333432623865623738643332656333660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039383735356134303862353332316532363330353230303064366437643461326333613535346435653133383461396362356562663437346165383832633633623438366264303864313434646466316139346365396137643632353139363330303661666461616334353838343666313736343031393566653235333961363536393330656661383534663231343865363865633161303863316334396432303063336633303435666537313437663036643533346334626432363231303063623164643339373339643736306438316130626432306638336632353564323530376434636362313130366235333631386336613934343039633838376361653236326434636565396338363233323134376365633134303465306335376262613733313731333065653339363433383838616633643539386564643832623863363165363561653831613465316135366263303664333937313433613938643431636138376433656634333365663061656162363830313139316233653338343830393638663636623665383836363261663435613965323132393934663638623238386562393637626562393834373863323433653231333663316131353931663036316635626330346232316666326261343862323966313834333130383838373362646665393966386135326539343038393731383536653830346465613630326133313137383663393835363532393633633361333737303332396234303966373466646663373436623232613566383431383931323037316334636538343663396234623332306665646636653962363465326362653338346639613832623661616164346232303930373433316466316133336636393230376135363536303062653831303730643038333239303039393538353961343439386435623539333135626365626566656538303765623061336139343266316364663333363764643434343466646232393838366566636464306265346162653961313838383033393533383735656461333364623732393839663736336230323033303130303031280b3202180e3a603139366237623132303739376364623361396430303362393833643537646131303331303662313733306531376636376532633762616161646234333738396166313639366461313031316232353362636263383630333333383566303332380ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061396462376638626161313236383938666162373839313135613362356438393734346631393765323830343161653039386633653838366336393837313732316531316262306164313166336365393132346161393631643661306463383435663439373635633366616231393935383430323637366635363434363262663238316462613535383837383066303365393035373938653138343236396161613630663761313437323333316532666231646561646438373763383463626362363431636139653563386164366534356263313539636230373966636230643434396364636438643932333963316130343765376234343864613063646361323636313061323566323936643936653734363962363736643461343434353136653761353965383532393361383038366638343063303532383534653032613863623230303264616433353832356265346438336235326661393165386337336666303439373436313438383632373837633131313866393234643331636261633162343466656666323264343336623339373965616466396234336134626661373265313562343735356663616232363065303661323739633362623733626337663136613036306434643532326664343930353830333838616135393564383034343733366535323266363432343931356637383033623735383365303935636466373863333235313936393764653831623839666235303035343735336231613137663961616662303634643834633939326639616231316363626338636231303831346463616635323634616134356632316264656661633832636361636161663335386533313337336565316261346537343032666438613730656130633238636135636337346463343235313063393639636432633435396231656333363838613031656133396139393237313063643232393763393861383462363334386135373738303466646332333464336665313930336532633231653137326461323862353961653665346337653865646438623731633439643730323033303130303031280c3202180f3a603538343661353366343437353239666439636462373830346364333136383865643665656265336236336461326635663231316666626337333731393763663366316366626664613631626537643135313066306539323339383131376637340ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061386365616333363765623166316465356630643965663365616630646639623938343438666532303830383437363536326130363063353163323839373730623463616366653932636236353536393832336539363263326132633966656435336264333663613361313232646531633532356135383266323561346437643632386331613364356264623839333661656365373531306537353534656537303333303235633039326338323865656235373338626530326564393633646138316135393230353633346365393435343537376162383266343066313366316565353565306165373237653233633330323834623166343462393961636534646463356639616337616438386439666132323535393335623234646362613834303036343265313663663235333263306230643638393239303436303837313563343037366634366438346130653066656433366537366363646339363335356537613236313630393435633262353461653236636330306664303832333236333436656565656137646437356639313931316539396462636239396561346163366261303536633333323238643838316438353833316439636338373935393364613137343664643065653935646332623936666539336261666366663263643764393239353864373864663333663230356437313135656439666163346462366634636336306535366135343431646135623562353566613539393939303265393538613662366334346438313064646335363138313234316238376632326630353961363838306538303231373336643031383937646236353434396365383137613233373564303335353163623064653530376336303961306338303330656366346266646562323133633033646161373634613138323162373234333334663731663736386437616563623237373035326137303333373635663037323138303536633738663261383761663138333836643866363161356366636233663262613464643539393135663133643338363334643136393537353730323033303130303031280d320218103a603030306162636435396133306135333838633530306265363832663663613239343034363239356339323735383831633230643334626230643639306564613762333862366262643037613364643166646662366137303434626230396366660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061663062393134323537626637613436353563346135306430636164356530613165343538316564363632336630653837333066373936623866323963353831373862636363363933326331666333316633396566343462383264336334336233393837333733373366656362313239353232386130346664353061313466333634366438346665316634363763616562393864343633653239373565393935623864326531653339663362663661646463323561653335643635643032363038653033343535333739363665326162636534396238313462656164336331623735373137346165333063303062306334336539396238303439366237326433633133316631633665346663646130356632383131376566396532386334333033626534643863376530343264353862383363633132313934356132633635653739363263616139313835393338663337353764663763636139356366303262356533313934346133613631396130616333663165333462396230313364346332323463346631653730666439666433363938336566383661646535313833363263633833323263306637623631613961633735666238326537623836643638626330663039396130396131346361633561316438643338663961386137306363333766663563633362626432373432666664313436323535633137316536613137383038333237316463653066646536383165643439326362353962303739366432373031373538333864633539303831303765336136656133663961343036623364313133306363656333623437393165343962626332333136303362343661623264306639336434336265373561623961346437313065613934306532383561376231353362306361376364646565366439646365306164383335306334316439306332313562393538383531356166613061633333363561653037653831663362626233366264626561633462333162636231616134653832353635623937376639646164383564363236656566396161613965663864376533666230323033303130303031280e320218113a603933653238313031303462326231376230303935326235613431303264333365646230343363623136646533616433643364363832363066353562623065353837333765613539343463333338663763386362383863373833336663383630630ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038633037626533303561643630623930626132646162333962306565373736306531613232663835373532323534306437306230336233663965343837356133613239616230383038386631343466353765623235326534366261353933383564306536643432373031313764613061626331623362383036393463396135303538623836643631646661303665373136373039633838653866656163376333613065316432356663306165626636613866373666636239396638343566653138313436316361623638353862393763336134303237666233373132623134653663303738396465313764343137363435373765353131343137656231363236393265623037616531653733353532333565396262343339303437623663303136313337383265376464366636303464616134363734363631643533393631663436633366616136623765373637363264333733623562353432623739656139363365666266333361633638313938626232623636316366663637363931366566333732616434633236633231366334626334373837633834656333326431383464373763373531383663303963663364396639313433336361393835333131396261623331666136616432366634353365353936643962646563613638613537363962633866656537613533356438306338633666336566623164666232383861623661393739383534623763653833313234656330643130326166663934633362373466396333373839353863323565623933336464353363316538303561313836353464366439313836393930663635373034323966393630663334653862346637666439393732646362666539323430653037346461326433353561356637656639633161663632656635393832613831373435373862396331356334396563353636626461636233306363666365663039636466653730386164343837343234653963316265363533663965653736363065376439343263316566613564613238366531616464616230366139613333663964653934363739356230323033303130303031280f320218123a603934383235313739643163333934303137306233356432363665346366613830643737386335653966356261653764653833666638636334373431663362653336616336336431653761653439373261656466366263316533636632303638390ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030626531376339393634376365633635613434343037623533353835366233633362616566356235346635363561663538623834353662613863376365353335643561633732633631633434633736623363353763386538363438343136333762653130613833636665333963303932343736643064626534643663646364636437323061333062356266656235316130316131386635383263343566366338363939336663663764663138323933356465316438363930363034346463663335313836393335643962643765656137393532333532626562623465663961653066373636316537306134323337616661393839393636383763613438666366633562303064333830376630353462653066613863336266613432353033386265366566323935313634663232663733623765383863393465613962653861613466336132343563383962396431666435313932663761353062393538623265663831303462333666316266386664326366623238633134323138303063316334376534656639386166313530303730636336643639643137653865623932663138613661613161363532363661343935323338643130336638663639356235376563663337333635306130353230303837343537323162656138313536323739363763383037363336356466386334633761376434646438663263333835306331386662613731656236306536653864666264313936653035333766643730623334346563626363353330646663383364613666656466343964353161393034313935303262613964373063643335663163663363303639346532333534663930363466646266353335656232336332376330613433643062373863316638363763363164393836393564386465663762633261313062623636373463323266363661616230613931383133646466323763646238353263353965663739653162396531613037356661366565323761376533373734646266346232363436353432376536643561623931666537663066336137313738346563613138326235303230333031303030312810320218133a603038393039376465663031623037633764393734613537353532353161366161613061666236623332613534353334336432393138653732626164303433323163313131633234643432373538306633626131653236616139643735653632360ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613561643262373634336130346330353564326638636432353131623135313339666334353537353632313338386534396331313962326633393861636131313066363133393662306338363664653530363335323262623835343032373365313366366439346365316536303433386636616662303061616136343631326637313435653962636538626331613533623934313931336161373663396633613238333366616437636632383563376163326433376639396633633263646234396465346431353165363136373835363466323831663534313432346234316661376335316232613936303232383363376433326565303065623833386461313563333861666339366530363164393763656465323231363566663161613935396631633432373562326430393863343035383661353537396662623363623930303732373034313230613861363661353237306634666366643130383663393233363930613335653766643434356533336163303366313339633638363835353635373063646334616166323231303761366331613434323435366137633663373965653034303930653765356434663636626361363063613166343762366466623534336461633363626631396137373139613866353562366638336234613362386136366436303235366430613436353531666137303234626430353633316238613535383038373732353463326632663236386364633333643264626263666237333365396662653233336262396362353961623331613031343862323365386334323638306666313061663463373961346430383334366662373961393364393632393534386561663162623132343639386661656661346364643732343432633033613034623733333433326637343839303361333235633238336434353661623961653932316165376564333339316535643137383765666463323335343061376238356336393161653837306130376639306231316331336233326365343365616564313562333639363835636534393137376363393835303230333031303030312811320218143a603939666162633461646534653636326336653238323366346139366562323134343034383465356136643064333132623730633036386432326236323936333830376332333361343964626239383361376562623330653737303637373261340ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030386434356332316330633935656636356130323964353263393537666430663835663230313233646130333465363136373164646565353437356630373338326136366336366362346463353035303464646664333735383130383364663864313735373733306564386436663336346466346333366132363531353931393535646132303161323430376661386162396232333133383131323235613064613233306662653338306530393061613536656661346632303265633962343832336636353031643936616336393865626632366161636633656532643166333261373231633934376531303736636633356233373364613164383761333661313532653030653731303131373932323832653832356666313731633538333362383835373062666336646138343439653666393566386231323635616235353531393430333135353364316435373666393363343263306361363061616261633463386464313632643831313466326232313531313538336337323533396665353663343939613932396465336134306130643435633137633538396332643739383863653236656166633932613364333762376561303034326434336530336166613632373162323632353561366363636661653533373138323164383165306230356332353062353966306139303734316130653065383861303965643536633562393738306430393566303930366630623831643531323633393832616165303131333663303732643834346131316436646134623261363163363434653161623137663136666634386565323366656465383435326631653432653264333061303739306332356434323036306531643434613637316132656232336431313466363863373165333366313736646235386136386234333030353462633164323938336132336133326561366666393566613763346438653338306562323936653938623739363865636638343534643831376337333765656135646439323165623836633136633762323933303461346137656362653561336131303230333031303030312812320218153a606537396165396337313933643164326263393433383436346338616135663632323461653835323936366134336239383235383833663766373432633533393562643330393935383761393638363662393233396431656666336165353037610ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623035616265326162303066646430366339353565383637313062306530366631613932363234613438616431636263386466633666323231323936326230633330666462643238346133376335613337363538623633633336656138313632353631613865346639343663626535373232633032383830316630663238316337306638643838633763303061326632653239663539376237393938363965643833353664663537633437626539393434613261616666363530663962346262613064626335336463383830666462623639656134353139303564323830323230326638653239633034613736643237616632656237633534383438356266336634363934633930633431383130383838383433373932383438383335663738313637303764336538643736663465363766353738306263663038383133633535656336333961396264363234313738663565623134376435303061663335316539656631623165333432343834636132363064623763636261653438366631336366323635623562316162363838303636303038303533623230633364656463653737316339613038613033323061613963653435316562396439383361376234396361613130393666386164633039383331386463333865306537636566306438653564353537613036373536383561316339653235366132626339646261333232623362623331373263663731343037376263333830663861306134333361386266613766626663353966366230393365633862663665393339376330396231386531383034306331623536363836343733376338666137653239373935663361343538386464613763326261623439353636356363346139623833366532656239306336326133666361663539316662356638313830346337363138306536323666613236343461376465333435313164366334363637643938393337653237373333663464316539313338383333353465353466643733353137323165373666376235366333343833333838663461366238376232386165626562303230333031303030312813320218163a603962343038383566313362366163316337353336393262613366313739303061333838333165363934613061663937343934623834333838323039636235656662646339386136646162623265316337313833393166633133356264616163330ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396463643863306135336539306333353539353734663636323034313137643362353033653530613336643330393766616338343239653663656364333762623534303731383038663265653938323033356638353161306339626532313736333833613232653338633161626131363866333266393035373063623332333363666536323539383736363661663637623531346361656632316662386466366430666364333363663236303662393264646561353533366236303638643836373832653339626435633338343435393931643431396237643165633038353939343132633039343964316332343062333563313464633535323734646261373166666165393336313235613566383139663534313332653234333964346163353539373939366563653835653133646666333336316639313331663536636561633562396635353262343963663666396139616336653564636532646233363934363266393361663830653562353662366538626566613136326130363162346137363839326264633834363437333036633630303835386664643237303332373663326337303434303139386566643766653335343563663261623538306337346366643634343561616637626437663734356363323532656162643236356561626565383632343137313034653639343861353537353666646332323264663061313031353234646531633363303863636630343330313165633766653936346564643834353161313330313437633037333633613335663131666465656638663261326237363137353762343335386666383962373561343864363762646336303930363933653062623836373965636262393366666462336633656439366265633933656634363536653337313661623837636534366361386531323539633866656464653866326631656130663365623263343865393635353164653132333330333435373235663435656436396338353735623531363833616661343732363231383236646232326262326431633466316533363436346139303230333031303030312814320218173a60346630613033333466393737363738313632663830643936376637323139313431333630633062376637663033316233376336396536323137333933336564616434366263626139373636376565373262666435613933346261313532326330")));

// node_modules/@hashgraph/sdk/src/client/ManagedNetwork.js
var MangedNetwork = class {
  constructor(createNetworkChannel) {
    this._network = new Map();
    this._nodes = [];
    this._createNetworkChannel = createNetworkChannel;
    this._ledgerId = null;
    this._minBackoff = 250;
    this._maxNodeAttempts = -1;
    this._transportSecurity = false;
  }
  isTransportSecurity() {
    return this._transportSecurity;
  }
  setTransportSecurity(transportSecurity) {
    if (this._transportSecurity != transportSecurity) {
      this._network.clear();
      for (let i = 0; i < this._nodes.length; i++) {
        let node = this._nodes[i];
        node.close();
        node = transportSecurity ? node.toSecure().setCert(this._ledgerId != null ? this._ledgerId : "") : node.toInsecure();
        this._nodes[i] = node;
        const nodes = this._network.get(node.getKey()) != null ? this._network.get(node.getKey()) : [];
        nodes.push(node);
        this._network.set(node.getKey(), nodes);
      }
    }
    this._transportSecurity = transportSecurity;
    return this;
  }
  setNetworkName(networkName) {
    this._ledgerId = _ledgerIdToLedgerId(networkName);
    return this;
  }
  get networkName() {
    return this._ledgerId != null ? _ledgerIdToNetworkName(this._ledgerId) : null;
  }
  _createNodeFromNetworkEntry(entry) {
    throw new Error("not implemented");
  }
  _getNodesToRemove(network) {
    throw new Error("not implemented");
  }
  _removeDeadNodes() {
    if (this._maxNodeAttempts > 0) {
      for (let i = this._nodes.length - 1; i >= 0; i--) {
        const node = this._nodes[i];
        if (node._attempts < this._maxNodeAttempts) {
          continue;
        }
        this._closeNode(i);
      }
    }
  }
  _getNumberOfMostHealthyNodes(count) {
    this._removeDeadNodes();
    this._nodes.sort((a, b) => a.compare(b));
    for (const [, value] of this._network) {
      value.sort((a, b) => a.compare(b));
    }
    const nodes = [];
    const keys = new Set();
    for (const node of this._nodes) {
      if (keys.size >= count) {
        break;
      }
      if (!keys.has(node.getKey())) {
        nodes.push(node);
      }
    }
    return nodes;
  }
  _closeNode(i) {
    const node = this._nodes[i];
    node.close();
    this._removeNodeFromNetwork(node);
    this._nodes.splice(i, 1);
  }
  _removeNodeFromNetwork(node) {
    const network = this._network.get(node.getKey());
    for (let j = 0; j < network.length; j++) {
      if (network[j] === node) {
        network.splice(j, 1);
        break;
      }
    }
    if (network.length === 0) {
      this._network.delete(node.getKey());
    }
  }
  _setNetwork(network) {
    for (const i of this._getNodesToRemove(network)) {
      this._closeNode(i);
    }
    for (const [key, value] of network) {
      const node = this._createNodeFromNetworkEntry([key, value]);
      this._nodes.push(node);
      const network2 = this._network.has(node.getKey()) ? this._network.get(node.getKey()) : [];
      network2.push(node);
      this._network.set(node.getKey(), network2);
    }
    shuffle(this._nodes);
    for (const [, value] of this._network) {
      shuffle(value);
    }
    this._ledgerId = null;
    return this;
  }
  get maxNodeAttempts() {
    return this._maxNodeAttempts;
  }
  setMaxNodeAttempts(maxNodeAttempts) {
    this._maxNodeAttempts = maxNodeAttempts;
    return this;
  }
  get minBackoff() {
    return this._minBackoff;
  }
  setMinBackoff(minBackoff) {
    this._minBackoff = minBackoff;
    for (const node of this._nodes) {
      node.setMinBackoff(minBackoff);
    }
    return this;
  }
  getNode(key) {
    return this._network.get(key.toString())[0];
  }
  close() {
    for (const node of this._nodes) {
      node.close();
    }
    this._network.clear();
    this._nodes = [];
  }
};
function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;
  while (currentIndex !== 0) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
}

// node_modules/@hashgraph/sdk/src/client/Network.js
var Network = class extends MangedNetwork {
  constructor(createNetworkChannel) {
    super(createNetworkChannel);
    this._maxNodesPerTransaction = -1;
    this._addressBook = null;
  }
  setNetwork(network) {
    this._setNetwork(new Map(Object.entries(network).map(([key, value]) => {
      return [
        key,
        typeof value === "string" ? AccountId.fromString(value) : value
      ];
    })));
  }
  get network() {
    var n = {};
    for (const node of this._nodes) {
      n[node.address.toString()] = node.accountId;
    }
    return n;
  }
  setNetworkName(networkName) {
    super.setNetworkName(networkName);
    switch (networkName) {
      case "mainnet":
        this._addressBook = MAINNET_ADDRESS_BOOK;
        break;
      case "testnet":
        this._addressBook = TESTNET_ADDRESS_BOOK;
        break;
      case "previewnet":
        this._addressBook = PREVIEWNET_ADDRESS_BOOK;
        break;
    }
    if (this._addressBook != null) {
      for (const node of this._nodes) {
        for (const address of this._addressBook.nodeAddresses) {
          if (address.accountId != null && address.accountId.toString() === node.accountId.toString()) {
            node.setNodeAddress(address);
          }
        }
      }
    }
    return this;
  }
  get networkName() {
    return this._ledgerId != null ? _ledgerIdToNetworkName(this._ledgerId) : null;
  }
  _createNodeFromNetworkEntry(entry) {
    const accountId = typeof entry[1] === "string" ? AccountId.fromString(entry[1]) : entry[1];
    return new Node({
      newNode: {
        address: entry[0],
        accountId,
        channelInitFunction: this._createNetworkChannel
      }
    }).setMinBackoff(this._minBackoff);
  }
  _getNodesToRemove(network) {
    const indexes = [];
    for (let i = this._nodes.length - 1; i >= 0; i--) {
      const node = this._nodes[i];
      const accountId = network.get(node.address.toString());
      if (accountId == null || accountId.toString() !== node.accountId.toString()) {
        indexes.push(i);
      }
    }
    return indexes;
  }
  _checkNetworkContainsEntry(entry) {
    for (const node of this._nodes) {
      if (node.address.toString() === entry[0]) {
        return true;
      }
    }
    return false;
  }
  get maxNodesPerTransaction() {
    return this._maxNodesPerTransaction;
  }
  setMaxNodesPerTransaction(maxNodesPerTransaction) {
    this._maxNodesPerTransaction = maxNodesPerTransaction;
    return this;
  }
  get maxNodeAttempts() {
    return this._maxNodeAttempts;
  }
  setMaxNodeAttempts(maxNodeAttempts) {
    this._maxNodeAttempts = maxNodeAttempts;
    return this;
  }
  get minBackoff() {
    return this._minBackoff;
  }
  setMinBackoff(minBackoff) {
    this._minBackoff = minBackoff;
    for (const node of this._nodes) {
      node.setMinBackoff(minBackoff);
    }
    return this;
  }
  getNumberOfNodesForTransaction() {
    if (this._maxNodesPerTransaction > 0) {
      return this._maxNodesPerTransaction;
    }
    return (this._nodes.length + 3 - 1) / 3;
  }
  getNodeAccountIdsForExecute() {
    return this._getNumberOfMostHealthyNodes(this.getNumberOfNodesForTransaction()).map((node) => node.accountId);
  }
};

// node_modules/@hashgraph/sdk/src/MirrorNode.js
var MirrorNode = class extends ManagedNode {
  constructor(props = {}) {
    super(props);
  }
  getKey() {
    return this._address.toString();
  }
  toInsecure() {
    return new MirrorNode({
      cloneNode: { node: this, address: this._address.toInsecure() }
    });
  }
  toSecure() {
    return new MirrorNode({
      cloneNode: { node: this, address: this._address.toSecure() }
    });
  }
};

// node_modules/@hashgraph/sdk/src/client/MirrorNetwork.js
var MirrorNetwork = class extends MangedNetwork {
  constructor(channelInitFunction) {
    super(channelInitFunction);
  }
  setNetwork(network) {
    this._setNetwork(new Map(network.map((address) => [address, address])));
  }
  get network() {
    var n = [];
    for (const node of this._nodes) {
      n.push(node.address.toString());
    }
    return n;
  }
  _createNodeFromNetworkEntry(entry) {
    return new MirrorNode({
      newNode: {
        address: entry[1],
        channelInitFunction: this._createNetworkChannel
      }
    }).setMinBackoff(this._minBackoff);
  }
  _getNodesToRemove(network) {
    const indexes = [];
    const values = Object.values(network);
    for (let i = this._nodes.length - 1; i >= 0; i--) {
      const node = this._nodes[i];
      if (!values.includes(node.address.toString())) {
        indexes.push(i);
      }
    }
    return indexes;
  }
  getNextMirrorNode() {
    if (this._createNetworkChannel == null) {
      throw new Error("mirror network not supported on browser");
    }
    return this._getNumberOfMostHealthyNodes(1)[0];
  }
};

// node_modules/@hashgraph/sdk/src/client/Client.js
var Client = class {
  constructor(props) {
    this._mirrorNetwork = new MirrorNetwork(this._createMirrorNetworkChannel());
    this._network = new Network(this._createNetworkChannel());
    this._operator = null;
    this._maxTransactionFee = new Hbar(2);
    this._maxQueryPayment = new Hbar(1);
    if (props != null) {
      if (props.operator != null) {
        this.setOperator(props.operator.accountId, props.operator.privateKey);
      }
    }
    this._signOnDemand = false;
    this._autoValidateChecksums = false;
    this._maxAttempts = null;
    this._minBackoff = 250;
    this._maxBackoff = 8e3;
  }
  setNetworkName(networkName) {
    this._network.setNetworkName(networkName);
    return this;
  }
  get networkName() {
    return this._network.networkName;
  }
  setNetwork(network) {
    throw new Error("not implemented");
  }
  get network() {
    return this._network.network;
  }
  setMirrorNetwork(mirrorNetwork) {
    throw new Error("not implemented");
  }
  get mirrorNetwork() {
    return this._mirrorNetwork.network;
  }
  setSignOnDemand(signOnDemand) {
    this._signOnDemand = signOnDemand;
  }
  isTransportSecurity() {
    return this._network.isTransportSecurity();
  }
  setTransportSecurity(transportSecurity) {
    this._network.setTransportSecurity(transportSecurity);
    return this;
  }
  setOperator(accountId, privateKey) {
    const key = typeof privateKey === "string" ? PrivateKey2.fromString(privateKey) : privateKey;
    return this.setOperatorWith(accountId, key.publicKey, (message) => Promise.resolve(key.sign(message)));
  }
  setOperatorWith(accountId, publicKey, transactionSigner) {
    const accountId_ = accountId instanceof AccountId ? accountId : AccountId.fromString(accountId);
    if (this._network._ledgerId != null) {
      accountId_.validateChecksum(this);
    }
    this._operator = {
      transactionSigner,
      accountId: accountId_,
      publicKey: publicKey instanceof PublicKey2 ? publicKey : PublicKey2.fromString(publicKey)
    };
    return this;
  }
  setAutoValidateChecksums(value) {
    this._autoValidateChecksums = value;
    return this;
  }
  isAutoValidateChecksumsEnabled() {
    return this._autoValidateChecksums;
  }
  get operatorAccountId() {
    return this._operator != null ? this._operator.accountId : null;
  }
  get operatorPublicKey() {
    return this._operator != null ? this._operator.publicKey : null;
  }
  get maxTransactionFee() {
    return this._maxTransactionFee;
  }
  setMaxTransactionFee(maxTransactionFee) {
    this._maxTransactionFee = maxTransactionFee;
    return this;
  }
  get maxQueryPayment() {
    return this._maxQueryPayment;
  }
  setMaxQueryPayment(maxQueryPayment) {
    this._maxQueryPayment = maxQueryPayment;
    return this;
  }
  get maxAttempts() {
    return this._maxAttempts != null ? this._maxAttempts : 10;
  }
  setMaxAttempts(maxAttempts) {
    this._maxAttempts = maxAttempts;
    return this;
  }
  get maxNodeAttempts() {
    return this._network.maxNodeAttempts;
  }
  setMaxNodeAttempts(maxNodeAttempts) {
    this._network.setMaxNodeAttempts(maxNodeAttempts);
    return this;
  }
  get nodeWaitTime() {
    return this._network.minBackoff;
  }
  setNodeWaitTime(nodeWaitTime) {
    this._network.setMinBackoff(nodeWaitTime);
    return this;
  }
  get maxNodesPerTransaction() {
    return this._network.maxNodesPerTransaction;
  }
  setMaxNodesPerTransaction(maxNodesPerTransaction) {
    this._network.setMaxNodesPerTransaction(maxNodesPerTransaction);
    return this;
  }
  setMinBackoff(minBackoff) {
    if (minBackoff == null) {
      throw new Error("minBackoff cannot be null.");
    }
    if (minBackoff > this._maxBackoff) {
      throw new Error("minBackoff cannot be larger than maxBackoff.");
    }
    this._minBackoff = minBackoff;
    return this;
  }
  get minBackoff() {
    return this._minBackoff;
  }
  setMaxBackoff(maxBackoff) {
    if (maxBackoff == null) {
      throw new Error("maxBackoff cannot be null.");
    } else if (maxBackoff < this._minBackoff) {
      throw new Error("maxBackoff cannot be smaller than minBackoff.");
    }
    this._maxBackoff = maxBackoff;
    return this;
  }
  get maxBackoff() {
    return this._maxBackoff;
  }
  async ping(accountId) {
    try {
      await new AccountBalanceQuery({ accountId }).setNodeAccountIds([
        accountId instanceof AccountId ? accountId : AccountId.fromString(accountId)
      ]).execute(this);
    } catch (_) {
    }
  }
  async pingAll() {
    for (const nodeAccountId of Object.values(this._network.network)) {
      await this.ping(nodeAccountId);
    }
  }
  close() {
    this._network.close();
    this._mirrorNetwork.close();
  }
  _createNetworkChannel() {
    throw new Error("not implemented");
  }
  _createMirrorNetworkChannel() {
    throw new Error("not implemented");
  }
};

// node_modules/@hashgraph/sdk/src/channel/Channel.js
var import_proto8 = __toModule(require_lib());
var Channel = class {
  constructor() {
    this._crypto = null;
    this._smartContract = null;
    this._file = null;
    this._consensus = null;
    this._freeze = null;
    this._network = null;
    this._token = null;
    this._schedule = null;
  }
  close() {
    throw new Error("not implemented");
  }
  get crypto() {
    if (this._crypto != null) {
      return this._crypto;
    }
    this._crypto = import_proto8.CryptoService.create(this._createUnaryClient("CryptoService"));
    return this._crypto;
  }
  get smartContract() {
    if (this._smartContract != null) {
      return this._smartContract;
    }
    this._smartContract = import_proto8.SmartContractService.create(this._createUnaryClient("SmartContractService"));
    return this._smartContract;
  }
  get file() {
    if (this._file != null) {
      return this._file;
    }
    this._file = import_proto8.FileService.create(this._createUnaryClient("FileService"));
    return this._file;
  }
  get consensus() {
    if (this._consensus != null) {
      return this._consensus;
    }
    this._consensus = import_proto8.ConsensusService.create(this._createUnaryClient("ConsensusService"));
    return this._consensus;
  }
  get freeze() {
    if (this._freeze != null) {
      return this._freeze;
    }
    this._freeze = import_proto8.FreezeService.create(this._createUnaryClient("FreezeService"));
    return this._freeze;
  }
  get network() {
    if (this._network != null) {
      return this._network;
    }
    this._network = import_proto8.NetworkService.create(this._createUnaryClient("NetworkService"));
    return this._network;
  }
  get token() {
    if (this._token != null) {
      return this._token;
    }
    this._token = import_proto8.TokenService.create(this._createUnaryClient("TokenService"));
    return this._token;
  }
  get schedule() {
    if (this._schedule != null) {
      return this._schedule;
    }
    this._schedule = import_proto8.ScheduleService.create(this._createUnaryClient("ScheduleService"));
    return this._schedule;
  }
  _createUnaryClient(serviceName) {
    throw new Error("not implemented");
  }
};
function encodeRequest(data) {
  const frame = new ArrayBuffer(data.byteLength + 5);
  new DataView(frame, 1, 4).setUint32(0, data.length);
  new Uint8Array(frame, 5).set(data);
  return frame;
}
function decodeUnaryResponse(data, byteOffset = 0, byteLength = data.byteLength) {
  const dataView = new DataView(data, byteOffset, byteLength);
  let dataOffset = 0;
  let unaryResponse = null;
  let status = 0;
  while (dataOffset < dataView.byteLength) {
    const frameByte = dataView.getUint8(dataOffset + 0);
    const frameType = frameByte >> 7;
    const frameByteLength = dataView.getUint32(dataOffset + 1);
    const frameOffset = dataOffset + 5;
    if (frameOffset + frameByteLength > dataView.byteLength) {
      throw new Error("(BUG) unexpected frame length past the boundary");
    }
    const frameData = new Uint8Array(data, dataView.byteOffset + frameOffset, frameByteLength);
    if (frameType === 0) {
      if (unaryResponse != null) {
        throw new Error("(BUG) unexpectedly received more than one data frame");
      }
      unaryResponse = frameData;
    } else if (frameType === 1) {
      const trailer = decode6(frameData);
      const [trailerName, trailerValue] = trailer.split(":");
      if (trailerName === "grpc-status") {
        status = parseInt(trailerValue);
      } else {
        throw new Error(`(BUG) unhandled trailer, ${trailer}`);
      }
    } else {
      throw new Error(`(BUG) unexpected frame type: ${frameType}`);
    }
    dataOffset += frameByteLength + 5;
  }
  if (status !== 0) {
    throw new Error(`(BUG) unhandled grpc-status: ${status}`);
  }
  if (unaryResponse == null) {
    throw new Error("(BUG) unexpectedly received no response");
  }
  return unaryResponse;
}

// node_modules/@hashgraph/sdk/src/channel/WebChannel.js
var WebChannel = class extends Channel {
  constructor(address) {
    super();
    this._address = address;
  }
  close() {
  }
  _createUnaryClient(serviceName) {
    return async (method, requestData, callback) => {
      const response = await fetch(`${this._address}/proto.${serviceName}/${method.name}`, {
        method: "POST",
        headers: {
          "content-type": "application/grpc-web+proto",
          "x-user-agent": "hedera-sdk-js/v2",
          "x-grpc-web": "1"
        },
        body: encodeRequest(requestData)
      });
      const responseBuffer = await response.arrayBuffer();
      const unaryResponse = decodeUnaryResponse(responseBuffer);
      callback(null, unaryResponse);
    };
  }
};

// node_modules/@hashgraph/sdk/src/client/WebClient.js
var Network2 = {
  fromName(name) {
    switch (name) {
      case "mainnet":
        return Network2.MAINNET;
      case "testnet":
        return Network2.TESTNET;
      case "previewnet":
        return Network2.PREVIEWNET;
      default:
        throw new Error(`unknown network name: ${name}`);
    }
  },
  MAINNET: {
    "https://grpc-web.myhbarwallet.com": new AccountId(3)
  },
  TESTNET: {
    "https://grpc-web.testnet.myhbarwallet.com": new AccountId(3)
  },
  PREVIEWNET: {
    "https://grpc-web.previewnet.myhbarwallet.com": new AccountId(3)
  }
};
var WebClient = class extends Client {
  constructor(props) {
    super(props);
    if (props != null) {
      if (typeof props.network === "string") {
        switch (props.network) {
          case "mainnet":
            this.setNetwork(Network2.MAINNET);
            this.setNetworkName("mainnet");
            break;
          case "testnet":
            this.setNetwork(Network2.TESTNET);
            this.setNetworkName("testnet");
            break;
          case "previewnet":
            this.setNetwork(Network2.PREVIEWNET);
            this.setNetworkName("previewnet");
            break;
          default:
            throw new Error(`unknown network: ${props.network}`);
        }
      } else if (props.network != null) {
        this.setNetwork(props.network);
      }
    }
  }
  static fromConfig(data) {
    return new WebClient(typeof data === "string" ? JSON.parse(data) : data);
  }
  static forNetwork(network) {
    return new WebClient({ network });
  }
  static forName(network) {
    return new WebClient({ network });
  }
  static forMainnet() {
    return new WebClient({ network: "mainnet" });
  }
  static forTestnet() {
    return new WebClient({ network: "testnet" });
  }
  static forPreviewnet() {
    return new WebClient({ network: "previewnet" });
  }
  setNetwork(network) {
    if (typeof network === "string") {
      switch (network) {
        case "previewnet":
          this._network.setNetwork(Network2.PREVIEWNET);
          break;
        case "testnet":
          this._network.setNetwork(Network2.TESTNET);
          break;
        case "mainnet":
          this._network.setNetwork(Network2.MAINNET);
      }
    } else {
      this._network.setNetwork(network);
    }
  }
  setMirrorNetwork(mirrorNetwork) {
    if (typeof mirrorNetwork === "string") {
      this._mirrorNetwork.setNetwork([]);
    } else {
      this._mirrorNetwork.setNetwork(mirrorNetwork);
    }
    return this;
  }
  _createNetworkChannel() {
    return (address) => new WebChannel(address);
  }
  _createMirrorNetworkChannel() {
    return () => {
      throw new Error("mirror support is not supported in browsers");
    };
  }
};
export {
  AccountBalanceQuery,
  AccountCreateTransaction,
  AccountDeleteTransaction,
  AccountId,
  AccountInfo,
  AccountInfoQuery,
  AccountRecordsQuery,
  AccountStakersQuery,
  AccountUpdateTransaction,
  AssessedCustomFee,
  BadKeyError,
  BadMnemonicError,
  BadMnemonicReason_default as BadMnemonicReason,
  WebClient as Client,
  ContractByteCodeQuery,
  ContractCallQuery,
  ContractCreateTransaction,
  ContractDeleteTransaction,
  ContractExecuteTransaction,
  ContractFunctionParameters,
  ContractFunctionResult,
  ContractFunctionSelector,
  ContractId,
  ContractInfo,
  ContractInfoQuery,
  ContractLogInfo,
  ContractUpdateTransaction,
  CustomFee,
  CustomFixedFee,
  CustomFractionalFee,
  CustomRoyalyFee as CustomRoyaltyFee,
  ExchangeRate,
  FileAppendTransaction,
  FileContentsQuery,
  FileCreateTransaction,
  FileDeleteTransaction,
  FileId,
  FileInfo,
  FileInfoQuery,
  FileUpdateTransaction,
  FreezeTransaction,
  Hbar,
  HbarUnit,
  Key2 as Key,
  KeyList2 as KeyList,
  LiveHash,
  LiveHashAddTransaction,
  LiveHashDeleteTransaction,
  LiveHashQuery,
  Mnemonic2 as Mnemonic,
  NetworkName_default as NetworkName,
  NetworkVersionInfo,
  NetworkVersionInfoQuery,
  NftId,
  PrecheckStatusError,
  PrivateKey2 as PrivateKey,
  ProxyStaker,
  PublicKey2 as PublicKey,
  Query,
  ReceiptStatusError,
  ScheduleCreateTransaction,
  ScheduleDeleteTransaction,
  ScheduleId,
  ScheduleInfo,
  ScheduleInfoQuery,
  ScheduleSignTransaction,
  SemanticVersion2 as SemanticVersion,
  Status,
  StatusError,
  SystemDeleteTransaction,
  SystemUndeleteTransaction,
  Timestamp,
  TokenAssociateTransaction,
  TokenBurnTransaction,
  TokenCreateTransaction,
  TokenDeleteTransaction,
  TokenDissociateTransaction,
  TokenFeeScheduleUpdateTransaction,
  TokenFreezeTransaction,
  TokenGrantKycTransaction,
  TokenId,
  TokenInfo2 as TokenInfo,
  TokenInfoQuery,
  TokenMintTransaction,
  TokenNftInfo,
  TokenNftInfoQuery,
  TokenPauseTransaction,
  TokenRevokeKycTransaction,
  TokenSupplyType,
  TokenType,
  TokenUnfreezeTransaction,
  TokenUnpauseTransaction,
  TokenUpdateTransaction,
  TokenWipeTransaction,
  TopicCreateTransaction,
  TopicDeleteTransaction,
  TopicId,
  TopicInfo,
  TopicInfoQuery,
  TopicMessage,
  TopicMessageChunk,
  TopicMessageQuery,
  TopicMessageSubmitTransaction,
  TopicUpdateTransaction,
  Transaction,
  TransactionId,
  TransactionReceipt,
  TransactionReceiptQuery,
  TransactionRecord,
  TransactionRecordQuery,
  TransactionResponse,
  Transfer,
  TransferTransaction
};
//# sourceMappingURL=@hashgraph_sdk.js.map
